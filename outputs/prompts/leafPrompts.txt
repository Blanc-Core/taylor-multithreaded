
# **Instructions**

## **ComponentRequirements**
- You will be given the requirements for a component. Create **complete React code** only for the component and nothing else.
- Ensure the React code works flawlessly using the **latest version of React**.
- **DO NOT** summarize or leave anything out. All functionality must be fully implemented and working together.
- `Component Name: MetricCard, Component requirements: ### Final Plan

#### **Component Description**
- **MetricCard Enhancements**
  - Displays individual metrics for each startup with added features to improve user engagement and data analysis. The component will be visually appealing, focusing on usability and information density, ensuring that users can make data-driven decisions with ease.

#### **Functionality**
- **MetricCard Details**
  - Each MetricCard showcases a specific growth metric (e.g., Monthly Active Users, Revenue, Customer Acquisition Cost), with enhanced interactivity and a cohesive design that encourages user exploration and understanding.

#### **Improvements and Features**
1. **Dynamic Comparison Feature**
   - **Description:** Users can select multiple MetricCards to compare metrics side-by-side.
   - **Implementation:** 
     - Add checkboxes on each MetricCard for users to select metrics for comparison.
     - Use a modal or separate comparison view to show selected metrics.
   - **Data Requirements:** Dummy data for multiple metrics (e.g., MAU, Revenue) for selected startups.
   - **User Interaction Flow:** After selecting metrics, a comparison chart appears, allowing users to visualize differences.
   - **Challenges/Solutions:** 
     - Managing state for selected metrics could be complex; utilize React context to handle state effectively.
     - Ensure performance by only rendering components that are currently in the view.

2. **Customizable Metric Views**
   - **Description:** Users can customize which metrics they want to display on the MetricCard.
   - **Implementation:** 
     - Provide a settings icon on the page that leads to a modal for selecting visible metrics.
     - Save user preferences using local storage or context API.
   - **Data Requirements:** Dummy data for available metrics (e.g., CAC, churn rate).
   - **User Interaction Flow:** Users can check/uncheck metrics in the modal, and the MetricCards update dynamically.
   - **Challenges/Solutions:** 
     - Ensure the UI remains responsive; use Ant Design's Grid system for layout adjustments.
     - Validate user selections to prevent displaying conflicting metrics.

3. **Gamification Elements**
   - **Description:** Introduce badges for metrics achievement (e.g., reaching a certain MAU).
   - **Implementation:** 
     - Add a badge icon on MetricCards that changes based on user-defined thresholds.
     - Create a badge library that defines thresholds and user achievements.
   - **Data Requirements:** Dummy data for thresholds and user achievements.
   - **User Interaction Flow:** Users can click on badges to learn more about the achievements and how to reach the next level.
   - **Challenges/Solutions:** 
     - Balancing between informative and overwhelming; ensure badges are visually distinct but not cluttered.
     - Consider user feedback to refine badge design and criteria.

4. **Integrated Notifications**
   - **Description:** Provide notifications for significant changes in metrics (e.g., sudden drop in revenue).
   - **Implementation:** 
     - Use a notification system to alert users based on predefined criteria (e.g., percentage change).
     - Integrate a dismiss or view later option for users to manage notifications effectively.
   - **Data Requirements:** Dummy data to simulate metric changes over time.
   - **User Interaction Flow:** Notifications appear as pop-ups and can be dismissed or viewed later.
   - **Challenges/Solutions:** 
     - Ensuring timely notifications without overwhelming users; allow users to set notification preferences to tailor their experience.

5. **Data Visualization Enhancements**
   - **Description:** Use ECharts to create interactive graphs and charts in the detailed view.
   - **Implementation:** 
     - Integrate ECharts to visualize historical trends and projections interactively.
     - Ensure charts are responsive and provide a variety of visualization options (line charts, bar graphs, etc.).
   - **Data Requirements:** Dummy data for historical metrics (e.g., MAU growth over the last year).
   - **User Interaction Flow:** Users can hover over data points for additional information, and click to filter data.
   - **Challenges/Solutions:** 
     - Ensuring performance; optimize chart rendering with React's lifecycle methods.
     - Consider lazy loading for heavy datasets to improve initial load times.

#### **Interconnectivity**
- **Cross-Page Metric Analysis**
  - MetricCard data will continue to be shared with the Health Dashboard for comprehensive analysis. This requires a shared state management approach (e.g., Redux or Context API) to ensure data consistency across components.

#### **User Interaction**
- **Interactions with MetricCards**
  - Users can click for detailed views, select for comparisons, customize visibility, and respond to notifications. Ensure intuitive navigation and feedback mechanisms to enhance user experience.

#### **Prioritization**
1. **Dynamic Comparison Feature** - High impact, feasible.
2. **Customizable Metric Views** - High impact, feasible.
3. **Data Visualization Enhancements** - High impact, slightly more complex but feasible.
4. **Integrated Notifications** - Medium impact, feasible.
5. **Gamification Elements** - Medium impact, feasible.

#### **Conclusion**
This plan enhances the MetricCard component for a professional ERP system, focusing on user engagement, interactivity, and data visualization while ensuring a streamlined experience within a desktop application context. All features are designed to use dummy data, maintaining simplicity and ease of implementation.

---

### Step-by-Step Plan

#### **Description**
Based on the user's request, here's a step-by-step plan to implement the MetricCard enhancements.

#### **Steps**
1. **Clarification**
   - Ensure all features are well-defined and aligned with user expectations to avoid scope creep during implementation.

2. **Dynamic Comparison Feature Implementation Guidance**
   - **Core Logic:** Enable users to select metrics for comparison using checkboxes.
   - **Error Handling:** Validate that at least two metrics are selected before allowing comparison.
   - **Dependencies:** React context for state management; ECharts or Chart.js for visualization.
   - **Example:** When two MetricCards are selected, display a side-by-side comparison of MAU and Revenue.

3. **Customizable Metric Views Implementation Guidance**
   - **Core Logic:** Create a modal for users to select visible metrics.
   - **Error Handling:** Check that at least one metric is selected.
   - **Dependencies:** Local storage or context API for saving user preferences.
   - **Example:** Users select which metrics to display from a checklist, and the MetricCards refresh accordingly.

4. **Gamification Elements Implementation Guidance**
   - **Core Logic:** Track user achievements and display badges based on performance.
   - **Error Handling:** Ensure badges only display once thresholds are met.
   - **Dependencies:** State management for user achievements.
   - **Example:** A user reaches 1,000 MAU and earns a "Growth Achiever" badge.

5. **Integrated Notifications Implementation Guidance**
   - **Core Logic:** Monitor metrics for significant changes and trigger notifications.
   - **Error Handling:** Ensure notifications are not spammed; use a debounce mechanism.
   - **Dependencies:** Notification library (e.g., Ant Design notifications).
   - **Example:** A pop-up appears when revenue drops by more than 10%.

6. **Data Visualization Enhancements Implementation Guidance**
   - **Core Logic:** Utilize ECharts to create interactive charts for metric visualization.
   - **Error Handling:** Check for data integrity before rendering charts.
   - **Dependencies:** ECharts library.
   - **Example:** A line chart showing MAU growth over the last year, with tooltips for each data point.

#### **Efficiency**
- Structure the plan logically, allowing for modular coding practices. Each feature should be developed as a separate component when possible.

#### **Technical Specifications**
- **Frameworks/Libraries:** React, ECharts, Ant Design (for UI components).
- **Methods/Classes:** Use functional components and hooks for state management.

#### **Examples**
- For the Dynamic Comparison Feature, provide a snippet showing how to handle checkbox state changes and render the comparison chart.

#### **Edge Cases**
- Identify scenarios where no metrics are selected or when there are no changes to notify the user about. Test these cases thoroughly.

#### **Enhancements**
- Consider implementing a tutorial or help section to guide users through new features, improving onboarding and user satisfaction.

This comprehensive plan covers all aspects of the MetricCard enhancement, ensuring a robust and user-friendly implementation for a professional ERP system.`

## **FileRequirements**
- Create **1 JS file** with **no styling**.
- Use only **dummy data**. **No backend** or API calls, only dummy data should be used.
- The entire file should be **self-contained**. **DO NOT** import any other JS files or components.

## **Rules**

### **General**
- **No errors or bugs** allowed. The code must work perfectly on the first try.
- Provide **complete, fully functional code** with no missing implementations or placeholder logic.
- **DO NOT** ask the user to implement anything. **DO NOT** leave out any code. Recreate everything within this file, and **DO NOT** import any external JS files or components.
- All necessary code must be included in this file, fully implemented, and functional with **no missing parts**.

### **ResponseFormat**
- Output **only** the requested code or response. **DO NOT** include explanations, comments, or additional information. Respond with the **complete code only**.

### **NoHeader**
- **DO NOT** include a header or any boilerplate explanations. Start **directly** with the code implementation.

## **ComponentRequirements**
- The component must be **fully implemented**, with **all functionality** integrated. **Nothing should be left out** or incomplete. Ensure all pieces work together seamlessly, and the code is ready to run without any issues.



# **Instructions**

## **ComponentRequirements**
- You will be given the requirements for a component. Create **complete React code** only for the component and nothing else.
- Ensure the React code works flawlessly using the **latest version of React**.
- **DO NOT** summarize or leave anything out. All functionality must be fully implemented and working together.
- `Component Name: AvailabilityIndicator, Component requirements: ### Final Plan for the Availability Indicator Component in a Professional ERP

#### **Component Description**
The AvailabilityIndicator component displays the real-time availability status of a mentor for startups. This feature is essential for enabling startups to quickly assess whether they can engage with a mentor without unnecessary delays.

---

#### **Functionality Overview**
The AvailabilityIndicator will feature dynamic updates based on the mentor's real-time schedule, indicating if they are available, busy, or completely booked. A user-friendly design with color-coded indicators will enhance usability and reduce the need for additional queries regarding mentor availability.

---

#### **Key Components and Features to Enhance User Experience**

1. **Color-Coded Status Indicators**
   - **Description:** Visual representation of mentor availability.
   - **Implementation:** Utilize Ant Design’s Badge component.
     - **Colors:** 
       - Green for Available
       - Red for Busy
       - Grey for Booked
     - **Code Example:** 
       ```javascript
       <Badge status="success" text="Available" />
       <Badge status="error" text="Busy" />
       <Badge status="default" text="Booked" />
       ```

2. **Text Descriptions**
   - **Description:** Provide text descriptions alongside color-coded indicators.
   - **Implementation:** Use Tooltip component for hover description.
     - **Code Example:**
       ```javascript
       <Tooltip title="Available" placement="top">
         <Badge status="success" />
       </Tooltip>
       ```

3. **Real-Time Updates**
   - **Description:** Dynamic updates to reflect mentor’s current commitments.
   - **Implementation:** Simulate schedule updates using an array of mentor availability objects.
     - **Code Structure:**
       ```javascript
       const [availability, setAvailability] = useState(initialAvailability);
       useEffect(() => {
         const interval = setInterval(() => {
           // Update availability logic here
         }, 5000);
         return () => clearInterval(interval);
       }, []);
       ```

4. **Tooltip Interaction**
   - **Description:** Detailed availability information in a tooltip.
   - **Implementation:** Show specific time slots in the tooltip on hover.
     - **Code Example:**
       ```javascript
       <Tooltip title={getDetailedAvailability(availability)} placement="top">
         <Badge status={getStatusColor(availability)} />
       </Tooltip>
       ```

5. **User Interaction Flow**
   - **Description:** Redirect to booking page when an available slot is clicked.
   - **Implementation:** Use React Router for navigation.
     - **Code Example:**
       ```javascript
       <Link to="/booking">
         <Badge status="success" onClick={() => handleBookingClick()} />
       </Link>
       ```

6. **Notifications**
   - **Description:** Users can subscribe to availability change notifications.
   - **Implementation:** Allow users to opt-in for notifications via a toggle.
     - **Code Structure:**
       ```javascript
       const [notificationsEnabled, setNotificationsEnabled] = useState(false);
       ```

7. **Gamification Elements**
   - **Description:** Points system for frequent engagement.
   - **Implementation:** Display a points badge next to the availability indicator.
     - **Code Example:**
       ```javascript
       <span>{points} points earned!</span>
       ```

8. **Customization Options**
   - **Description:** Users can set their preferred notification methods.
   - **Implementation:** Create a settings modal for toggling preferences.
     - **Code Structure:**
       ```javascript
       <Modal>
         <Switch checked={emailNotifications} onChange={setEmailNotifications} />
       </Modal>
       ```

9. **Data Visualization**
   - **Description:** Mini dashboard showing trends in mentor availability.
   - **Implementation:** Create line charts using ECharts.
     - **Code Example:**
       ```javascript
       <LineChart data={availabilityData} />
       ```

10. **Interactive Calendar**
    - **Description:** Highlight available dates for mentorship sessions.
    - **Implementation:** Use a calendar component from Ant Design.
      - **Code Example:**
        ```javascript
        <Calendar dateCellRender={dateCellRender} />
        ```

---

#### **User Interaction Flow**
1. User views the AvailabilityIndicator on the dashboard.
2. They hover over the indicator to see detailed availability via tooltip.
3. If the mentor is available, clicking the green indicator redirects them to the booking page.
4. Users can set notification preferences for future availability changes.
5. Users can view availability trends and upcoming availability in a mini calendar view.

---

#### **Potential Challenges and Solutions**
1. **Real-time Data Simulation**
   - **Challenge:** Complexity in simulating real-time updates.
   - **Solution:** Randomly change availability status at timed intervals to reflect realistic scenarios.
   - **Code Example:**
     ```javascript
     const randomizeAvailability = () => {
       // Logic to randomly change mentor's availability
     };
     ```

2. **User Engagement with Notifications**
   - **Challenge:** Users may ignore notifications.
   - **Solution:** Introduce rewards for frequent engagement with mentors.

3. **Integration with Other Components**
   - **Challenge:** Ensuring the AvailabilityIndicator works well with existing components.
   - **Solution:** Maintain consistent design patterns and clear documentation.

---

#### **Prioritization of Ideas**
1. **Color-Coded Status Indicators** - High impact, easy implementation.
2. **Real-Time Updates** - High impact, moderate complexity.
3. **Text Descriptions & Tooltip Interaction** - Medium impact, straightforward implementation.
4. **User Interaction Flow** - High impact, essential for usability.
5. **Notifications** - Medium impact, feasible with moderate effort.
6. **Gamification Elements** - Medium impact, requires more design consideration.
7. **Data Visualization** - Medium impact, complex but valuable for user insights.
8. **Interactive Calendar** - Medium impact, enhances user experience.
9. **Customization Options** - Low impact, adds user flexibility but complex.
10. **Mini Dashboard** - Low impact, requires extensive data management.

---

This comprehensive plan outlines the development of the AvailabilityIndicator component, ensuring a user-friendly, interactive, and visually engaging experience for startups seeking mentorship. Each feature is designed to work together, creating a cohesive user experience that facilitates engagement and enhances the overall functionality of the ERP system.`

## **FileRequirements**
- Create **1 JS file** with **no styling**.
- Use only **dummy data**. **No backend** or API calls, only dummy data should be used.
- The entire file should be **self-contained**. **DO NOT** import any other JS files or components.

## **Rules**

### **General**
- **No errors or bugs** allowed. The code must work perfectly on the first try.
- Provide **complete, fully functional code** with no missing implementations or placeholder logic.
- **DO NOT** ask the user to implement anything. **DO NOT** leave out any code. Recreate everything within this file, and **DO NOT** import any external JS files or components.
- All necessary code must be included in this file, fully implemented, and functional with **no missing parts**.

### **ResponseFormat**
- Output **only** the requested code or response. **DO NOT** include explanations, comments, or additional information. Respond with the **complete code only**.

### **NoHeader**
- **DO NOT** include a header or any boilerplate explanations. Start **directly** with the code implementation.

## **ComponentRequirements**
- The component must be **fully implemented**, with **all functionality** integrated. **Nothing should be left out** or incomplete. Ensure all pieces work together seamlessly, and the code is ready to run without any issues.



# **Instructions**

## **ComponentRequirements**
- You will be given the requirements for a component. Create **complete React code** only for the component and nothing else.
- Ensure the React code works flawlessly using the **latest version of React**.
- **DO NOT** summarize or leave anything out. All functionality must be fully implemented and working together.
- `Component Name: InvestorProfileCard, Component requirements: ### Final Plan for Investor Profile Component

#### Description
The InvestorProfileCard is a pivotal component showcasing essential investor information, enhancing user experience by enabling quick access and efficient updates. It serves as a centralized point for managing investor details and interactions.

#### Content
- **Component Description**: Displays basic investor information such as name, organization, and contact details.
- **Functionality**: 
    - Provides a succinct overview of the investor's basic information.
    - Includes editable fields for updating the investor's name, organization, title, and primary contact details.
    - Facilitates direct interactions for editing and maintains accurate records.
  
- **Details**:
    - The card should display the investor's name prominently with their organization and contact information.
    - An 'Edit' button should allow users to toggle fields into edit mode, enabling updates to the investor's details.
    - In edit mode, fields like name and contact should become input fields with validation checks.
    - Changes should be saved to the state and trigger backend updates upon submission.

- **Visibility**: True
- **Interconnectivity**:
    - Can be reused on other pages where investor details are needed, such as a summary on an Investor List Page.
- **User Interaction**:
    - Edit button on the InvestorProfileCard.
    - Clicking 'Edit' turns fields into editable input fields.
    - Upon clicking 'Save', updated information will be sent to the backend and reflected in the UI.

### Improvements and Enhancements

1. **User Engagement Features**
    - **Activity Log**: Displays recent interactions with the investor (e.g., meetings, emails).
        - **Implementation**: Integrate a collapsible list showing recent interactions.
        - **User Interaction**: Clickable items expand to show details, providing users with context.

2. **Data Visualization Module**
    - **Investment Overview Chart**: Visual representation of investment history or portfolio performance.
        - **Implementation**: Use ECharts to create a chart component.
        - **User Interaction**: Hover over chart elements for detailed investment information.

3. **Interactivity Enhancements**
    - **Comments Section**: Collaborative space for users to leave notes or feedback about the investor.
        - **Implementation**: A text area for adding comments, with a list displaying previous comments.
        - **User Interaction**: Users can add, edit, or delete comments.

4. **Information Presentation Improvements**
    - **Summary Card**: Summarizes key metrics related to the investor, such as total investments or ROI.
        - **Implementation**: Design a card that aggregates and displays dummy metrics.
        - **User Interaction**: Clicking the card opens a detailed view.

5. **Productivity Tools**
    - **Task Management**: Users can set reminders or tasks related to the investor.
        - **Implementation**: A section for task creation and management with dummy task data.
        - **User Interaction**: Users can create, edit, or mark tasks as complete.

6. **Customization Options**
    - **Theme Selector**: Allows users to switch between different themes (light/dark mode).
        - **Implementation**: A toggle button to change the theme dynamically.
        - **User Interaction**: Immediate visual feedback on theme changes.

7. **Gamification Elements**
    - **Achievement Badges**: Display badges for milestones reached with the investor.
        - **Implementation**: A section showing earned badges with dummy achievement data.
        - **User Interaction**: Clickable badges that provide more context on achievements.

8. **Dynamic Content Updates**
    - **Real-time Notifications**: Notify users of updates related to the investor, such as new investments or activities.
        - **Implementation**: A notification icon displaying the number of updates.
        - **User Interaction**: Clicking the icon reveals recent notifications.

9. **Notifications Management**
    - **Settings for Notifications**: Customize which notifications users want to receive.
        - **Implementation**: A settings modal for notification preferences.
        - **User Interaction**: Users check/uncheck options to customize notifications.

### Planning Outline for Enhancements

- **Elements**
    - **Main Functionality**: Integrate new modules for engagement, visualization, interactivity, and productivity.
    - **Key Components or Modules**: Activity Log, Investment Overview Chart, Comments Section, Summary Card, Task Management, Theme Selector, Achievement Badges, Real-time Notifications, Notifications Management.
    - **Data Requirements**: Use dummy data for visualization and interactions (e.g., recent interactions, investment history, task lists).
    - **User Interaction Flow**: Users interact with each module through clicks, edits, and selections, leading to dynamic updates in the investor profile view.
    - **Potential Challenges and Solutions**: 
        - **Challenge**: Managing state across multiple components. 
        - **Solution**: Use a centralized state management approach (e.g., React Context) to maintain data consistency.
        - **Challenge**: Ensuring user-friendly interactions.
        - **Solution**: Conduct usability testing to refine interactions based on user feedback.

### Step-by-Step Plan for Implementation

1. **Clarification**
    - Ensure all components are clearly defined, with specific interactions and data requirements outlined.

2. **Implementation Guidance**
    - **Activity Log**:
        - Create a collapsible list that fetches and displays recent interactions. Utilize dummy data for initial implementation.
        - Implement expandable functionality for detailed views.

    - **Investment Overview Chart**:
        - Integrate ECharts to visualize investment data.
        - Set up event listeners for hover actions to display tooltips with detailed information.

    - **Comments Section**:
        - Create a text area with a list to show previous comments.
        - Implement add, edit, and delete functionalities for comments, ensuring state updates accordingly.

    - **Summary Card**:
        - Develop a card component that compiles key metrics.
        - Include a click event to transition to a detailed metrics view.

    - **Task Management**:
        - Build a task management section with forms for adding tasks.
        - Create list functionality for editing and marking tasks as complete.

    - **Theme Selector**:
        - Implement a toggle switch that changes the theme via CSS classes.
        - Use local storage to persist user preferences.

    - **Achievement Badges**:
        - Design a badge component to display achievements.
        - Allow interaction for users to explore badge details.

    - **Real-time Notifications**:
        - Create a notification icon that updates based on activity.
        - Implement a dropdown to show recent notifications upon user interaction.

    - **Notifications Management**:
        - Develop a modal for users to customize notification preferences.
        - Ensure user selections save and affect future notifications.

3. **Efficiency**
    - Structure the components logically, ensuring code reusability and modularity.
    - Utilize hooks and context for state management to improve performance.

4. **Technical Specifications**
    - Use a front-end framework such as React for component structure.
    - Implement ECharts for data visualization and ensure compatibility with various browsers.

5. **Examples**
    - Use sample data for initial testing (e.g., investor names, contact info, investment amounts).
    - Create visual mockups to guide development.

6. **Edge Cases**
    - Test for empty fields in the comments section and ensure validation exists.
    - Ensure the chart renders correctly with no data and handles errors gracefully.

7. **Enhancements**
    - Consider integrating third-party libraries for better UI components (e.g., Material-UI).
    - Explore performance optimization techniques, such as code splitting and lazy loading for large components.

### Prioritization
1. **Investment Overview Chart** (High impact, moderate feasibility)
2. **Activity Log** (High impact, high feasibility)
3. **Comments Section** (Medium impact, high feasibility)
4. **Task Management** (Medium impact, moderate feasibility)
5. **Theme Selector** (Medium impact, high feasibility)
6. **Summary Card** (Medium impact, moderate feasibility)
7. **Real-time Notifications** (Medium impact, moderate feasibility)
8. **Achievement Badges** (Low impact, moderate feasibility)
9. **Notifications Management** (Low impact, high feasibility)

This comprehensive plan outlines an enriched InvestorProfileCard component that addresses user needs and enhances overall functionality, providing a robust and engaging experience. Each aspect is connected and supports the overall goal of creating a seamless user experience on the desktop platform.`

## **FileRequirements**
- Create **1 JS file** with **no styling**.
- Use only **dummy data**. **No backend** or API calls, only dummy data should be used.
- The entire file should be **self-contained**. **DO NOT** import any other JS files or components.

## **Rules**

### **General**
- **No errors or bugs** allowed. The code must work perfectly on the first try.
- Provide **complete, fully functional code** with no missing implementations or placeholder logic.
- **DO NOT** ask the user to implement anything. **DO NOT** leave out any code. Recreate everything within this file, and **DO NOT** import any external JS files or components.
- All necessary code must be included in this file, fully implemented, and functional with **no missing parts**.

### **ResponseFormat**
- Output **only** the requested code or response. **DO NOT** include explanations, comments, or additional information. Respond with the **complete code only**.

### **NoHeader**
- **DO NOT** include a header or any boilerplate explanations. Start **directly** with the code implementation.

## **ComponentRequirements**
- The component must be **fully implemented**, with **all functionality** integrated. **Nothing should be left out** or incomplete. Ensure all pieces work together seamlessly, and the code is ready to run without any issues.



# **Instructions**

## **ComponentRequirements**
- You will be given the requirements for a component. Create **complete React code** only for the component and nothing else.
- Ensure the React code works flawlessly using the **latest version of React**.
- **DO NOT** summarize or leave anything out. All functionality must be fully implemented and working together.
- `Component Name: Title, Component requirements: ### Final Plan

#### Component Description
- **Title Component**: This component displays the startup's name prominently, allowing for easy identification and editing. It serves as the first point of reference for users interacting with the startup's profile.

#### Functionality
- **Display Logic**: The Title component will always show the startup's name in a large, bold font. In edit mode, it converts to an input field for users to modify the name. Changes are saved immediately upon confirmation, ensuring updated data visibility across the platform.

#### Details
- **Text Styling**: 
    - Default mode: Large, bold font (e.g., FontSize: 24px, FontWeight: 700).
    - Edit mode: Text input styled to match the default font but with a character limit of 50 to prevent overflow.
- **Input Validation**: Prevent users from entering special characters and enforce length constraints through regex validation.

#### Visibility
- The Title component is permanently visible and accessible on the startup’s profile card.

#### Interconnectivity
- **Linkage**: The Title component links to detailed funding information at `/funding-overview/:startupId`, allowing users to directly access relevant data.

#### User Interaction
- **Edit Mode Activation**: Users click the startup name to enter edit mode.
- **Immediate Update**: Once a new name is entered and saved, the display updates immediately.
- **Input Field Behavior**: The input field pre-fills with the current name, enabling straightforward editing.
- **Validation Feedback**: Provide real-time feedback on validation errors (e.g., "Invalid characters" message).

### Enhanced Features and Components

1. **Dynamic Tagline Component**
    - **Description**: Displays a tagline or mission statement below the startup's name.
    - **Functionality**: Editable in a manner similar to the startup name.
    - **Details**: Use a smaller, italicized font (e.g., FontSize: 18px, FontStyle: italic).
    - **User Interaction**: Click to edit with similar validations as the Title component.

2. **Funding Overview Graph**
    - **Description**: A line graph showing funding history over time.
    - **Functionality**: 
        - Utilize ECharts to visualize funding rounds.
        - Dummy data to simulate funding rounds and amounts.
    - **User Interaction Flow**: Hovering over data points reveals funding details (amount and date).
    - **Challenges**: Ensure accuracy by using well-structured dummy data that represents realistic funding scenarios.

3. **Collaborators Section**
    - **Description**: Lists team members or collaborators associated with the startup.
    - **Functionality**: Users can add, edit, or remove collaborator details.
    - **Details**: Each entry includes name, role, and contact information.
    - **User Interaction**: 
        - "Add Collaborator" button for input.
        - Edits and deletions are performed through a dedicated button for each collaborator.
    - **Challenges**: Manage dynamic lists using React state management for real-time updates.

4. **Notifications Panel**
    - **Description**: Displays recent notifications related to startup activities.
    - **Functionality**: Users can view updates like new funding opportunities or messages.
    - **User Interaction**: Users can mark notifications as read or dismiss them.
    - **Challenges**: Ensure notifications remain relevant; implement categorization and timestamps for effective sorting.

5. **Customization Options**
    - **Description**: Users can customize their profile card display settings.
    - **Functionality**: Theme selection, font sizes, and layout adjustments.
    - **User Interaction**: A settings button opens a modal for customization options.
    - **Challenges**: Ensure changes are saved efficiently and applied dynamically (use hooks for state management).

### Prioritization of Ideas
1. **Dynamic Tagline Component** - High impact for branding and user engagement.
2. **Funding Overview Graph** - Essential for visual data representation.
3. **Collaborators Section** - Increases productivity and visibility among team members.
4. **Notifications Panel** - Enhances user experience through timely updates.
5. **Customization Options** - Provides a personalized user experience, though may require more development time.

### Additional Considerations
- **User Engagement**: Implement a feedback mechanism for users to suggest features.
- **Data Visualization**: Ensure graphs are interactive, enabling users to explore data deeply.
- **Interactivity**: Add hover effects and subtle animations for a polished user experience.
- **Information Presentation**: Utilize tooltips to provide additional information without cluttering the interface.
- **Productivity Tools**: Include keyboard shortcuts for frequent actions to streamline user workflow.
- **Gamification Elements**: Introduce badges or points for profile completion or active participation.
- **Dynamic Content Updates**: Refresh content based on user interactions to maintain relevance.
- **Notification Alerts**: Implement badge alerts for unread notifications to attract user attention.

### Step-by-Step Plan

#### 1. Title Component Implementation
   - **Clarification**: Implement a title component that supports both display and edit modes.
   - **Implementation Guidance**:
     - Create a state to manage edit mode (use `useState`).
     - On click, toggle to edit mode and display an input field.
     - Validate input on change and provide visual feedback.
   - **Efficiency**: Structure the component to handle state management simply, using hooks.
   - **Technical Specifications**: Use React components and CSS for styling.
   - **Example**: 
     ```jsx
     const [isEditing, setIsEditing] = useState(false);
     const [startupName, setStartupName] = useState("Current Startup Name");

     return (
       <div>
         {isEditing ? (
           <input 
             type="text" 
             value={startupName} 
             onChange={(e) => setStartupName(e.target.value)} 
             onBlur={() => setIsEditing(false)} 
           />
         ) : (
           <h1 onClick={() => setIsEditing(true)}>{startupName}</h1>
         )}
       </div>
     );
     ```
   - **Edge Cases**: Handle empty input or invalid characters; provide user feedback.
   - **Enhancements**: Consider adding a save button for better control over changes.

#### 2. Dynamic Tagline Component
   - **Clarification**: Similar to the Title component but for a tagline.
   - **Implementation Guidance**: Follow the same logic for editing and displaying.
   - **Efficiency**: Reuse validation logic from the Title component.
   - **Technical Specifications**: React functional component.
   - **Example**: Implement using similar state management.
   - **Edge Cases**: Validate for a maximum character limit and special characters.

#### 3. Funding Overview Graph
   - **Clarification**: Visualize funding data over time.
   - **Implementation Guidance**: Fetch data, structure it, and feed it into ECharts.
   - **Efficiency**: Cache data to improve load times.
   - **Technical Specifications**: Use ECharts library for visualization.
   - **Example**: 
     ```jsx
     const data = [/* Dummy funding data */];
     return <ReactECharts option={chartOptions(data)} />;
     ```
   - **Edge Cases**: Handle scenarios with no data gracefully.

#### 4. Collaborators Section
   - **Clarification**: List collaborators with editable details.
   - **Implementation Guidance**: Create a dynamic list using state.
   - **Efficiency**: Use keys effectively for list rendering.
   - **Technical Specifications**: React functional components for each collaborator.
   - **Example**: 
     ```jsx
     const [collaborators, setCollaborators] = useState([]);

     return (
       <div>
         {collaborators.map(collab => (
           <Collaborator key={collab.id} data={collab} />
         ))}
         <button onClick={addCollaborator}>Add Collaborator</button>
       </div>
     );
     ```
   - **Edge Cases**: Ensure removal and updates reflect in real-time.

#### 5. Notifications Panel
   - **Clarification**: Show recent activity notifications.
   - **Implementation Guidance**: Create a panel that updates based on user activity.
   - **Efficiency**: Utilize state for real-time updates.
   - **Technical Specifications**: Use CSS for styling alerts and notifications.
   - **Example**: 
     ```jsx
     const [notifications, setNotifications] = useState([]);

     return (
       <div>
         {notifications.map(note => (
           <Notification key={note.id} data={note} />
         ))}
       </div>
     );
     ```
   - **Edge Cases**: Handle empty state gracefully.

#### 6. Customization Options
   - **Clarification**: Allow users to personalize their profile view.
   - **Implementation Guidance**: Create a modal for settings.
   - **Efficiency**: Implement hooks for state management and local storage for persistence.
   - **Technical Specifications**: Use React context to manage global settings.
   - **Example**: 
     ```jsx
     const [theme, setTheme] = useState('default');

     return (
       <SettingsModal
         theme={theme}
         onChange={setTheme}
       />
     );
     ```
   - **Edge Cases**: Ensure changes reflect immediately without lag.

### Conclusion
This comprehensive plan outlines the functionality and implementation details for each component of the ERP profile setup while ensuring interconnectivity and a seamless user experience. Each feature is designed to work together cohesively, enhancing the overall usability and engagement for users interacting with the startup's profile.`

## **FileRequirements**
- Create **1 JS file** with **no styling**.
- Use only **dummy data**. **No backend** or API calls, only dummy data should be used.
- The entire file should be **self-contained**. **DO NOT** import any other JS files or components.

## **Rules**

### **General**
- **No errors or bugs** allowed. The code must work perfectly on the first try.
- Provide **complete, fully functional code** with no missing implementations or placeholder logic.
- **DO NOT** ask the user to implement anything. **DO NOT** leave out any code. Recreate everything within this file, and **DO NOT** import any external JS files or components.
- All necessary code must be included in this file, fully implemented, and functional with **no missing parts**.

### **ResponseFormat**
- Output **only** the requested code or response. **DO NOT** include explanations, comments, or additional information. Respond with the **complete code only**.

### **NoHeader**
- **DO NOT** include a header or any boilerplate explanations. Start **directly** with the code implementation.

## **ComponentRequirements**
- The component must be **fully implemented**, with **all functionality** integrated. **Nothing should be left out** or incomplete. Ensure all pieces work together seamlessly, and the code is ready to run without any issues.



# **Instructions**

## **ComponentRequirements**
- You will be given the requirements for a component. Create **complete React code** only for the component and nothing else.
- Ensure the React code works flawlessly using the **latest version of React**.
- **DO NOT** summarize or leave anything out. All functionality must be fully implemented and working together.
- `Component Name: ExpertiseTag, Component requirements: ### Final Plan

#### **Description**
This plan outlines comprehensive enhancements for the MentorCard page, focusing on a component that highlights mentors' areas of expertise using tags. The goal is to create a professional and engaging interface utilizing React, Ant Design, and ECharts for an Enterprise Resource Planning (ERP) application, specifically tailored for desktop users.

#### **Content**
- **Component Description**: The ExpertiseTag component visually represents specific areas of expertise possessed by mentors. Tags are clickable and allow users to filter mentors based on their expertise.

- **Functionality**: This component enables users to swiftly identify mentors with suitable skill sets, enhancing the search and selection process, particularly for startups seeking specialized expertise.

- **Details**:
    - Displays mentor's areas of expertise as clickable tags.
    - Applies a distinct color scheme for easy recognition.
    - Tags are interactive, allowing filtering based on expertise.
    - Supports a broad array of expertise areas, with dynamic rendering based on mentor data.
    - Integrates with the MentorProfileList component to provide filtered results.

- **Is Visible**: True

- **Interconnectivity**:
    - Page URL: `/mentors/search`
        - Description: Redirects to a search page filtered by the selected expertise tag.

- **User Interaction**:
    - Interact: Clickable expertise tags.
    - Possible Interactions: User clicks on a 'Marketing' expertise tag.
    - Result: Filters the MentorProfileList to show only mentors with 'Marketing' expertise.
    - Result Functionality: The filtering action narrows down the list of mentors, displaying only relevant profiles.

#### **Idea Generation and Implementation Guidance**

1. **Mentor Ratings and Reviews**:
    - **Main Functionality**: Users can rate and review mentors, visible on the MentorCard.
    - **Key Components**: 
        - **Rating Stars**: Utilize Ant Design's Rate component for star ratings.
        - **Review Text Area**: A simple textarea for user comments.
        - **Average Rating Display**: Show average rating prominently on the card.
    - **Implementation**: 
        - Create state management for ratings using React hooks.
        - Validate user sessions before allowing reviews to prevent fake entries.
        - Update the MentorCard in real-time using local state or Redux for state management.
    - **Edge Cases**: 
        - Ensure users cannot review the same mentor multiple times. Test by attempting to submit a second review.
    
2. **Expertise Heatmap Visualization**:
    - **Main Functionality**: Visual representation of expertise distribution among mentors.
    - **Key Components**: 
        - **ECharts Heatmap**: Integrate ECharts for visual representation.
        - **Hover Details**: Display mentor counts on hover.
    - **Implementation**: 
        - Fetch data and format it for ECharts.
        - Ensure the heatmap is responsive to different screen sizes using CSS media queries.
    - **Edge Cases**: 
        - Handle cases with no mentors in a certain expertise area gracefully by displaying a message.

3. **Mentor Availability Calendar**:
    - **Main Functionality**: Calendar indicating when each mentor is available for consultations.
    - **Key Components**: 
        - **Calendar UI**: Use libraries like `react-calendar` for calendar display.
        - **Availability Slots**: Visual indicators for available times.
    - **Implementation**: 
        - Populate the calendar with dummy availability data.
        - Allow users to click on slots to initiate booking (integrate with a modal for booking confirmation).
    - **Edge Cases**: 
        - Ensure users can’t book past time slots. Test by attempting to select unavailable slots.

4. **Mentor Matchmaker Tool**:
    - **Main Functionality**: A questionnaire that matches users with mentors based on needs and preferences.
    - **Key Components**: 
        - **Form Inputs**: Use controlled components to capture user responses.
        - **Matching Algorithm**: Implement a simple algorithm to return mentor suggestions based on input.
    - **Implementation**: 
        - Create a form with various input types (dropdowns, checkboxes).
        - Process responses and filter mentors accordingly.
    - **Edge Cases**: 
        - Ensure the form handles empty submissions gracefully.

5. **Gamification Elements**:
    - **Main Functionality**: Introduce badges and rewards for frequent users or those who leave reviews.
    - **Key Components**: 
        - **Badge Display Section**: Area to show earned badges on user profiles.
    - **Implementation**: 
        - Define criteria for earning badges (e.g., number of reviews, session bookings).
        - Update user profiles to reflect earned badges.
    - **Edge Cases**: 
        - Handle badge display for users who have not earned any.

#### **Prioritization**
1. **Mentor Ratings and Reviews**: High impact, medium feasibility.
2. **Expertise Heatmap Visualization**: Medium impact, medium feasibility.
3. **Mentor Availability Calendar**: Medium impact, high feasibility.
4. **Mentor Matchmaker Tool**: High impact, medium feasibility.
5. **Gamification Elements**: Medium impact, high feasibility.

### Enhancements Summary
This plan emphasizes user engagement through interactive elements such as ratings and reviews, visualizations, and tools designed to enhance user experience. By incorporating these features, the MentorCard page can transform into a comprehensive resource for users seeking mentorship, significantly improving the application's functionality and appeal.

### Additional Considerations
- **Performance Optimization**: Implement lazy loading for mentor data to improve initial load time.
- **Accessibility**: Ensure all components are keyboard-navigable and screen reader-friendly.
- **User Feedback**: Incorporate a feedback mechanism to collect user insights on new features for continuous improvement.`

## **FileRequirements**
- Create **1 JS file** with **no styling**.
- Use only **dummy data**. **No backend** or API calls, only dummy data should be used.
- The entire file should be **self-contained**. **DO NOT** import any other JS files or components.

## **Rules**

### **General**
- **No errors or bugs** allowed. The code must work perfectly on the first try.
- Provide **complete, fully functional code** with no missing implementations or placeholder logic.
- **DO NOT** ask the user to implement anything. **DO NOT** leave out any code. Recreate everything within this file, and **DO NOT** import any external JS files or components.
- All necessary code must be included in this file, fully implemented, and functional with **no missing parts**.

### **ResponseFormat**
- Output **only** the requested code or response. **DO NOT** include explanations, comments, or additional information. Respond with the **complete code only**.

### **NoHeader**
- **DO NOT** include a header or any boilerplate explanations. Start **directly** with the code implementation.

## **ComponentRequirements**
- The component must be **fully implemented**, with **all functionality** integrated. **Nothing should be left out** or incomplete. Ensure all pieces work together seamlessly, and the code is ready to run without any issues.



# **Instructions**

## **ComponentRequirements**
- You will be given the requirements for a component. Create **complete React code** only for the component and nothing else.
- Ensure the React code works flawlessly using the **latest version of React**.
- **DO NOT** summarize or leave anything out. All functionality must be fully implemented and working together.
- `Component Name: FilterPanel, Component requirements: ### Final Plan for Enhanced Metrics Filtering Component

#### Previous Plan
- **Description**
    - The existing FilterPanel component allows users to filter metrics by date range, startup, or metric type.
- **Content**
    - `{'componentDescription': 'Allows users to filter metrics by date range, startup, or metric type.', 'functionality': 'The FilterPanel component provides a user interface for filtering the displayed growth metrics by various criteria. It includes interactive elements such as dropdown menus for selecting startups, date pickers for specifying date ranges, and checkboxes for selecting metric types. The panel dynamically updates the data in the MetricsOverview and MetricsTable components, ensuring users only see data relevant to their selected filters.', 'details': ['Includes a date range picker for custom date selections.', 'Dropdown menus for selecting specific startups.', 'Checkboxes for enabling or disabling specific metric types.'], 'isVisible': True, 'interconnectivity': [{'pageUrl': '/metrics/cohort', 'description': 'The FilterPanel settings can be shared with the Cohort Analytics Page for consistent filtering across pages.'}], 'userInteraction': {'interact': 'Users select filters to refine the data displayed.', 'possibleInteractions': 'Selecting a date range updates the metrics to only show data within those dates. Choosing a startup limits the metrics to that company.', 'result': 'The MetricsOverview and MetricsTable components refresh to show only the filtered data.', 'resultFunctionality': 'Filtered data updates instantly across components, providing a seamless and intuitive user experience with real-time data adjustment.'}}`

#### Improvements and New Features
1. **Enhanced Data Visualization**
   - **Main Functionality**: Integrate ECharts to display metrics visually (e.g., line graphs, bar charts) based on filtered data.
   - **Key Components**: ChartComponent, TooltipComponent for additional insights.
   - **Data Requirements**: Use dummy data arrays for various metrics (revenue, user growth, etc.).
   - **User Interaction Flow**: Users can hover over chart elements to see detailed metrics for specific dates or startups.
   - **Potential Challenges & Solutions**: Ensuring real-time data updates in charts may require optimizing rendering; use memoization to limit re-renders.

2. **Dynamic Notifications**
   - **Main Functionality**: Provide real-time notifications or alerts when specific metrics exceed user-defined thresholds.
   - **Key Components**: NotificationComponent, SettingsDialog for threshold input.
   - **Data Requirements**: Dummy thresholds and metrics to simulate alerts.
   - **User Interaction Flow**: Users set thresholds; notifications pop up when conditions are met.
   - **Potential Challenges & Solutions**: Managing user preferences for notifications; implement a user preference storage mechanism.

3. **Customizable Dashboard**
   - **Main Functionality**: Allow users to customize their dashboard layout, selecting which metrics and visualizations to display.
   - **Key Components**: DashboardSettingsComponent, DraggableComponent for layout adjustments.
   - **Data Requirements**: Dummy data for default metrics.
   - **User Interaction Flow**: Users drag and drop components to rearrange their dashboard; changes are saved in local storage.
   - **Potential Challenges & Solutions**: Complexity in managing component states; utilize a state management library (e.g., Redux) for simplicity.

4. **Gamification Elements**
   - **Main Functionality**: Introduce gamification by awarding badges for achieving specific filtering milestones (e.g., filtering for a month straight).
   - **Key Components**: BadgeDisplayComponent, UserProgressTracker.
   - **Data Requirements**: Dummy data for milestone tracking.
   - **User Interaction Flow**: Users see progress bars and badges as they achieve milestones.
   - **Potential Challenges & Solutions**: Balancing gamification with usability; provide clear instructions and progress visibility.

5. **User Engagement Analytics**
   - **Main Functionality**: Track user interactions with the FilterPanel to understand usage patterns.
   - **Key Components**: AnalyticsComponent to visualize usage data.
   - **Data Requirements**: Dummy interaction logs.
   - **User Interaction Flow**: Admin can view analytics to see which filters are most used.
   - **Potential Challenges & Solutions**: Ensuring user privacy; anonymize data collection.

#### Step-by-Step Plan

1. **Clarification**
   - Ensure each functionality is thoroughly defined and aligns with existing FilterPanel functionality.
   - Confirm the integration of new features does not disrupt current functionalities.

2. **Enhanced Data Visualization Implementation**
   - **Create ChartComponent**: Utilize ECharts for rendering visualizations based on filtered data.
   - **Implementation Steps**:
     - Import ECharts library.
     - Define chart data structure based on filtered metrics.
     - Use effect hooks to update chart data when filters change.
     - Implement TooltipComponent to show detailed data on hover.
   - **Error Handling**: Ensure that if the data is empty or invalid, the chart displays a user-friendly message.

3. **Dynamic Notifications Implementation**
   - **Create NotificationComponent**: For displaying alerts based on user-defined thresholds.
   - **Implementation Steps**:
     - Design a SettingsDialog for users to input threshold values.
     - Use a state management solution to track current thresholds.
     - Trigger notifications based on metric evaluations.
   - **Error Handling**: Validate user input in the SettingsDialog to prevent erroneous threshold settings.

4. **Customizable Dashboard Implementation**
   - **Create DashboardSettingsComponent**: Allow users to rearrange metrics.
   - **Implementation Steps**:
     - Integrate DraggableComponent for drag-and-drop functionality.
     - Save user preferences in local storage or state management for persistence.
   - **Error Handling**: Ensure the layout persists correctly and handles edge cases like resizing or unexpected data loss.

5. **Gamification Elements Implementation**
   - **Create BadgeDisplayComponent**: Show progress and achievements.
   - **Implementation Steps**:
     - Track user engagement milestones.
     - Display badges based on completed milestones.
   - **Error Handling**: Implement checks to ensure badges are awarded appropriately.

6. **User Engagement Analytics Implementation**
   - **Create AnalyticsComponent**: For visualizing user interaction with the FilterPanel.
   - **Implementation Steps**:
     - Track interactions with filters (e.g., how often each filter is used).
     - Visualize data in a user-friendly format (e.g., bar charts, pie charts).
   - **Error Handling**: Ensure that user privacy is maintained in data logging.

#### Prioritization of Ideas
1. Enhanced Data Visualization (high impact, high feasibility)
2. Customizable Dashboard (high impact, medium feasibility)
3. Dynamic Notifications (medium impact, medium feasibility)
4. User Engagement Analytics (medium impact, medium feasibility)
5. Gamification Elements (low impact, medium feasibility)

These enhancements aim to improve user engagement, interactivity, and overall experience on the metrics page, making it an efficient and visually appealing tool for users.

#### Final Plan Summary
This comprehensive plan for the Enhanced Metrics Filtering Component incorporates the existing functionalities and new improvements, ensuring a cohesive, user-friendly interface. Each feature is designed to work seamlessly with the FilterPanel, allowing users to filter metrics effectively while enjoying enhanced visualizations, notifications, and customization options. The focus on user engagement and gamification elements adds a layer of interactivity, making the metrics page a dynamic tool for analysis and performance tracking.`

## **FileRequirements**
- Create **1 JS file** with **no styling**.
- Use only **dummy data**. **No backend** or API calls, only dummy data should be used.
- The entire file should be **self-contained**. **DO NOT** import any other JS files or components.

## **Rules**

### **General**
- **No errors or bugs** allowed. The code must work perfectly on the first try.
- Provide **complete, fully functional code** with no missing implementations or placeholder logic.
- **DO NOT** ask the user to implement anything. **DO NOT** leave out any code. Recreate everything within this file, and **DO NOT** import any external JS files or components.
- All necessary code must be included in this file, fully implemented, and functional with **no missing parts**.

### **ResponseFormat**
- Output **only** the requested code or response. **DO NOT** include explanations, comments, or additional information. Respond with the **complete code only**.

### **NoHeader**
- **DO NOT** include a header or any boilerplate explanations. Start **directly** with the code implementation.

## **ComponentRequirements**
- The component must be **fully implemented**, with **all functionality** integrated. **Nothing should be left out** or incomplete. Ensure all pieces work together seamlessly, and the code is ready to run without any issues.



# **Instructions**

## **ComponentRequirements**
- You will be given the requirements for a component. Create **complete React code** only for the component and nothing else.
- Ensure the React code works flawlessly using the **latest version of React**.
- **DO NOT** summarize or leave anything out. All functionality must be fully implemented and working together.
- `Component Name: InvestorPreferences, Component requirements: ### Final Plan for Investor Preferences Component

#### Component Description
- **Investor Preferences Component**
    - This component will enumerate the investment preferences of an investor, including sectors of interest, geographical locations, investment stages, and funding ranges. It is designed to facilitate better matches between investors and startups by providing a clear overview of investor interests.

#### Functionality
- The Investor Preferences component must allow users to view, edit, and update their investment preferences easily. The functionality will ensure that users can modify their preferences, which will be subsequently reflected on the Matchmaking Page for improved recommendations.

#### Detailed Functional Breakdown

1. **Sectors Selection**
    - **Implementation**: 
        - Utilize a multi-select checkbox component to allow users to select multiple sectors of interest.
        - **Data Binding**: Bind the selected sectors to the component’s state.
        - **Dummy Data**: `["Technology", "Healthcare", "Finance", "Education"]`
        - **Error Handling**: Ensure at least one sector is selected when saving preferences.
    - **Enhancement**: Provide a search functionality within the sector selection for easy navigation.

2. **Funding Range Slider**
    - **Implementation**:
        - Implement a slider component (using libraries like `React Slider`) to allow users to select their desired funding range.
        - **Data Binding**: Bind the slider values to the state.
        - **Dummy Data**: Min: `$10,000`, Max: `$5,000,000`
        - **Error Handling**: Validate that the minimum funding is less than the maximum before saving preferences.
    - **Enhancement**: Display the current selected range dynamically above the slider for user clarity.

3. **Geographical Location Selection**
    - **Implementation**:
        - Use a dropdown or tag input for selecting geographical locations.
        - **Data Binding**: Store selected locations in the component state.
        - **Dummy Data**: `["North America", "Europe", "Asia"]`
        - **Error Handling**: Ensure at least one location is selected.
    - **Enhancement**: Include a feature to recommend popular locations based on existing investments.

4. **Investment Stages Selection**
    - **Implementation**:
        - Similar to the sectors selection, use a dropdown or tag input for investment stages.
        - **Data Binding**: Bind state to selected stages.
        - **Dummy Data**: `["Seed", "Series A", "Series B", "IPO"]`
        - **Error Handling**: Verify that at least one stage is selected.
    - **Enhancement**: Provide additional context or descriptions for each stage via tooltips.

5. **Edit Preferences Button**
    - **Implementation**:
        - Create an 'Edit Preferences' button that toggles the state between view-only and editable modes.
        - **Functionality**: When clicked, it enables the inputs for sectors, funding range, locations, and stages.
        - **State Management**: Use local state to manage editable status.
    - **Enhancement**: Implement a confirmation dialog to confirm changes before saving.

### User Interaction
- **Interactivity**:
    - The 'Edit Preferences' button should activate input fields, allowing users to make changes. A "Save Changes" button will appear for users to save their updated preferences.
- **Result Functionality**:
    - Upon clicking "Save Changes", validate all inputs, update the state, and ensure changes are reflected in the Matchmaking Page.

### Interconnectivity
- **Matchmaking Page Integration**:
    - Ensure that the investor preferences are sent to the Matchmaking Page through a shared state management solution (like Context API or Redux) to enhance recommendations based on updated preferences.

### New Ideas for Enhancement

1. **User Engagement**
   - **Feature: Preference Sharing**
     - Implement a "Share Preferences" button that generates a shareable link.
     - **Challenge**: Maintain user data privacy with an opt-in policy.

2. **Data Visualization**
   - **Feature: Visual Representation of Preferences**
     - Use pie charts for sectors and bar graphs for funding ranges.
     - **Challenge**: Ensure visuals update immediately when preferences change.

3. **Interactivity**
   - **Feature: Real-Time Updates**
     - Use state management techniques (like hooks) to reflect changes instantly.
     - **Challenge**: Handle complex state transitions efficiently.

4. **Information Presentation**
   - **Feature: Tooltips and Help Sections**
     - Use tooltips for descriptions of each input field.
     - **Challenge**: Ensure tooltips do not create UI clutter.

5. **Productivity Tools**
   - **Feature: Save Favorite Preferences**
     - Allow users to save multiple configurations of preferences.
     - **Challenge**: Efficiently manage and retrieve these templates.

6. **Customization Options**
   - **Feature: Theme Customization**
     - Enable users to switch between light and dark modes.
     - **Challenge**: Adhere to accessibility standards in color choices.

### Prioritization
1. **Visual Representation of Preferences** – High impact, medium feasibility.
2. **Real-Time Updates** – High impact, medium feasibility.
3. **Preference Sharing** – Medium impact, high feasibility.
4. **Tooltips and Help Sections** – Medium impact, high feasibility.
5. **Save Favorite Preferences** – Medium impact, medium feasibility.
6. **Theme Customization** – Low impact, medium feasibility.

### Conclusion
This finalized plan for the Investor Preferences component encompasses all aspects of functionality, user interaction, and enhancements to ensure a comprehensive, user-friendly experience. The outlined strategies and features are actionable and designed to be implemented in a desktop application environment, providing an efficient way to manage investor preferences and improve startup matchmaking processes.`

## **FileRequirements**
- Create **1 JS file** with **no styling**.
- Use only **dummy data**. **No backend** or API calls, only dummy data should be used.
- The entire file should be **self-contained**. **DO NOT** import any other JS files or components.

## **Rules**

### **General**
- **No errors or bugs** allowed. The code must work perfectly on the first try.
- Provide **complete, fully functional code** with no missing implementations or placeholder logic.
- **DO NOT** ask the user to implement anything. **DO NOT** leave out any code. Recreate everything within this file, and **DO NOT** import any external JS files or components.
- All necessary code must be included in this file, fully implemented, and functional with **no missing parts**.

### **ResponseFormat**
- Output **only** the requested code or response. **DO NOT** include explanations, comments, or additional information. Respond with the **complete code only**.

### **NoHeader**
- **DO NOT** include a header or any boilerplate explanations. Start **directly** with the code implementation.

## **ComponentRequirements**
- The component must be **fully implemented**, with **all functionality** integrated. **Nothing should be left out** or incomplete. Ensure all pieces work together seamlessly, and the code is ready to run without any issues.



# **Instructions**

## **ComponentRequirements**
- You will be given the requirements for a component. Create **complete React code** only for the component and nothing else.
- Ensure the React code works flawlessly using the **latest version of React**.
- **DO NOT** summarize or leave anything out. All functionality must be fully implemented and working together.
- `Component Name: Description, Component requirements: ### Final Plan

#### **Description**
This plan outlines the enhancement of a startup overview page for a professional ERP desktop interface. The aim is to incorporate features and components that prioritize user engagement, data visualization, and interactivity while ensuring a cohesive and user-friendly experience. Each component is designed to work together seamlessly, providing a comprehensive and engaging user experience.

#### **Component Enhancement**

1. **Mission Statement Overview**
   - **Functionality**: 
     - Display the startup's mission statement prominently.
     - Provide an editable text area for real-time updates.
   - **Details**: 
     - Utilize a legible font with rich text formatting options (bold, italic, underline).
   - **User Interaction**: 
     - Implement a clickable area that opens an inline editor.
     - Changes should automatically save on blur or after a set timeout.
   - **Interconnectivity**: 
     - Include links to mentorship details or related documents, potentially as a sidebar or popover.

2. **User Engagement Features**
   - **Feedback Mechanism**:
     - **Implementation**: Add a feedback button next to the mission statement for user input.
     - **Interaction Flow**: Trigger a modal with a text area for feedback submission upon clicking the button.
     - **Data Requirements**: Use a mock dataset to simulate feedback storage (e.g., `[{ userId: '1', feedback: 'Clear mission!' }, ...]`).
     - **Challenges and Solutions**: Ensure the modal closes and provides a success message after submission to maintain user engagement.

3. **Data Visualization Panel**
   - **Functionality**: 
     - Visual representation of startup metrics (e.g., user growth, engagement statistics).
   - **Key Components**: 
     - Use ECharts or Chart.js for creating responsive graphs/charts.
   - **Data Requirements**: Prepare mock datasets to visualize metrics (e.g., `[{ month: 'Jan', users: 100 }, { month: 'Feb', users: 150 }, ...]`).
   - **User Interaction**: 
     - Implement tooltips on hover for data points to display additional details (e.g., exact numbers, percentage change).
   - **Potential Challenges**: 
     - Ensure charts adapt to screen size by using CSS flex properties to manage layout.

4. **Interactivity with Gamification Element**
   - **Functionality**: 
     - Introduce a progress tracker for startup milestones, visually engaging users with a gamified experience.
   - **Key Components**: 
     - Use progress bars that fill as milestones are achieved, with color coding for different statuses (completed, in-progress, pending).
   - **User Interaction Flow**: 
     - Allow users to click on progress bars to view detailed descriptions of each milestone.
   - **Data Requirements**: Mock data for milestones (e.g., `[{ milestone: 'Launch', status: 'Completed' }, { milestone: 'First 100 Users', status: 'In Progress' }]`).
   - **Challenges and Solutions**: 
     - Clear visual indicators (such as icons or color changes) to differentiate between completed and pending milestones.

5. **Customization Options**
   - **Functionality**: 
     - Enable users to customize the display of the mission statement (e.g., font size, color).
   - **Key Components**: 
     - Include a settings panel with sliders and color pickers for customization options.
   - **User Interaction Flow**: 
     - Use event listeners to instantly reflect changes on the page as users modify settings.
   - **Potential Challenges**: 
     - Validate that selected colors and sizes maintain readability and accessibility standards.

6. **Dynamic Content Updates**
   - **Functionality**: 
     - Automatically update sections based on user engagement metrics (e.g., most viewed or interacted metrics).
   - **Components**: 
     - Create a dynamic section that showcases popular metrics, using a grid layout to display various data points.
   - **User Interaction**: 
     - Allow users to filter content based on categories (e.g., growth, user feedback).
   - **Data Requirements**: Use mock data to simulate user interactions (e.g., `[{ metric: 'User Growth', views: 200 }, ...]`).
   - **Challenges and Solutions**: 
     - Employ a debouncing technique to manage updates efficiently without overwhelming the server or the UI.

7. **Notifications and Alerts**
   - **Functionality**: 
     - Introduce a notification system to inform users of important updates (e.g., mission statement changes, milestone achievements).
   - **Key Components**: 
     - A notification bell icon that displays a dropdown list of recent alerts when clicked.
   - **User Interaction Flow**: 
     - Include options to mark notifications as read or dismiss them individually or collectively.
   - **Data Requirements**: Utilize mock notifications data (e.g., `[{ type: 'update', message: 'Mission statement updated!', timestamp: '2023-10-01' }, ...]`).
   - **Challenges and Solutions**: 
     - Provide a mechanism to ensure notifications are timely and relevant to avoid overwhelming users.

#### **Prioritization**
1. User Engagement Features
2. Data Visualization Panel
3. Interactivity with Gamification Element
4. Dynamic Content Updates
5. Notifications and Alerts
6. Customization Options
7. Mission Statement Overview (core functionality)

---

This final plan meticulously details the implementation of new features and enhancements for a professional ERP desktop interface, ensuring a comprehensive and engaging user experience. Each component is designed with user interaction, data visualization, and customization in mind, promoting a seamless integration of functionality and aesthetics. All features are interlinked, ensuring a holistic user experience within the ERP environment.`

## **FileRequirements**
- Create **1 JS file** with **no styling**.
- Use only **dummy data**. **No backend** or API calls, only dummy data should be used.
- The entire file should be **self-contained**. **DO NOT** import any other JS files or components.

## **Rules**

### **General**
- **No errors or bugs** allowed. The code must work perfectly on the first try.
- Provide **complete, fully functional code** with no missing implementations or placeholder logic.
- **DO NOT** ask the user to implement anything. **DO NOT** leave out any code. Recreate everything within this file, and **DO NOT** import any external JS files or components.
- All necessary code must be included in this file, fully implemented, and functional with **no missing parts**.

### **ResponseFormat**
- Output **only** the requested code or response. **DO NOT** include explanations, comments, or additional information. Respond with the **complete code only**.

### **NoHeader**
- **DO NOT** include a header or any boilerplate explanations. Start **directly** with the code implementation.

## **ComponentRequirements**
- The component must be **fully implemented**, with **all functionality** integrated. **Nothing should be left out** or incomplete. Ensure all pieces work together seamlessly, and the code is ready to run without any issues.



# **Instructions**

## **ComponentRequirements**
- You will be given the requirements for a component. Create **complete React code** only for the component and nothing else.
- Ensure the React code works flawlessly using the **latest version of React**.
- **DO NOT** summarize or leave anything out. All functionality must be fully implemented and working together.
- `Component Name: Heatmap, Component requirements: ### Final Plan

#### Component Description
- **Heatmap Component**
    - Visualizes metrics in a heatmap format for quick insights, allowing users to identify performance trends across different startups and time periods.

#### Functionality
- The Heatmap component provides an interactive visual representation of performance metrics using color gradients to indicate various levels of metric values. Users can hover over cells for detailed information and click to delve into specific data points.

#### Details
- **Dynamic Visualization**: Utilizes ECharts for creating a dynamic and interactive heatmap.
- **Color Gradients**: Different levels of metric performance are represented with various color gradients.
- **Interactivity**: The heatmap is interactive, displaying tooltips with detailed data and trends when hovered over.

#### Interconnectivity
- **Health Dashboard Integration**: Heatmap data can be exported or shared with the Health Dashboard for deeper analysis.

#### User Interaction
- **Interactions**:
    - **Hover**: Users can hover over heatmap cells to view detailed tooltips displaying the exact metric value and timestamp.
    - **Click**: Clicking on a heatmap cell will drill down into specific metrics, opening a detailed analysis chart or graph related to the selected cell.
- **Result Functionality**:
    - The detailed analysis includes breakdowns of metric trends over time, with options to export data or view related metrics.

### New Features and Enhancements

#### 1. User Engagement Tools
- **Feature**: Implement a user feedback mechanism.
    - **Main Functionality**: Allow users to rate the usefulness of the heatmap insights.
    - **Key Components**: Thumbs up/down buttons beside the heatmap.
    - **Data Requirements**: Track feedback counts using local state management.
    - **User Interaction Flow**: Users click the feedback buttons, updating the count visually.
    - **Challenges & Solutions**: Use local state management to store counts temporarily to manage feedback data effectively.

#### 2. Advanced Data Visualization
- **Feature**: Multiple metric overlays.
    - **Main Functionality**: Enable users to select multiple metrics to visualize on the same heatmap.
    - **Key Components**: Checkbox filters for different metrics.
    - **Data Requirements**: Array of dummy metric data for various KPIs.
    - **User Interaction Flow**: Users select checkboxes, and the heatmap updates in real-time.
    - **Challenges & Solutions**: Manage visual clutter by using a clear legend and tooltips to explain overlays.

#### 3. Customization Options
- **Feature**: Theme customization.
    - **Main Functionality**: Allow users to customize color gradients and themes for the heatmap.
    - **Key Components**: A settings panel with color pickers.
    - **Data Requirements**: Store user preferences in local state.
    - **User Interaction Flow**: Users select colors, and the heatmap updates accordingly.
    - **Challenges & Solutions**: Ensure colorblind-friendly options; provide predefined themes to enhance usability.

#### 4. Gamification
- **Feature**: Achievement badges.
    - **Main Functionality**: Reward users for exploring different metrics or exceeding performance thresholds.
    - **Key Components**: Badge notifications displayed upon achieving a milestone.
    - **Data Requirements**: Dummy data for milestone criteria.
    - **User Interaction Flow**: Users receive badges, viewable in a dedicated achievements section.
    - **Challenges & Solutions**: Balance challenge and accessibility; provide clear criteria for achievements to ensure user engagement.

#### 5. Dynamic Content Notifications
- **Feature**: Real-time notifications for performance changes.
    - **Main Functionality**: Alert users of significant shifts in metrics.
    - **Key Components**: Notification pop-ups or banners.
    - **Data Requirements**: Dummy thresholds for notification triggers.
    - **User Interaction Flow**: Users see a notification when metrics exceed or fall below predefined thresholds.
    - **Challenges & Solutions**: Avoid overwhelming users by implementing a digest view for notifications, ensuring clarity and relevance.

### Prioritization of Ideas
1. **Advanced Data Visualization** - High impact and enhances user experience significantly.
2. **User Engagement Tools** - Boosts user interaction and feedback collection.
3. **Dynamic Content Notifications** - Keeps users informed and engaged with real-time data.
4. **Customization Options** - Adds a personal touch and improves user satisfaction.
5. **Gamification** - Encourages exploration and interaction but may be less critical to core functionality.

### Tech Stack Considerations
- **React**: For building interactive components.
- **Ant Design**: For UI elements to maintain a professional look and feel.
- **ECharts**: For sophisticated data visualizations that enhance user understanding.

### Step-by-Step Plan

#### Step 1: Setup Environment
- **Install Dependencies**: Set up a React project with Ant Design and ECharts.
- **Structure Project**: Create a dedicated `Heatmap` component folder with subcomponents for tooltips, feedback, and overlays.

#### Step 2: Implement Heatmap Core
- **Dynamic Visualization**:
    - Utilize ECharts to create the heatmap component.
    - Define data structure for metrics and implement rendering logic.
- **Color Gradients**: Use a color mapping function to assign colors based on metric values.

#### Step 3: Add Interactivity
- **Hover Functionality**:
    - Implement `onMouseOver` event for ECharts to show tooltips with metric values and timestamps.
- **Click Functionality**:
    - Implement `onClick` event to navigate to detailed analysis based on the selected cell.

#### Step 4: Integrate User Engagement Tools
- **Feedback Mechanism**:
    - Add thumbs up/down buttons next to the heatmap.
    - Implement local state management to track feedback counts.
- **Update Display**: Ensure visual updates occur immediately upon user interaction.

#### Step 5: Advanced Data Visualization
- **Multiple Metric Overlays**:
    - Create checkbox filters to toggle different metrics.
    - Implement logic to update the heatmap dynamically based on selected metrics.

#### Step 6: Add Customization Options
- **Theme Customization**:
    - Create a settings panel with color pickers.
    - Implement user preference storage in local state for theme settings.

#### Step 7: Implement Gamification
- **Achievement Badges**:
    - Define milestones for user achievements.
    - Create a notification system to inform users when they earn badges.

#### Step 8: Add Dynamic Content Notifications
- **Real-time Notifications**:
    - Implement a mechanism to check for performance changes and trigger notifications.
    - Use a digest view to prevent overwhelming the user with alerts.

#### Step 9: Final Testing and Optimization
- **Testing**:
    - Identify edge cases (e.g., no data scenarios, rapid metric changes) and create tests to ensure reliability.
    - Conduct user testing sessions to gather feedback on usability and interactivity.
- **Optimization**: Review component performance and optimize rendering logic for better efficiency.

### Enhancements
- **Performance Monitoring**: Implement logging for performance metrics within the heatmap component to analyze user engagement and interaction patterns.
- **Accessibility Features**: Ensure keyboard navigation and screen reader compatibility for all interactive elements.
- **Documentation**: Create comprehensive documentation for the component, including setup instructions, usage examples, and customization options.

This plan outlines a comprehensive approach to enhancing the heatmap component, focusing on user experience, interaction, and functionality, ensuring it meets the needs of a professional ERP system.`

## **FileRequirements**
- Create **1 JS file** with **no styling**.
- Use only **dummy data**. **No backend** or API calls, only dummy data should be used.
- The entire file should be **self-contained**. **DO NOT** import any other JS files or components.

## **Rules**

### **General**
- **No errors or bugs** allowed. The code must work perfectly on the first try.
- Provide **complete, fully functional code** with no missing implementations or placeholder logic.
- **DO NOT** ask the user to implement anything. **DO NOT** leave out any code. Recreate everything within this file, and **DO NOT** import any external JS files or components.
- All necessary code must be included in this file, fully implemented, and functional with **no missing parts**.

### **ResponseFormat**
- Output **only** the requested code or response. **DO NOT** include explanations, comments, or additional information. Respond with the **complete code only**.

### **NoHeader**
- **DO NOT** include a header or any boilerplate explanations. Start **directly** with the code implementation.

## **ComponentRequirements**
- The component must be **fully implemented**, with **all functionality** integrated. **Nothing should be left out** or incomplete. Ensure all pieces work together seamlessly, and the code is ready to run without any issues.



# **Instructions**

## **ComponentRequirements**
- You will be given the requirements for a component. Create **complete React code** only for the component and nothing else.
- Ensure the React code works flawlessly using the **latest version of React**.
- **DO NOT** summarize or leave anything out. All functionality must be fully implemented and working together.
- `Component Name: EngagementHistory, Component requirements: ### **Final Plan for EngagementHistory Component**

#### **Description**
The EngagementHistory component will serve as a comprehensive timeline reflecting all interactions between the user and their investors. This component not only facilitates tracking but also enhances user engagement through interactive features and data visualization.

#### **Content**
```json
{
    "componentDescription": "Shows a timeline of interactions and communications with the investor.",
    "functionality": "The EngagementHistory component provides a chronological timeline of all interactions between the user and the investor. This includes meetings, calls, emails, and any notes taken during these engagements. By visualizing this data, users gain insights into the relationship's progression and can identify patterns or opportunities for further engagement. It supports adding new entries, which updates both the timeline and the records, ensuring a comprehensive and up-to-date engagement history.",
    "details": [
        "The timeline should include dates, types of engagement (e.g., meeting, call), and a brief summary of the interaction.",
        "Users can click on an entry to view more details or edit the engagement information.",
        "A 'New Entry' button allows adding new engagements, which opens a form for data input.",
        "The timeline should support filtering by date range or type of engagement.",
        "Integration with notifications for upcoming engagements due or reminders for follow-ups.",
        "Option for users to categorize engagements (e.g., high priority, follow-up) to customize their view."
    ],
    "isVisible": true,
    "interconnectivity": [
        {
            "pageUrl": "/engagement-dashboard",
            "description": "Can be integrated with an Engagement Dashboard for a broader view of all investor interactions."
        }
    ],
    "userInteraction": {
        "interact": "New Entry button in the EngagementHistory component",
        "possibleInteractions": "Clicking 'New Entry' opens a form for adding a new engagement.",
        "result": "A form appears for users to input details about a new engagement.",
        "resultFunctionality": "The form includes fields for the date, type of interaction, and notes. Upon submission, the data is appended to the current timeline, updating the state and sending the new entry for persistent storage."
    }
}
```

### **New Features and Enhancements**

1. **Enhanced Data Visualization**
   - **Main Functionality**: Utilize ECharts to represent engagement frequency over time, with distinct colors for various types of interactions.
   - **Key Components**: A line chart for trends and a pie chart for interaction types.
   - **Data Requirements**: Simulated data representing monthly engagement counts.
   - **User Interaction Flow**: Users can hover over the charts for tooltips displaying specific interaction details.
   - **Potential Challenges**: Ensuring charts are responsive. Solution: Use flexible dimensions for the charts.

2. **Advanced Filtering Options**
   - **Main Functionality**: Enable users to filter engagements by multiple criteria (date, type, priority).
   - **Key Components**: Dropdown menus and sliders for inputs.
   - **Data Requirements**: Simulated data for various engagement types and dates.
   - **User Interaction Flow**: Users select filtering options, and the timeline updates in real-time.
   - **Potential Challenges**: Performance with large datasets. Solution: Implement pagination or lazy loading.

3. **Notifications and Reminders**
   - **Main Functionality**: Alert users for upcoming meetings or follow-ups based on the timeline entries.
   - **Key Components**: A notification bell icon with dropdown notifications.
   - **Data Requirements**: Simulated data for upcoming engagements.
   - **User Interaction Flow**: Clicking the bell reveals a list of notifications; users can mark them as read.
   - **Potential Challenges**: Ensuring notifications remain relevant. Solution: Allow users to customize notification settings.

4. **Customizable Engagement Categories**
   - **Main Functionality**: Users can tag engagements with categories (e.g., high priority, follow-up) for better organization.
   - **Key Components**: Tag input field in the 'New Entry' form.
   - **Data Requirements**: Simulated data representing various engagement categories.
   - **User Interaction Flow**: Users can select or create tags while adding new engagements.
   - **Potential Challenges**: Preventing excessive similar tags. Solution: Implement tag suggestions based on existing tags.

5. **Gamification Elements**
   - **Main Functionality**: Introduce badges or rewards for reaching engagement milestones (e.g., 10 meetings).
   - **Key Components**: Badge display area on the component.
   - **Data Requirements**: Simulated data for user engagement history.
   - **User Interaction Flow**: Users can click on badges to see what they need for the next achievement.
   - **Potential Challenges**: Keeping gamification meaningful. Solution: Limit badges to significant achievements.

### **Prioritization**
1. Enhanced Data Visualization
2. Advanced Filtering Options
3. Notifications and Reminders
4. Customizable Engagement Categories
5. Gamification Elements

### **Step by Step Plan**

#### **1. Clarification**
   - Ensure the component displays a responsive timeline of interactions, with interactive charts and filters.
   - Clearly define the engagement types and their categorizations.

#### **2. Implementation Guidance**
   - **Engagement Timeline**: 
     - Use a `Timeline` component from a UI library (e.g., Ant Design).
     - Each entry should display date, type, and summary. 
     - Implement click handlers for viewing/editing details.
   - **New Entry Form**: 
     - Create a modal form with fields for date, type, notes, and categories.
     - Implement form validation for required fields and correct data formats.
   - **Data Visualization**: 
     - Integrate ECharts to create dynamic charts.
     - Fetch and render engagement data through props or a state management solution.
   - **Filtering**: 
     - Design dropdowns and sliders for user inputs.
     - Implement state management to filter timeline entries based on user selections.
   - **Notifications**: 
     - Implement a notification system with a dropdown for upcoming engagements.
   - **Categories**: 
     - Use a tagging library (e.g., React-Select) for user-defined categories.
   - **Gamification**: 
     - Create a badge system that tracks user engagement milestones.

#### **3. Efficiency**
   - Structure code using functional components for clarity and maintainability.
   - Optimize data fetching and rendering to reduce component re-renders.

#### **4. Technical Specifications**
   - **Frameworks**: React, Ant Design, ECharts.
   - **State Management**: Use React's context API or a state management library like Redux.
   - **Form Handling**: Use Formik or React Hook Form for managing forms.

#### **5. Examples**
   - **Example Interaction**: User clicks on a timeline entry to expand details.
   - **Example New Entry Submission**: User fills in the form and submits, which immediately updates the timeline.

#### **6. Edge Cases**
   - Handle cases where no engagements exist by displaying a friendly message.
   - Validate input for the new entry form and show error messages for user corrections.

#### **7. Enhancements**
   - Consider adding a search bar for quick access to specific engagements.
   - Implement tooltips on engagement types for user education.
   - Explore incorporating user feedback mechanisms for continuous improvement.

This comprehensive plan ensures that the EngagementHistory component is functional, user-friendly, and equipped with enhanced features that drive user engagement and interaction.`

## **FileRequirements**
- Create **1 JS file** with **no styling**.
- Use only **dummy data**. **No backend** or API calls, only dummy data should be used.
- The entire file should be **self-contained**. **DO NOT** import any other JS files or components.

## **Rules**

### **General**
- **No errors or bugs** allowed. The code must work perfectly on the first try.
- Provide **complete, fully functional code** with no missing implementations or placeholder logic.
- **DO NOT** ask the user to implement anything. **DO NOT** leave out any code. Recreate everything within this file, and **DO NOT** import any external JS files or components.
- All necessary code must be included in this file, fully implemented, and functional with **no missing parts**.

### **ResponseFormat**
- Output **only** the requested code or response. **DO NOT** include explanations, comments, or additional information. Respond with the **complete code only**.

### **NoHeader**
- **DO NOT** include a header or any boilerplate explanations. Start **directly** with the code implementation.

## **ComponentRequirements**
- The component must be **fully implemented**, with **all functionality** integrated. **Nothing should be left out** or incomplete. Ensure all pieces work together seamlessly, and the code is ready to run without any issues.



# **Instructions**

## **ComponentRequirements**
- You will be given the requirements for a component. Create **complete React code** only for the component and nothing else.
- Ensure the React code works flawlessly using the **latest version of React**.
- **DO NOT** summarize or leave anything out. All functionality must be fully implemented and working together.
- `Component Name: TeamList, Component requirements: ### Final Plan

#### **Component Description**
- **TeamList Component**: Renders a comprehensive list of team members, showcasing their roles, contact details, and additional interactive features for efficient team management.

#### **Functionality**
- The TeamList component will display the startup's team members, including their names, roles, contact information, and interactive elements to enhance user engagement and productivity. It allows users to view detailed information, add new members, edit existing members, and reorder them through drag-and-drop functionality, ensuring that the team structure remains clear and current.

#### **Details**
- Each entry will include:
  - Name
  - Role
  - Email
  - Brief bio
  - Status indicator (e.g., 'Available', 'In a Meeting')
  - Star rating component for feedback
- Supports:
  - Drag-and-drop for reordering members
  - Inline editing for quick updates
  - Task assignment capability

#### **User Interaction**
- **Interactivity**:
  - Users click on a team member’s name to view or edit their details.
  - Clicking 'Add Member' opens a modal form for adding new members.
  - Users can submit ratings, assign tasks, and filter members by role or department.
- **Result**:
  - Displays modals for detailed information, edit forms, and feedback submissions.
- **Result Functionality**:
  - Modals provide a streamlined way to manage member data, ensuring all changes are captured and updated in real-time.

#### **Interconnectivity**
- **Links**:
  - `/team-management`: Links to a detailed management page for deeper insights and role assignments.

---

### **New Features and Enhancements**

#### **1. User Engagement Features**
- **Feedback Mechanism**:
  - Incorporate a star rating system next to each team member’s entry for collaborative feedback.
  - **Implementation**:
    - Add a star rating component using a library like React Stars or similar.
    - Use mock data to simulate user ratings and display average ratings.
- **User Interaction Flow**:
  - Users click on a star rating to submit feedback, which updates displayed ratings in real-time.

#### **2. Data Visualization**
- **Team Composition Chart**:
  - Visual representation of team structure using a pie chart to show role distribution.
  - **Implementation**:
    - Utilize ECharts or Chart.js to create a pie chart showing roles (e.g., Developers, Designers).
    - Populate the chart with mock data for role distribution.
- **User Interaction Flow**:
  - Users hover over chart segments to view precise role counts and percentages.

#### **3. Productivity Tools**
- **Task Assignment Feature**:
  - Enable task assignments directly from the TeamList.
  - **Implementation**:
    - Add an 'Assign Task' button next to each member that opens a modal form for task details.
- **User Interaction Flow**:
  - Upon form submission, the assigned task appears in a task list associated with the member.

#### **4. Customization Options**
- **Personalized Views**:
  - Allow users to filter team members by role or department.
  - **Implementation**:
    - Include dropdown filters at the top of the TeamList component.
- **User Interaction Flow**:
  - Users select roles from the dropdown, dynamically updating the displayed members.

#### **5. Dynamic Content**
- **Real-time Status Updates**:
  - Show current project status or availability of team members.
  - **Implementation**:
    - Use color-coded indicators (green, yellow, red) next to each member's name to represent status.
- **User Interaction Flow**:
  - Users can click on the status to view detailed availability information.

#### **6. Notifications**
- **Team Updates Notification**:
  - Notify users of changes made to the team list (e.g., new member added).
  - **Implementation**:
    - Implement a notification component that displays messages when changes occur and disappears after a few seconds.
- **User Interaction Flow**:
  - Notifications appear at the top of the component for immediate visibility.

---

### **Prioritization of Ideas**
1. **User Engagement Features** (High Impact, High Feasibility)
2. **Productivity Tools** (High Impact, Medium Feasibility)
3. **Data Visualization** (Medium Impact, Medium Feasibility)
4. **Customization Options** (Medium Impact, High Feasibility)
5. **Dynamic Content** (Medium Impact, Medium Feasibility)
6. **Notifications** (Low Impact, High Feasibility)

---

### **Implementation Considerations**
- **Main Functionality**: Ensure all proposed features integrate cohesively within the existing TeamList structure.
- **Key Components/Modules**: 
  - Rating Component
  - Task Assignment Modal
  - Filter Dropdowns
  - Notification System
- **Data Requirements**: Use mock data for team members, task assignments, and ratings to simulate functionality.
- **User Interaction Flow**: Prioritize an intuitive experience with seamless navigation and clear feedback mechanisms.
- **Potential Challenges and Solutions**: Manage potential UI clutter by logically grouping features, ensuring clarity in modals and notifications.

### **Step-by-Step Plan**

#### **1. Clarification**
- Ensure the TeamList component clearly displays all necessary information about team members, their roles, and interactive features. 

#### **2. Implementation Guidance**
- Create a responsive layout for the TeamList using CSS Flexbox or Grid to allow for dynamic content arrangement.
- Implement drag-and-drop functionality with libraries like React DnD for reordering team members.
- Use state management (e.g., React Context or Redux) to manage team member data, ratings, and tasks seamlessly.

#### **3. Efficiency**
- Organize the component structure logically (e.g., separate components for TeamMember, TaskAssignment, Rating, etc.) to enhance maintainability and readability.

#### **4. Technical Specifications**
- Framework: React.js
- Libraries: ECharts or Chart.js for data visualization; React DnD for drag-and-drop; React Stars for rating functionality.
  
#### **5. Examples**
- Example of a member entry:
  ```jsx
  <TeamMember 
    name="John Doe" 
    role="Developer" 
    email="john.doe@example.com" 
    bio="Full stack developer with a passion for coding." 
    status="Available"
    rating={4.5}
  />
  ```

#### **6. Edge Cases**
- Handle edge cases such as attempting to assign a task to a member who is currently unavailable by providing appropriate error messages or disabling the assignment button.

#### **7. Enhancements**
- Consider implementing a search bar for quick member lookup.
- Introduce an audit log feature to track changes made to team member data for accountability.

---

This final plan provides a comprehensive overview of the TeamList component, detailing its functionality, user interaction, and necessary implementation steps to create a professional ERP tool, ensuring all aspects work together seamlessly.`

## **FileRequirements**
- Create **1 JS file** with **no styling**.
- Use only **dummy data**. **No backend** or API calls, only dummy data should be used.
- The entire file should be **self-contained**. **DO NOT** import any other JS files or components.

## **Rules**

### **General**
- **No errors or bugs** allowed. The code must work perfectly on the first try.
- Provide **complete, fully functional code** with no missing implementations or placeholder logic.
- **DO NOT** ask the user to implement anything. **DO NOT** leave out any code. Recreate everything within this file, and **DO NOT** import any external JS files or components.
- All necessary code must be included in this file, fully implemented, and functional with **no missing parts**.

### **ResponseFormat**
- Output **only** the requested code or response. **DO NOT** include explanations, comments, or additional information. Respond with the **complete code only**.

### **NoHeader**
- **DO NOT** include a header or any boilerplate explanations. Start **directly** with the code implementation.

## **ComponentRequirements**
- The component must be **fully implemented**, with **all functionality** integrated. **Nothing should be left out** or incomplete. Ensure all pieces work together seamlessly, and the code is ready to run without any issues.



# **Instructions**

## **ComponentRequirements**
- You will be given the requirements for a component. Create **complete React code** only for the component and nothing else.
- Ensure the React code works flawlessly using the **latest version of React**.
- **DO NOT** summarize or leave anything out. All functionality must be fully implemented and working together.
- `Component Name: MatchSuggestions, Component requirements: ### Comprehensive Plan for the MatchSuggestions Component

#### **Description**
The MatchSuggestions component provides a curated list of startups that align with the investor's preferences, facilitating effective introductions and potential investment opportunities. By leveraging real-time data and advanced filtering capabilities, it ensures that suggestions are relevant and valuable to the investor's interests.

---

#### **Content Enhancements**

1. **Main Functionality**
    - Curated list of startups based on user-defined criteria (sector, funding stage, geographical focus).
    - Real-time data integration for dynamic updates.
    - User-friendly interface for easy navigation and exploration of matches.

2. **Key Components or Modules**
    - **Startup List View**: 
        - **Layout**: Implement a card-style layout for better visual appeal, displaying critical information (name, description, relevance score) prominently.
        - **Action**: Each card should have a hover effect to indicate interactivity.
    
    - **Detailed Startup Profile Modal**: 
        - **Trigger**: On clicking a startup card, a modal opens with detailed information.
        - **Content**: Include metrics such as market size, financials, team information, and pitch decks.
        - **User Interaction**: Include a close button and a 'Book a Meeting' option.

    - **Dynamic Filtering Options**: 
        - **Filters**: Implement multi-select dropdowns for filtering by sector, funding stage, and geographic location.
        - **Implementation**: Use checkboxes within dropdowns for a better UX.
        - **Real-Time Update**: As filters are applied, dynamically update the startup list.

    - **Refresh Button**: 
        - **Functionality**: Allows users to refresh the list based on current preferences.
        - **UI Element**: Place this button prominently, but not obtrusively, on the UI.

    - **Notifications/Alerts**: 
        - **Functionality**: Inform users of new matches or updates via a notification system.
        - **Design**: Use a non-intrusive pop-up or toast notification.
        - **Trigger**: Notifications should appear based on user-defined thresholds (e.g., new startups within a saved filter).

    - **Engagement Analytics**: 
        - **Tracking**: Track user interactions with startups (e.g., clicks, views).
        - **Data Collection**: Capture data points to analyze user behavior and enhance suggestions.

3. **Data Requirements**
    - **Dummy Data Structure**: 
        ```json
        [
          {
            "name": "Tech Innovators",
            "description": "A startup focusing on AI solutions.",
            "sector": "Technology",
            "fundingStage": "Seed",
            "geographicFocus": "North America",
            "relevanceScore": 85
          },
          {
            "name": "Eco Green",
            "description": "Sustainable energy solutions.",
            "sector": "Environment",
            "fundingStage": "Series A",
            "geographicFocus": "Europe",
            "relevanceScore": 78
          }
        ]
        ```

4. **User Interaction Flow**
    - **Loading**: On loading the component, users see the list of startups.
    - **Filtering**: Users can select desired filters, which will dynamically update the list.
    - **Details**: Clicking on a startup card opens a detailed profile modal.
    - **Refreshing**: Users can refresh the list for updated matches.

5. **Potential Challenges and Solutions**
    - **Dynamic Filtering Complexity**: 
      - **Solution**: Utilize efficient state management techniques (like React's useState and useEffect hooks) to handle filter states and update the startup list dynamically.
    
    - **UI Responsiveness**: 
      - **Solution**: Use responsive design principles, possibly utilizing a UI library like Ant Design or Material-UI for consistent styling.

---

#### **New Feature Ideas for Enhanced User Experience**

1. **Data Visualization Dashboard**
    - **Functionality**: Visual representation of startup performance metrics (e.g., funding trends, sector growth).
    - **Components**: Consider integrating ECharts or Chart.js for graphs and charts.
    - **User Interaction**: Users can hover over graphs for detailed data points.

2. **Gamification Elements**
    - **Functionality**: Implement badges or rewards for users based on engagement (e.g., number of startups viewed).
    - **Components**: Add a side panel displaying user achievements and progress.
    - **User Interaction**: Users can see their progress and compete with peers.

3. **Customization Options**
    - **Functionality**: Allow users to save their preferred filter settings for quick access.
    - **Components**: A settings panel for saving and loading filter presets.
    - **User Interaction**: Users can name, manage their presets, and swiftly apply them when needed.

4. **Interactive FAQs Section**
    - **Functionality**: A collapsible FAQ section addressing common user questions about startup investing.
    - **Components**: Accordion-style component for clean presentation.
    - **User Interaction**: Users can click to expand questions for answers.

---

#### **Prioritization of Ideas**
1. **Dynamic Filtering Options**: High impact, essential for user experience.
2. **Detailed Startup Profile Modal**: High impact, enhances information accessibility.
3. **Data Visualization Dashboard**: Medium impact, adds depth to the user experience.
4. **Customization Options**: Medium impact, increases productivity.
5. **Gamification Elements**: Low impact, fun addition but not essential.
6. **Interactive FAQs Section**: Low impact, improves user support but can be added later.

---

### Final Plan

This comprehensive plan focuses on enhancing the MatchSuggestions component's functionality while considering user engagement, interactivity, and productivity. 

1. **Startup List View**: Implement a card-style layout that is visually appealing and provides easy access to essential information.

2. **Detailed Startup Profile Modal**: Design a modal that opens with comprehensive details about each startup, including metrics and the option to book meetings.

3. **Dynamic Filtering Options**: Build multi-select dropdowns for a refined filtering experience that updates the displayed startups in real-time.

4. **Refresh Button**: Add an intuitive refresh button to allow users to see the most current suggestions based on their preferences.

5. **Notifications/Alerts**: Integrate a notification system that updates users on new matches and relevant changes.

6. **Engagement Analytics**: Track user interactions within the application to continually improve user experience and suggestions.

7. **Data Visualization Dashboard**: Create a separate dashboard or integrate within the component to visualize key startup metrics for better insight.

8. **Gamification Elements**: Introduce a side panel that showcases badges and achievements based on user interactions, enhancing engagement.

9. **Customization Options**: Implement a feature that allows users to save their filter settings, making it easier for them to return to preferred views.

10. **Interactive FAQs Section**: Include an accordion-style FAQ section for easy access to common questions related to investing in startups.

By implementing these features, the user experience will be significantly improved, making it easier for investors to connect with promising startups. Each component will work together seamlessly, providing a cohesive and engaging platform for users.`

## **FileRequirements**
- Create **1 JS file** with **no styling**.
- Use only **dummy data**. **No backend** or API calls, only dummy data should be used.
- The entire file should be **self-contained**. **DO NOT** import any other JS files or components.

## **Rules**

### **General**
- **No errors or bugs** allowed. The code must work perfectly on the first try.
- Provide **complete, fully functional code** with no missing implementations or placeholder logic.
- **DO NOT** ask the user to implement anything. **DO NOT** leave out any code. Recreate everything within this file, and **DO NOT** import any external JS files or components.
- All necessary code must be included in this file, fully implemented, and functional with **no missing parts**.

### **ResponseFormat**
- Output **only** the requested code or response. **DO NOT** include explanations, comments, or additional information. Respond with the **complete code only**.

### **NoHeader**
- **DO NOT** include a header or any boilerplate explanations. Start **directly** with the code implementation.

## **ComponentRequirements**
- The component must be **fully implemented**, with **all functionality** integrated. **Nothing should be left out** or incomplete. Ensure all pieces work together seamlessly, and the code is ready to run without any issues.



# **Instructions**

## **ComponentRequirements**
- You will be given the requirements for a component. Create **complete React code** only for the component and nothing else.
- Ensure the React code works flawlessly using the **latest version of React**.
- **DO NOT** summarize or leave anything out. All functionality must be fully implemented and working together.
- `Component Name: TableRow, Component requirements: # Final Plan

## Component Description
- The component is designed to display individual rows of data for each startup and its related metrics, enhancing user experience through organized data presentation and interactivity. It enables efficient tracking and analysis of multiple metrics, ensuring high readability.

## Functionality
- **TableRow**: Each entry represents a startup and contains multiple **TableCells** for different metrics (e.g., Monthly Active Users (MAU), Revenue).
- **Row Hover Effects**: Rows are highlighted on hover to improve visibility and ease of tracking across the table.
- **Expandable Rows**: Users can expand rows to reveal detailed metrics and insights about each startup, facilitating deeper analysis.

## Details
- **Row Hover Highlights**: Implement CSS transitions for smooth hover effects.
- **TableCells**: Each cell contains specific metrics related to the startup, formatted for clarity.
- **Expandable Rows**: Utilize state management to control the visibility of detailed information.

## Improvements and New Features
### 1. Dynamic Data Filtering
- **Functionality**: Users can filter data based on criteria (e.g., revenue range, user growth percentage).
- **Key Components**: 
  - Dropdown filters for specific metrics (e.g., MAU).
  - Range sliders for numerical values (e.g., revenue).
- **Data Requirements**: Utilize dummy data sets with varied metrics for testing.
- **User Interaction Flow**: Users select filters; the table updates to reflect these selections dynamically.
- **Challenges/Solutions**: Optimize state management to handle filtering efficiently. Consider using libraries like React Query for data fetching and caching.
- **Implementation Steps**:
  1. Create filter components (dropdowns/sliders).
  2. Implement event listeners to handle filter changes.
  3. Update the displayed data set based on selected filters.

### 2. Data Visualization Integration
- **Functionality**: Integrate ECharts for visualizing metrics.
- **Key Components**: 
  - Add chart components adjacent to the table.
  - Implement click events on metrics to trigger visualizations.
- **Data Requirements**: Format dummy data for visual representation.
- **User Interaction Flow**: Users click on metrics to view corresponding charts.
- **Challenges/Solutions**: Use a centralized state management system to synchronize table data and charts.
- **Implementation Steps**:
  1. Install ECharts and create chart components.
  2. Define data binding between metrics and charts.
  3. Ensure charts update based on filtered data.

### 3. User Engagement Features
- **Functionality**: Introduce gamification with badges for user engagement.
- **Key Components**: 
  - Badge display area.
  - User profile section to show achievement status.
- **Data Requirements**: Create dummy user engagement metrics.
- **User Interaction Flow**: Users earn points/badges by interacting with the table.
- **Challenges/Solutions**: Simplify gamification to avoid overwhelming users.
- **Implementation Steps**:
  1. Define user engagement metrics.
  2. Create a system for tracking points and awarding badges.
  3. Display badges in the user profile.

### 4. Customizable Dashboard Layout
- **Functionality**: Allow users to customize their dashboard by dragging and dropping table columns/charts.
- **Key Components**: 
  - Implement drag-and-drop functionality for table headers and charts.
  - Save user preferences for layout configuration.
- **Data Requirements**: Use dummy configurations to simulate user settings.
- **User Interaction Flow**: Users rearrange the layout as desired.
- **Challenges/Solutions**: Utilize local storage to save user configurations across sessions.
- **Implementation Steps**:
  1. Implement drag-and-drop functionality using libraries like React Beautiful DnD.
  2. Create functions to save and load user layout preferences.

### 5. Interactive Notifications
- **Functionality**: Notify users of significant metric changes (e.g., MAU drop).
- **Key Components**: 
  - Notification badge and message pop-ups for alerts.
- **Data Requirements**: Use dummy data with threshold-defined alerts.
- **User Interaction Flow**: Users receive notifications that link to affected data.
- **Challenges/Solutions**: Implement user settings to control notification types.
- **Implementation Steps**:
  1. Create a notification system with conditions for alerts.
  2. Implement user settings for notification preferences.

## Interconnectivity
- Each new feature integrates seamlessly with the MetricsTable:
  - Filtering updates the displayed dataset.
  - Charts reflect the current filtered metrics.
  - User engagement and dashboard customization maintain state across interactions.

## User Interaction
- Users will:
  - Hover or click on table rows.
  - Filter data using dropdowns/sliders.
  - View visualizations by clicking metrics.
  - Engage with gamification features.
  - Customize their dashboard layout.
  - Receive notifications about significant changes.

## Prioritization
1. Dynamic Data Filtering
2. Data Visualization Integration
3. Customizable Dashboard Layout
4. User Engagement Features
5. Interactive Notifications

## Additional Considerations
- **Performance**: Implement lazy loading for large datasets to improve rendering performance.
- **Accessibility**: Ensure the application is accessible, with keyboard navigation and screen reader support.
- **Responsive Design**: Although focused on desktop, ensure the layout can adapt to different screen sizes.

This comprehensive plan aims to enhance user experience through improved interactivity, engagement, and data presentation. It ensures that the application meets professional ERP standards while remaining user-friendly and visually appealing.`

## **FileRequirements**
- Create **1 JS file** with **no styling**.
- Use only **dummy data**. **No backend** or API calls, only dummy data should be used.
- The entire file should be **self-contained**. **DO NOT** import any other JS files or components.

## **Rules**

### **General**
- **No errors or bugs** allowed. The code must work perfectly on the first try.
- Provide **complete, fully functional code** with no missing implementations or placeholder logic.
- **DO NOT** ask the user to implement anything. **DO NOT** leave out any code. Recreate everything within this file, and **DO NOT** import any external JS files or components.
- All necessary code must be included in this file, fully implemented, and functional with **no missing parts**.

### **ResponseFormat**
- Output **only** the requested code or response. **DO NOT** include explanations, comments, or additional information. Respond with the **complete code only**.

### **NoHeader**
- **DO NOT** include a header or any boilerplate explanations. Start **directly** with the code implementation.

## **ComponentRequirements**
- The component must be **fully implemented**, with **all functionality** integrated. **Nothing should be left out** or incomplete. Ensure all pieces work together seamlessly, and the code is ready to run without any issues.



# **Instructions**

## **ComponentRequirements**
- You will be given the requirements for a component. Create **complete React code** only for the component and nothing else.
- Ensure the React code works flawlessly using the **latest version of React**.
- **DO NOT** summarize or leave anything out. All functionality must be fully implemented and working together.
- `Component Name: MentorFilter, Component requirements: ### Final Plan for Mentor Filter Component Enhancement

#### **Description**
The MentorFilter component enhances the Mentor Overview Page by providing users with comprehensive filtering options for expertise and availability, enabling efficient selection of suitable mentors.

#### **Content**
- **Component Overview:** 
  The MentorFilter is designed to improve user experience by allowing users to filter mentors based on specific criteria (expertise areas and availability). It consists of dropdown menus and checkboxes, updating the displayed mentor profiles in real-time to match selected filters.

- **Functionality:** 
  - **Expertise Filters:** Dropdown menus allow users to filter mentors by expertise areas (Technology, Marketing, Finance, etc.).
  - **Availability Filters:** Checkboxes indicate availability status (Available Now, Busy, Booked).
  - **Real-Time Updates:** The MentorProfileList refreshes automatically as users adjust the filters.
  - **Responsive Design:** Ensures usability across various desktop resolutions.

- **Visibility:** The MentorFilter component is prominently displayed on the Mentor Overview Page, ensuring constant access for users.

- **Interconnectivity:**
  - **MentorProfileList:** The MentorFilter directly interacts to filter mentors based on user-selected criteria, enhancing the overall functionality of the Mentor Overview Page.

- **User Interaction:**
  - **Selection Process:** Users select expertise through dropdowns and availability via checkboxes.
  - **Example Interaction:** User selects 'Technology' and checks 'Available Now', resulting in the MentorProfileList displaying only mentors who match these criteria.
  - **Dynamic Result Functionality:** The MentorProfileList reflects changes in real-time, streamlining the mentor selection process for users.

#### **New Ideas for Enhancements**
To further enhance user engagement, interactivity, and overall experience, the following features can be integrated:

1. **Mentor Ratings and Reviews**
   - **Functionality:** Users can view ratings (1-5 stars) and reviews for each mentor.
   - **Components:** 
     - Star rating system.
     - Modal for detailed reviews.
   - **User Flow:** Hovering over a mentor reveals ratings; clicking opens a modal for detailed reviews.
   - **Moderation:** Implement a moderation process for real reviews to avoid spam.

2. **Visual Performance Metrics**
   - **Functionality:** Display visual data on mentor performance (e.g., successful matches).
   - **Components:** 
     - Graphs/charts (using ECharts).
   - **User Flow:** Clicking a mentor's profile shows performance metrics in a section or modal.
   - **Responsive Design:** Ensure charts resize appropriately based on screen dimensions.

3. **Mentor Availability Calendar**
   - **Functionality:** Provides a calendar view of mentor availability.
   - **Components:** 
     - Calendar component showing available time slots.
   - **User Flow:** Users click on a mentor's profile to view availability and can book sessions directly.
   - **Data Management:** Use state management to sync calendar data and availability status.

4. **Gamification Features**
   - **Functionality:** Implement a points system for user engagement (e.g., booking sessions, leaving reviews).
   - **Components:** 
     - Points tracker and achievement badges.
   - **User Flow:** Users can view their earned points and badges on their profiles.
   - **Engagement Strategy:** Define clear criteria for earning points to encourage genuine user engagement.

5. **Customized Mentor Recommendations**
   - **Functionality:** Provide personalized mentor suggestions based on user preferences.
   - **Components:** 
     - Recommendation engine that analyzes user preferences.
   - **User Flow:** Users fill out a quick questionnaire, and the system suggests tailored mentors.
   - **Data Strategy:** Regularly refresh the recommendation algorithm with dummy data for testing purposes.

#### **Step-by-Step Plan**

**1. Clarification**
   - Ensure each functional aspect of the MentorFilter is clear and concise, enabling straightforward implementation.

**2. Implementation Guidance**
   - **Dropdown Menus:** 
     - Implement using a UI library (e.g., React Select) for expertise selection.
     - Set up functions to handle selection changes and filter mentor data accordingly.
   - **Checkboxes:** 
     - Utilize standard HTML checkboxes for availability options.
     - Create state variables to track checked status and update the mentor list upon user interaction.
   - **Real-Time Updates:** 
     - Use state management (e.g., React's useState) to trigger updates in the MentorProfileList based on filter selections.

**3. Efficiency**
   - Structure the component logically, separating concerns (filter logic, UI elements, and data handling).

**4. Technical Specifications**
   - Use React.js for the component structure.
   - Employ ECharts for visual metrics.
   - Utilize a calendar library (e.g., react-calendar) for availability views.

**5. Examples**
   - **Dropdown Example:** 
     ```jsx
     <Select options={expertiseOptions} onChange={handleExpertiseChange} />
     ```
   - **Checkbox Example:** 
     ```jsx
     <Checkbox onChange={handleAvailabilityChange} label="Available Now" />
     ```

**6. Edge Cases**
   - Test scenarios where no mentors match the selected filters.
   - Ensure performance metrics display even when a mentor has no reviews or data.

**7. Enhancements**
   - Optimize the MentorFilter for better performance by minimizing re-renders.
   - Consider lazy loading mentor data to improve initial page load times.

#### **Prioritization**
1. **Mentor Ratings and Reviews** - High impact; immediate user feedback.
2. **Visual Performance Metrics** - High impact; enhances decision-making.
3. **Mentor Availability Calendar** - Moderate impact; improves booking efficiency.
4. **Gamification Features** - Moderate impact; fosters ongoing user engagement.
5. **Customized Mentor Recommendations** - High impact; personalizes the user experience. 

By implementing these enhancements, the MentorFilter component can significantly elevate user experience, making the mentor selection process more engaging, informative, and efficient for users.`

## **FileRequirements**
- Create **1 JS file** with **no styling**.
- Use only **dummy data**. **No backend** or API calls, only dummy data should be used.
- The entire file should be **self-contained**. **DO NOT** import any other JS files or components.

## **Rules**

### **General**
- **No errors or bugs** allowed. The code must work perfectly on the first try.
- Provide **complete, fully functional code** with no missing implementations or placeholder logic.
- **DO NOT** ask the user to implement anything. **DO NOT** leave out any code. Recreate everything within this file, and **DO NOT** import any external JS files or components.
- All necessary code must be included in this file, fully implemented, and functional with **no missing parts**.

### **ResponseFormat**
- Output **only** the requested code or response. **DO NOT** include explanations, comments, or additional information. Respond with the **complete code only**.

### **NoHeader**
- **DO NOT** include a header or any boilerplate explanations. Start **directly** with the code implementation.

## **ComponentRequirements**
- The component must be **fully implemented**, with **all functionality** integrated. **Nothing should be left out** or incomplete. Ensure all pieces work together seamlessly, and the code is ready to run without any issues.



# **Instructions**

## **ComponentRequirements**
- You will be given the requirements for a component. Create **complete React code** only for the component and nothing else.
- Ensure the React code works flawlessly using the **latest version of React**.
- **DO NOT** summarize or leave anything out. All functionality must be fully implemented and working together.
- `Component Name: FundingRoundsTable, Component requirements: ### Final Plan for Funding Rounds Table Component

**Description**
This plan outlines the enhancements and features for the FundingRoundsTable component, ensuring it provides a comprehensive and user-friendly experience for displaying detailed funding rounds information for startups.

**Content**
- **ComponentDescription**
    - A table format to display detailed funding rounds information in a professional ERP solution.

- **Functionality**
    - The FundingRoundsTable component is designed to display a comprehensive list of the startup's funding rounds. It provides detailed information, including the round type, amount raised, date, and any significant investors involved. This table allows users to quickly ascertain the financial history of the startup and track its funding progression over time. In edit mode, new rounds can be added, and existing entries can be modified, ensuring that all information remains current and accurate.

- **Details**
    - **Columns:**
        - Round Type
        - Amount
        - Date
        - Investors
    - **Features:**
        - Supports sorting by amount or date to tailor the view to user preferences.
        - Filtering options to view specific funding rounds based on criteria such as round type or investor names.
        - Integration of interactive charts to visualize funding trends over time.
        - A summary section that aggregates data, showing total funds raised and number of rounds.

- **UserInteraction**
    - Users can click on a row to view detailed funding information or edit entries.
    - A popup provides a detailed breakdown or an edit interface.
    - Interactive elements such as tooltips or hover effects to enhance the user experience.

- **Dynamic Content**
    - Implement real-time updates of the table as users add or modify funding rounds, ensuring that the displayed data is always current.

- **Customization Options**
    - Allow users to save their preferred sorting and filtering settings for future visits, enhancing personalization.

**New Features and Improvements**
- **Data Visualization**
    - Integrate ECharts to provide visual representations of funding trends, showing total funds raised over time and the distribution of funding types.
    - Implement a pie chart to display the percentage of total funding by investor, enhancing the visual understanding of funding sources.

- **User Engagement**
    - Introduce a notification system to alert users when new funding rounds are added or when their favorite investors participate in a round.

- **Productivity Tools**
    - Add a bulk upload feature to allow users to enter multiple funding rounds at once using a CSV format.
    - Include a quick search bar to filter funding rounds by keywords (e.g., investor names, round types).

- **Gamification**
    - Introduce a "Funding Milestone" badge system that rewards users for tracking and updating funding rounds regularly, encouraging user engagement.

- **Interactivity**
    - Allow users to click on investor names to view a modal with detailed investor profiles, including past investments and performance metrics.

**Planning Outline**
- **Main Functionality**
    - Display, edit, and visualize funding rounds data in an interactive and engaging manner.

- **Key Components or Modules**
    - FundingRoundsTable
    - FundingTrendChart (using ECharts)
    - InvestorProfileModal
    - NotificationSystem
    - BulkUploadFeature

- **Data Requirements**
    - Utilize dummy data for funding rounds, including round type, amount, date, and investor names.
    - Example dummy data:
        ```json
        [
            {"roundType": "Seed", "amount": 500000, "date": "2023-01-15", "investors": ["Investor A", "Investor B"]},
            {"roundType": "Series A", "amount": 2000000, "date": "2023-06-20", "investors": ["Investor C"]},
            {"roundType": "Series B", "amount": 5000000, "date": "2023-09-10", "investors": ["Investor A", "Investor D"]}
        ]
        ```

- **User Interaction Flow**
    - Users can view the table, sort/filter data, click on rows for detailed views, and edit entries directly from popups.
    - Users receive notifications for new funding updates and can access investor profiles via the table.

- **Potential Challenges and Solutions**
    - **Challenge:** Users may find it difficult to navigate through large datasets.
        - **Solution:** Implement robust filtering and sorting options, including a search bar for quick access.
    - **Challenge:** Real-time updates may be complex.
        - **Solution:** Utilize local state management to handle updates efficiently without backend dependencies.

- **Prioritization**
    - Rank ideas based on impact and feasibility:
        1. Data Visualization (FundingTrendChart, pie chart for investors)
        2. User Engagement (Notification system)
        3. Interactivity (Investor profiles)
        4. Productivity Tools (Bulk upload feature, quick search)
        5. Gamification (Funding Milestone badge system)
        6. Customization Options (Save sorting/filter settings)

**StepByStepPlan**
- **Clarification**
    - Ensure each point in the user's plan is clear and concise, focusing on essential features and their implementations.

- **ImplementationGuidance**
    - **FundingRoundsTable Component:**
        - Create a table structure with columns for Round Type, Amount, Date, and Investors.
        - Implement sorting functionality using event listeners for click events on the column headers.
        - Develop filtering options with dropdown menus or checkboxes for users to select criteria.

    - **Data Visualization:**
        - Integrate ECharts for the FundingTrendChart by setting up a component that receives data from the table.
        - Create methods to calculate total funds raised and funding distribution for pie chart representation.

    - **User Engagement:**
        - Set up a notification system using event emitters or local state to track changes in funding rounds.
        - Create a notification UI component that displays alerts to users.

    - **Productivity Tools:**
        - Build the bulk upload feature to parse CSV files and update the table dynamically.
        - Create a search bar component that filters the table based on user input.

    - **Gamification:**
        - Develop a badge system that tracks user interactions with the table and awards badges for milestones.

    - **Interactivity:**
        - Implement modal components for detailed investor profiles, loading data on click events.

- **Efficiency**
    - Structure the code logically, ensuring each module is self-contained for easier maintenance and updates.

- **Technical Specifications**
    - Utilize React or Vue.js for component-based architecture.
    - Use state management libraries like Redux or Vuex if necessary for managing complex state interactions.

- **Examples**
    - For the FundingRoundsTable:
        ```jsx
        <Table>
            <TableHeader>
                <TableRow>
                    <TableCell onClick={sortByType}>Round Type</TableCell>
                    <TableCell onClick={sortByAmount}>Amount</TableCell>
                    <TableCell onClick={sortByDate}>Date</TableCell>
                    <TableCell>Investors</TableCell>
                </TableRow>
            </TableHeader>
            <TableBody>
                {fundingRounds.map(round => (
                    <TableRow key={round.id} onClick={() => openDetailModal(round)}>
                        <TableCell>{round.roundType}</TableCell>
                        <TableCell>{round.amount}</TableCell>
                        <TableCell>{round.date}</TableCell>
                        <TableCell>{round.investors.join(", ")}</TableCell>
                    </TableRow>
                ))}
            </TableBody>
        </Table>
        ```

- **EdgeCases**
    - Handle scenarios where data is missing or incorrectly formatted during bulk uploads.
    - Ensure the table updates correctly when data is deleted or modified by users.

- **Enhancements**
    - Consider adding keyboard navigation support for accessibility.
    - Plan for mobile responsiveness in future iterations, even though this plan focuses on desktop.

This final plan provides a comprehensive roadmap for enhancing the FundingRoundsTable component, focusing on user experience, data representation, and interactivity to create a professional ERP solution tailored for startup funding management.`

## **FileRequirements**
- Create **1 JS file** with **no styling**.
- Use only **dummy data**. **No backend** or API calls, only dummy data should be used.
- The entire file should be **self-contained**. **DO NOT** import any other JS files or components.

## **Rules**

### **General**
- **No errors or bugs** allowed. The code must work perfectly on the first try.
- Provide **complete, fully functional code** with no missing implementations or placeholder logic.
- **DO NOT** ask the user to implement anything. **DO NOT** leave out any code. Recreate everything within this file, and **DO NOT** import any external JS files or components.
- All necessary code must be included in this file, fully implemented, and functional with **no missing parts**.

### **ResponseFormat**
- Output **only** the requested code or response. **DO NOT** include explanations, comments, or additional information. Respond with the **complete code only**.

### **NoHeader**
- **DO NOT** include a header or any boilerplate explanations. Start **directly** with the code implementation.

## **ComponentRequirements**
- The component must be **fully implemented**, with **all functionality** integrated. **Nothing should be left out** or incomplete. Ensure all pieces work together seamlessly, and the code is ready to run without any issues.



# **Instructions**

## **ComponentRequirements**
- You will be given the requirements for a component. Create **complete React code** only for the component and nothing else.
- Ensure the React code works flawlessly using the **latest version of React**.
- **DO NOT** summarize or leave anything out. All functionality must be fully implemented and working together.
- `Component Name: TableCell, Component requirements: ### Final Plan for Enhanced Metrics Table Component

#### **Component Description**
The Enhanced Metrics Table component will serve as a dynamic and interactive dashboard for displaying key performance indicators (KPIs). The table will present metrics in a structured format, providing users with the ability to edit, analyze, and visualize data in an engaging manner.

#### **Core Functionality**
1. **TableCell Components**:
   - Each `TableCell` will represent a metric, allowing for inline editing and displaying tooltips with additional context.
   - Inline editing should include validation to ensure accuracy (e.g., numeric inputs).

2. **Data Visualization**:
   - Integration of ECharts for visual representation of trends and comparisons linked to metrics.
   - Charts should update dynamically based on the selected metric from the table.

3. **Dynamic Content**:
   - Real-time updates of the table as users edit data or switch datasets.
   - Use WebSockets or similar technologies to facilitate real-time data updates.

4. **Notification System**:
   - Implement a notification system to inform users of significant changes or updates in the data.
   - Notifications should have types (info, warning, success) and be dismissible.

#### **Details**
- **Inline Editing**: Each `TableCell` supports inline editing with live validation.
- **Hover Tooltips**: Tooltips will provide contextual data, including definitions and trends.
- **Dynamic Charts**: Charts that reflect the selected metrics will update in real-time.
- **Notifications**: Alerts will notify users of data changes and important updates.

#### **Interconnectivity**
- Each `TableCell` will link to detailed metrics pages (e.g., `/metrics/growth`), enabling users to delve deeper into specific data points for enhanced insights.

#### **User Interaction**
- **Interaction Flow**:
    1. User hovers over a `TableCell` to see a tooltip.
    2. User clicks to edit the data inline, with validation occurring on input.
    3. Upon saving, the table updates in real-time, and associated charts adjust accordingly.
    4. Notifications appear at the top of the table to inform users of significant changes.

#### **Potential Challenges and Solutions**
- **State Management**:
  - Use React's `useState` and `useEffect` hooks to manage state updates effectively.
  
- **User Experience**:
  - Implement debounce functionality for input changes to minimize performance hits.
  
- **Integration of Notifications**:
  - Utilize a notification library to create customizable alerts that do not overwhelm users.

#### **Idea Generation**
1. **Enhanced Tooltips**:
   - Tooltips will include mini-bar charts and trend lines for better context.
   - Ensure tooltips do not obstruct the editing experience by managing z-index.

2. **Data Filtering Options**:
   - Implement dropdowns or sliders to allow filtering of data by date, category, etc.
   - Consider pagination or lazy loading for handling large datasets.

3. **Gamification Elements**:
   - Introduce achievements or badges for user engagement in data accuracy.
   - Ensure that gamification does not distract from the core data focus.

4. **Customizable Views**:
   - Allow users to customize table views through a settings modal for sorting and column visibility.
   - Provide tooltips or guides to assist users in understanding customization options.

#### **Prioritization**
1. Enhanced Tooltips
2. Data Filtering Options
3. Customizable Views
4. Gamification Elements

---

### Step-By-Step Plan

#### **Description**
This section outlines actionable steps for implementing the Enhanced Metrics Table component while ensuring clarity and efficiency for coding.

#### **Steps**
1. **Clarification**
   - Define each `TableCell` to represent specific metrics with unique identifiers for inline editing and tooltips.
   - Ensure tooltips provide relevant definitions and mini-data visualizations.

2. **Implementation Guidance**
   - **Inline Editing**: Create a component for `TableCell` that handles user input and validation.
   - **Data Visualization**: Integrate ECharts by installing the library and creating chart components that accept data dynamically.
   - **Real-Time Updates**: Implement WebSocket connections to update table data in real-time based on user interactions.
   - **Notification System**: Use a notification library to manage alerts and incorporate them into the component.

3. **Efficiency**
   - Organize the code into modular components (e.g., `Table`, `TableCell`, `Chart`, `Tooltip`, `Notification`) for maintainability.
   - Use React's context or Redux for state management across the app.

4. **Technical Specifications**
   - Framework: React
   - Libraries: ECharts for visualization, a notification library (e.g., react-toastify) for notifications.
   - Methods: Utilize hooks like `useState`, `useEffect`, and event handlers for user interactions.

5. **Examples**
   - Example for inline editing:
     ```javascript
     const TableCell = ({ metric, value, onSave }) => {
       const [inputValue, setInputValue] = useState(value);

       const handleSave = () => {
         onSave(metric, inputValue);
       };

       return (
         <div>
           <input
             type="text"
             value={inputValue}
             onChange={(e) => setInputValue(e.target.value)}
             onBlur={handleSave}
           />
         </div>
       );
     };
     ```

6. **Edge Cases**
   - Handle scenarios where users input invalid data (e.g., letters in a numeric field).
   - Implement error handling to provide user feedback on input validation.

7. **Enhancements**
   - Optimize performance by using memoization techniques (e.g., `React.memo`) for components that do not change often.
   - Consider implementing dark mode support for user customization.

---

### Final Plan Summary
This comprehensive plan details the functionality and enhancements for the Enhanced Metrics Table component, designed to improve user experience, interactivity, and data presentation. The outlined steps provide clear guidance for implementation, ensuring that all functionalities work cohesively to create a professional and efficient desktop application. Each aspect is thoughtfully considered to maximize engagement and usability while maintaining performance and reliability.`

## **FileRequirements**
- Create **1 JS file** with **no styling**.
- Use only **dummy data**. **No backend** or API calls, only dummy data should be used.
- The entire file should be **self-contained**. **DO NOT** import any other JS files or components.

## **Rules**

### **General**
- **No errors or bugs** allowed. The code must work perfectly on the first try.
- Provide **complete, fully functional code** with no missing implementations or placeholder logic.
- **DO NOT** ask the user to implement anything. **DO NOT** leave out any code. Recreate everything within this file, and **DO NOT** import any external JS files or components.
- All necessary code must be included in this file, fully implemented, and functional with **no missing parts**.

### **ResponseFormat**
- Output **only** the requested code or response. **DO NOT** include explanations, comments, or additional information. Respond with the **complete code only**.

### **NoHeader**
- **DO NOT** include a header or any boilerplate explanations. Start **directly** with the code implementation.

## **ComponentRequirements**
- The component must be **fully implemented**, with **all functionality** integrated. **Nothing should be left out** or incomplete. Ensure all pieces work together seamlessly, and the code is ready to run without any issues.



# **Instructions**

## **ComponentRequirements**
- You will be given the requirements for a component. Create **complete React code** only for the component and nothing else.
- Ensure the React code works flawlessly using the **latest version of React**.
- **DO NOT** summarize or leave anything out. All functionality must be fully implemented and working together.
- `Component Name: BurnRateIndicator, Component requirements: ## Final Plan

### Component Description
The BurnRateIndicator component is a key visual tool for startups, designed to provide an immediate understanding of financial health through a gauge or progress bar that represents the current burn rate in relation to revenue. It serves as a central element on a financial dashboard, ensuring stakeholders can make informed decisions regarding budget adjustments or funding needs.

### Functionality
- **Visual Representation**: A gauge or progress bar that dynamically reflects the burn rate.
- **Color Coding**: 
  - Green: Healthy burn rate
  - Yellow: Caution
  - Red: Critical burn rate

### Details
- **Color-Coded Gauge**: Uses clear visual cues to indicate financial health.
- **Interactive Tooltip**: Displays exact figures on hover, including:
  - Current burn rate percentage
  - Months of runway remaining
  - Breakdown of expenses vs. revenue

### Visibility
- This component is prominently displayed on the dashboard, ensuring constant visibility for users to monitor financial status.

### Interconnectivity
- **Link to Budget Analysis**: A button or link that redirects users to a detailed budget analysis page for deeper insights.

### User Interaction
- **Hover Interaction**: Users hover over the gauge to reveal detailed information.
- **Tooltip Details**:
  - Exact burn rate percentage
  - Estimated runway left in months
  - Historical spending trends (if applicable)

### New Features and Enhancements

1. **Historical Burn Rate Chart**
   - **Functionality**: Displays burn rate trends over the past 12 months.
   - **Key Components**: Line chart using ECharts.
   - **User Interaction**: Hovering over data points reveals monthly burn rates.
   - **Potential Challenges**: Ensure accurate data representation; standardize dummy data format.

2. **Forecasting Tool**
   - **Functionality**: Users input projected expenses and revenues to estimate future burn rates.
   - **Key Components**: Input fields and a projection output gauge.
   - **User Interaction**: Users enter projections and trigger a calculation.
   - **Potential Challenges**: Simplify calculations for user clarity; provide clear examples.

3. **Notifications for Critical Burn Rates**
   - **Functionality**: Alerts users when the burn rate exceeds predefined thresholds.
   - **Key Components**: Notification pop-up or badge.
   - **User Interaction**: Users receive alerts based on predefined criteria.
   - **Potential Challenges**: Establish appropriate thresholds and timing for notifications.

4. **Customizable Dashboard Widgets**
   - **Functionality**: Users can select which financial metrics to display.
   - **Key Components**: Drag-and-drop interface for widget customization.
   - **User Interaction**: Users modify their dashboard layout by rearranging widgets.
   - **Potential Challenges**: Maintain a user-friendly interface while allowing customization.

5. **Gamification of Financial Management**
   - **Functionality**: Users earn badges for maintaining a healthy burn rate.
   - **Key Components**: Badge display system on the dashboard.
   - **User Interaction**: Users receive recognitions based on performance metrics.
   - **Potential Challenges**: Define relevant and achievable criteria for earning badges.

### Prioritization of Ideas
1. **Historical Burn Rate Chart**: High impact, feasible.
2. **Forecasting Tool**: High impact, moderate feasibility.
3. **Notifications for Critical Burn Rates**: Medium impact, high feasibility.
4. **Customizable Dashboard Widgets**: Medium impact, moderate feasibility.
5. **Gamification of Financial Management**: Low impact, moderate feasibility.

### Implementation Steps

#### Step 1: Clarification
- Ensure all stakeholders understand the purpose and utility of the BurnRateIndicator component.
- Define the metrics to be displayed and their significance.

#### Step 2: Core Functionality
- **Gauge Setup**: Implement a gauge or progress bar using libraries such as Ant Design or D3.js.
- **Data Binding**: Ensure that the component is bound to real-time financial data (e.g., burn rate, revenue).

#### Step 3: Tooltip Implementation
- Create an interactive tooltip that activates on hover.
- Use a library like React Tooltip or custom tooltip implementation to show detailed data.

#### Step 4: Historical Data Visualization
- Use ECharts to implement a line chart for historical burn rates.
- Ensure proper data fetching and binding to the chart component.

#### Step 5: Building the Forecasting Tool
- Create input fields for users to enter projected expenses and revenues.
- Implement a calculation function to derive the projected burn rate based on inputs.

#### Step 6: Notification System
- Setup a notification system to alert users when the burn rate passes critical thresholds.
- Use a state management solution (e.g., Redux) to track burn rate changes.

#### Step 7: Customizable Dashboard Widgets
- Implement a drag-and-drop interface for users to rearrange widgets.
- Ensure that the layout maintains a clean appearance while allowing customization.

#### Step 8: Gamification Elements
- Define criteria for earning badges.
- Implement a badge awarding system and display on the dashboard.

### Edge Cases
- **Data Unavailability**: Handle cases where financial data is not available by displaying a message or placeholder.
- **Input Validation**: Ensure user inputs in the forecasting tool are validated to prevent erroneous calculations.
- **Notification Spam**: Implement a delay or cooldown period for notifications to avoid overwhelming users.

### Enhancements
- **User Feedback Mechanism**: Include a feedback system for users to suggest improvements or report issues.
- **Performance Optimization**: Regularly assess component performance, particularly for the historical chart and forecasting calculations, to ensure smooth user experiences.
- **Mobile Responsiveness**: Although primarily for desktop, plan for future responsiveness to accommodate various screen sizes.

### Conclusion
This comprehensive plan for the BurnRateIndicator component outlines all necessary functionalities, user interactions, and enhancements to create a professional and useful tool for monitoring financial health in startups. By focusing on clarity, interactivity, and user engagement, this component will provide stakeholders with the insights they need to make informed financial decisions.`

## **FileRequirements**
- Create **1 JS file** with **no styling**.
- Use only **dummy data**. **No backend** or API calls, only dummy data should be used.
- The entire file should be **self-contained**. **DO NOT** import any other JS files or components.

## **Rules**

### **General**
- **No errors or bugs** allowed. The code must work perfectly on the first try.
- Provide **complete, fully functional code** with no missing implementations or placeholder logic.
- **DO NOT** ask the user to implement anything. **DO NOT** leave out any code. Recreate everything within this file, and **DO NOT** import any external JS files or components.
- All necessary code must be included in this file, fully implemented, and functional with **no missing parts**.

### **ResponseFormat**
- Output **only** the requested code or response. **DO NOT** include explanations, comments, or additional information. Respond with the **complete code only**.

### **NoHeader**
- **DO NOT** include a header or any boilerplate explanations. Start **directly** with the code implementation.

## **ComponentRequirements**
- The component must be **fully implemented**, with **all functionality** integrated. **Nothing should be left out** or incomplete. Ensure all pieces work together seamlessly, and the code is ready to run without any issues.



# **Instructions**

## **ComponentRequirements**
- You will be given the requirements for a component. Create **complete React code** only for the component and nothing else.
- Ensure the React code works flawlessly using the **latest version of React**.
- **DO NOT** summarize or leave anything out. All functionality must be fully implemented and working together.
- `Component Name: EngagementTimeline, Component requirements: **Final Plan**

**Component Overview**
- **Component Description**: The EngagementTimeline component provides a comprehensive visual representation of the investor's engagement history using interactive timelines and advanced data visualization techniques, primarily designed for desktop use.

**Functionality**
- The EngagementTimeline component will render an interactive visual depiction of the engagement history. It will feature heat maps and tree graphs to offer insights into the frequency and nature of interactions over time, enabling users to quickly assess relationship dynamics and enhance their understanding.

**Detailed Features**
1. **Visual Representation**:
   - **Heat Map**: 
     - Utilize a heat map to indicate the frequency of interactions, where color intensity varies based on engagement levels. Implement a gradient scale where dark colors indicate high engagement and lighter colors signify low engagement.
   - **Tree Graph**: 
     - Create a tree graph to represent hierarchical relationships and different types of engagements. This should include collapsible nodes for a cleaner view that allows users to drill down into specific relationships.

2. **Interactivity**:
   - **Zoom Functionality**: 
     - Users can use zoom controls (buttons or mouse scroll) to focus on specific time periods, enhancing the examination of engagement patterns.
   - **Engagement Node Details**: 
     - Clicking on timeline nodes should trigger an overlay/modal to display detailed information about each engagement, including the date, type, specific notes, and any associated actions.
   - **Filtering Options**: 
     - Include filter options allowing users to customize the timeline view based on engagement types (e.g., meetings, calls, emails) or specific date ranges. Filters should update the data dynamically as selections are made.

3. **Dynamic Content**:
   - **Real-Time Updates**: 
     - Implement a real-time update mechanism to reflect changes in the engagement data instantly as users adjust filters or interact with the timeline.

4. **User Engagement**:
   - **Gamification**: 
     - Integrate gamification elements, such as badges or milestones for frequent interactions or reaching specific engagement levels to motivate user participation.
   - **Notifications**: 
     - Provide in-app notifications for users regarding significant interactions or changes in engagement status, ensuring users remain informed.

**User Interaction Flow**
1. Users access the EngagementTimeline component and are presented with a default view of engagement data.
2. Users can utilize zoom controls to adjust the timeline view, focusing on specific periods.
3. By clicking on engagement nodes, a detailed modal should appear, offering insights into each interaction.
4. Users apply filters to customize their view, which should dynamically update the timeline based on selected criteria.
5. The system prompts users with notifications for key engagement events, enhancing user awareness and interaction.

**Key Components or Modules**
1. **HeatMapComponent**: Responsible for rendering the heat map visualizing engagement frequency.
2. **TreeGraphComponent**: Displays hierarchical interaction data.
3. **ZoomControls**: UI elements for zooming in and out of the timeline.
4. **FilterOptions**: Dropdowns or checkboxes enabling engagement type and date range filtering.
5. **EngagementDetailsModal**: Modal component for displaying detailed engagement information upon clicking nodes.

**Data Requirements**
- Dummy data structure:
    ```json
    [
        {
            "date": "2023-01-01",
            "type": "Meeting",
            "details": "Discussion on investment strategies",
            "frequency": 5
        },
        {
            "date": "2023-01-15",
            "type": "Call",
            "details": "Follow-up on previous meeting",
            "frequency": 3
        },
        {
            "date": "2023-02-10",
            "type": "Email",
            "details": "Quarterly report sent",
            "frequency": 8
        }
    ]
    ```

**Potential Challenges and Solutions**
- **Challenge**: Performance issues with complex visualizations.
  - **Solution**: Optimize rendering through techniques like lazy loading for components and efficient data handling (e.g., only render visible parts of the graph).
  
- **Challenge**: User confusion with excessive interaction options.
  - **Solution**: Provide tooltips and onboarding tutorials to guide new users through the features.

- **Challenge**: Maintaining responsiveness on different screen sizes.
  - **Solution**: Implement responsive design principles and conduct thorough testing to ensure usability.

**Prioritization of Ideas**
1. **Dynamic Content Updates**: High impact; keeps users engaged in real-time.
2. **Gamification Features**: Increase user interaction and motivation.
3. **Detailed Engagement Modals**: Provides essential insights that enhance value.
4. **Interactive Zoom and Filter Options**: Improves user experience through customization.
5. **Visual Representation Enhancements**: Important for data presentation but requires careful design to avoid clutter.

**Step-by-Step Plan**

1. **Clarification**
   - Refine each feature and functionality to ensure they are actionable and target specific user needs.

2. **Implementation Guidance**
   - For each module, define methods for rendering the heat map, tree graph, zoom controls, etc., ensuring clear input/output requirements.
   - Implement error handling for user interactions (e.g., no data found for selected filters).

3. **Efficiency**
   - Organize the codebase into separate files or modules for each component (e.g., HeatMapComponent.js, TreeGraphComponent.js, etc.) to enhance maintainability.

4. **Technical Specifications**
   - Frameworks: Use React for component structure, D3.js for data visualization, and CSS Grid/Flexbox for layout.
   - Methods: Create methods for fetching data, updating state, and rendering visuals in an optimized manner.

5. **Examples**
   - Create sample datasets for testing various interactions, such as filtering by date range and type of engagement.

6. **Edge Cases**
   - Test scenarios where no engagement data is available. Ensure the UI gracefully handles this with appropriate messaging.
   - Validate the filter functionality to ensure it correctly updates the visualizations.

7. **Enhancements**
   - Consider adding export functionality (e.g., CSV, PDF) for users to save their engagement history.
   - Implement user preferences for default views and filter settings to enhance personalization.

This comprehensive plan covers all aspects of the EngagementTimeline component, ensuring that functionality, user experience, and maintainability are prioritized for a professional ERP system.`

## **FileRequirements**
- Create **1 JS file** with **no styling**.
- Use only **dummy data**. **No backend** or API calls, only dummy data should be used.
- The entire file should be **self-contained**. **DO NOT** import any other JS files or components.

## **Rules**

### **General**
- **No errors or bugs** allowed. The code must work perfectly on the first try.
- Provide **complete, fully functional code** with no missing implementations or placeholder logic.
- **DO NOT** ask the user to implement anything. **DO NOT** leave out any code. Recreate everything within this file, and **DO NOT** import any external JS files or components.
- All necessary code must be included in this file, fully implemented, and functional with **no missing parts**.

### **ResponseFormat**
- Output **only** the requested code or response. **DO NOT** include explanations, comments, or additional information. Respond with the **complete code only**.

### **NoHeader**
- **DO NOT** include a header or any boilerplate explanations. Start **directly** with the code implementation.

## **ComponentRequirements**
- The component must be **fully implemented**, with **all functionality** integrated. **Nothing should be left out** or incomplete. Ensure all pieces work together seamlessly, and the code is ready to run without any issues.



# **Instructions**

## **ComponentRequirements**
- You will be given the requirements for a component. Create **complete React code** only for the component and nothing else.
- Ensure the React code works flawlessly using the **latest version of React**.
- **DO NOT** summarize or leave anything out. All functionality must be fully implemented and working together.
- `Component Name: PaginationControl, Component requirements: ### Final Plan for Pagination Control Enhancement in Metrics Table

**Component Description**  
The PaginationControl component manages pagination for the MetricsTable, allowing users to navigate through large datasets efficiently. This component enhances user experience by providing intuitive pagination controls, including navigation buttons and options for customizing displayed data. It ensures users can access relevant information without overwhelming the interface.

---

**Functionality**  
The PaginationControl will provide users with a seamless experience when navigating through data. Key functionalities include:

1. **Next and Previous Buttons**: Allow users to navigate to adjacent pages.
2. **First and Last Page Buttons**: Enable quick access to the start and end of the dataset.
3. **Rows per Page Dropdown**: Users can select how many rows they wish to view at once (e.g., 5, 10, 25, 50).
4. **Current Page Indicator**: Displays the current page number and total pages.
5. **Jump to Page Input**: Allows users to directly input a page number to navigate to.
6. **Data Summary**: Shows the total number of records and the range of records currently displayed (e.g., "Showing 1-10 of 100").

---

**Core Features Implementation**

1. **Next and Previous Buttons**  
   - **Implementation**: Create button elements with event listeners for click actions that adjust the current page index.
   - **Error Handling**: Ensure buttons are disabled when the user is on the first page (previous) or the last page (next).

2. **First and Last Page Buttons**  
   - **Implementation**: Add buttons that set the current page to 1 (first) or to the total number of pages (last).
   - **Error Handling**: Similar to above, handle cases where these buttons should be disabled when on respective pages.

3. **Rows per Page Dropdown**  
   - **Implementation**: Use a select element with options for the user to choose the number of rows displayed. Update state accordingly.
   - **Efficiency**: Ensure that the dropdown change event recalculates the total number of pages based on the selected rows per page.

4. **Current Page Indicator**  
   - **Implementation**: Display the current page number and total pages dynamically as the user interacts with pagination controls.
   - **Example**: "Page 2 of 10".

5. **Jump to Page Input**  
   - **Implementation**: Include an input field that accepts page numbers. Validate input to ensure it's within the valid range before updating the current page.
   - **Edge Cases**: Handle invalid inputs gracefully, providing feedback to the user.

6. **Data Summary**  
   - **Implementation**: Show a summary label that updates based on the current page and the total number of records.
   - **Example**: "Showing 1-10 of 100".

---

**Visibility**  
The PaginationControl will always be visible when the MetricsTable is displayed, providing constant access to pagination features.

---

**Interconnectivity**  
The PaginationControl directly affects the data displayed in the MetricsTable. It communicates with the MetricsTable to update the displayed data based on user interactions. This requires proper state management to ensure that changes in pagination reflect immediately in the table.

---

**User Interaction**  
Users will interact with the PaginationControl as follows:

- Clicking the next and previous buttons to change the page.
- Selecting a number from the dropdown to adjust the number of rows shown per page.
- Inputting a page number to jump directly to that page.

**Result**: The MetricsTable data is paginated, and a new set of rows is displayed according to the user's navigation choices, enhancing the efficiency of data navigation and improving user experience.

---

### Idea Generation for Enhancements

1. **User Engagement Features**
   - **Feature**: Tooltips explaining pagination controls.
   - **Implementation**: Add tooltips that appear on hover, providing information about what each button does.
   - **Data Requirements**: Dummy text for tooltips (e.g., "Go to the next page").
   - **Interaction Flow**: User hovers over buttons to see tooltips.
   - **Challenges**: Ensuring tooltips do not obstruct content.
   - **Solutions**: Position tooltips with CSS to avoid overlap.

2. **Data Visualization**
   - **Feature**: Mini chart alongside pagination controls showing data trends.
   - **Implementation**: Use a lightweight charting library (e.g., Chart.js) to create a small line chart of the dataset's key metrics.
   - **Data Requirements**: Dummy data representing trends (e.g., monthly data).
   - **Interaction Flow**: Users can see immediate trends as they paginate.
   - **Challenges**: Synchronizing chart data with current page data.
   - **Solutions**: Update the chart data dynamically based on pagination events.

3. **Interactive Filters**
   - **Feature**: Filters to narrow down displayed data based on criteria (e.g., date range, category).
   - **Implementation**: Add filter dropdowns above the pagination controls.
   - **Data Requirements**: Dummy filter options (e.g., date ranges, categories).
   - **Interaction Flow**: Users select filters to adjust the displayed dataset before paginating.
   - **Challenges**: Managing filter states alongside pagination.
   - **Solutions**: Use state management to keep track of selected filters.

4. **Customization Options**
   - **Feature**: Allow users to save pagination settings (e.g., default rows per page).
   - **Implementation**: Provide a settings icon that opens a modal for customization.
   - **Data Requirements**: Dummy user preferences to define default settings.
   - **Interaction Flow**: Users set and save their preferred pagination layout.
   - **Challenges**: Storing user preferences without a backend.
   - **Solutions**: Utilize local storage to remember user settings.

5. **Dynamic Notifications**
   - **Feature**: Notifications for when users reach the last page or when no more data is available.
   - **Implementation**: Show a message when the user navigates to the last page or tries to go beyond available records.
   - **Data Requirements**: Dummy message strings for notifications.
   - **Interaction Flow**: Users receive feedback when they reach the limits of pagination.
   - **Challenges**: Ensuring notifications do not disrupt the user experience.
   - **Solutions**: Display notifications in a subtle manner (e.g., a toast notification).

---

### Prioritization of Ideas
1. **Interactive Filters**: High impact and feasibility, significantly improves data accessibility.
2. **User Engagement Features**: High impact for user experience, easy to implement.
3. **Data Visualization**: Moderate impact, adds value but may require more development.
4. **Dynamic Notifications**: Moderate impact, good for user feedback but less critical.
5. **Customization Options**: Lower impact, more of a nice-to-have feature, may require more complexity.

---

### Step-by-Step Plan

1. **Clarify Core Features**
   - Ensure each feature is well defined and the expected behavior is understood.

2. **Set Up Pagination State Management**
   - Create a state variable to hold the current page index, total number of records, rows per page, and any filters.

3. **Implement Navigation Buttons**
   - Create and position Next, Previous, First, and Last buttons. Add event listeners to manage page changes.

4. **Create Rows per Page Dropdown**
   - Set up the dropdown with options for selecting the number of rows displayed. Add an event listener to update the pagination state.

5. **Develop Current Page Indicator and Data Summary**
   - Implement a display area for the current page and total records. Ensure it updates with each interaction.

6. **Integrate Jump to Page Input**
   - Create an input field for users to enter page numbers. Add validation to ensure input is within range.

7. **Implement Enhancements**
   - Add tooltips, interactive filters, data visualization, and customization options as discussed.

8. **Test Functionality**
   - Check all interactive elements for correct behavior, including edge cases (navigating beyond available pages, invalid input, etc.).

9. **Optimize User Experience**
   - Ensure all components are visually appealing and intuitive, using consistent styling and spacing.

10. **Document the Component**
    - Provide clear documentation on how to use the PaginationControl and how it interacts with the MetricsTable.

---

This comprehensive plan outlines the enhancements that can be made to the PaginationControl, ensuring a robust and user-friendly experience in the MetricsTable component. The ideas focus on improving user engagement, data accessibility, and interactivity while maintaining practicality and alignment with the current application theme. Each step in the plan is actionable and optimized for ease of coding, ensuring a streamlined development process.`

## **FileRequirements**
- Create **1 JS file** with **no styling**.
- Use only **dummy data**. **No backend** or API calls, only dummy data should be used.
- The entire file should be **self-contained**. **DO NOT** import any other JS files or components.

## **Rules**

### **General**
- **No errors or bugs** allowed. The code must work perfectly on the first try.
- Provide **complete, fully functional code** with no missing implementations or placeholder logic.
- **DO NOT** ask the user to implement anything. **DO NOT** leave out any code. Recreate everything within this file, and **DO NOT** import any external JS files or components.
- All necessary code must be included in this file, fully implemented, and functional with **no missing parts**.

### **ResponseFormat**
- Output **only** the requested code or response. **DO NOT** include explanations, comments, or additional information. Respond with the **complete code only**.

### **NoHeader**
- **DO NOT** include a header or any boilerplate explanations. Start **directly** with the code implementation.

## **ComponentRequirements**
- The component must be **fully implemented**, with **all functionality** integrated. **Nothing should be left out** or incomplete. Ensure all pieces work together seamlessly, and the code is ready to run without any issues.



# **Instructions**

## **ComponentRequirements**
- You will be given the requirements for a component. Create **complete React code** only for the component and nothing else.
- Ensure the React code works flawlessly using the **latest version of React**.
- **DO NOT** summarize or leave anything out. All functionality must be fully implemented and working together.
- `Component Name: Interconnections, Component requirements: ### Final Plan for Interconnections Component of ERP System

#### Component Description
The Interconnections component manages the connectivity between different pages and modules within the ERP system, facilitating seamless user navigation and data flow. It ensures that users can transition smoothly between various sections without losing context or data integrity.

#### Functionality
The Interconnections component is responsible for:
- Managing URL routing and navigation between pages.
- Handling state sharing across modules to ensure data consistency.
- Supporting seamless user journeys.
- Integrating with a shared context provider for data access and manipulation.

#### Details
- **URL Routing**: Define routes for each page.
- **State Management**: Utilize a context provider to share data among components.
- **User Journeys**: Design intuitive navigation paths between pages.
- **Interconnectivity Examples**:
  - `{'pageUrl': '/mentors/overview', 'description': 'Facilitates navigation to the Mentor Overview Page from other sections such as the main dashboard.'}`
  - `{'pageUrl': '/mentors/profile', 'description': 'Enables transitions to detailed mentor profiles from the Mentor Overview Page.'}`

#### User Interaction
- **Navigation Links and Buttons**: Users interact through sidebar tabs and buttons.
- **Example Interaction**:
  - **Action**: User clicks on the 'Mentors' tab.
  - **Result**: User navigates to the Mentor Overview Page, displaying the MentorDashboard component.

---

### Enhanced Features and Functionality

1. **User Engagement**
   - **Feature**: Introduce a user feedback mechanism on every page.
   - **Implementation**:
     - Create feedback buttons (thumbs up/down) on each page.
     - Store feedback ratings in an in-memory data structure.
     - Update feedback count dynamically on user interaction.
     - Consider using local state management to avoid conflicts with navigation.

2. **Data Visualization**
   - **Feature**: Dashboard widgets showing real-time statistics.
   - **Implementation**:
     - Utilize ECharts for graphical representation of data.
     - Set up responsive charts that automatically update based on dummy data for mentor count and sessions.
     - Ensure the charts are responsive to window resizing events.

3. **Interactivity**
   - **Feature**: Interactive map displaying mentor locations.
   - **Implementation**:
     - Use a JavaScript mapping library (e.g., Leaflet or Google Maps API).
     - Load mentor location data lazily to ensure efficient map loading.
     - Allow users to interact with map markers to view mentor details.

4. **Customization Options**
   - **Feature**: Dashboard view customization.
   - **Implementation**:
     - Provide toggle buttons for each widget on the dashboard.
     - Store user preferences in a context provider to maintain state across sessions.
     - Update the dashboard dynamically based on user-selected preferences.

5. **Dynamic Content**
   - **Feature**: News feed or announcement bar.
   - **Implementation**:
     - Create a component that fetches and displays announcements.
     - Use a simple polling mechanism to keep the feed updated without full-page refreshes.
     - Ensure the component is scrollable for user convenience.

6. **Notifications**
   - **Feature**: Real-time notifications for user actions.
   - **Implementation**:
     - Implement a notification component that listens for specific actions (e.g., feedback received).
     - Manage notification states using local state management.
     - Allow users to dismiss notifications once viewed.

---

### Prioritization of Ideas
1. **User Engagement (High Impact, Medium Feasibility)**
2. **Data Visualization (High Impact, High Feasibility)**
3. **Dynamic Content (Medium Impact, High Feasibility)**
4. **Customization Options (Medium Impact, Medium Feasibility)**
5. **Notifications (Medium Impact, Medium Feasibility)**
6. **Interactivity (Medium Impact, Low Feasibility)**

---

### Step-by-Step Implementation Plan

#### Step 1: Clarification
- Confirm all functionality and user interactions required for the Interconnections component, ensuring that the plan aligns with user needs.

#### Step 2: Implement URL Routing
- Define routes for all pages using a routing library (e.g., React Router).
- Ensure each route corresponds to a component that renders when navigated to.

#### Step 3: State Management Setup
- Integrate a context provider for sharing state across pages.
- Define state variables for user preferences, feedback ratings, and notifications.

#### Step 4: Develop User Engagement Feature
- Implement feedback buttons on each page.
- Create a function to handle feedback submissions and update the in-memory data structure.

#### Step 5: Create Data Visualization Components
- Set up ECharts components for displaying real-time data statistics.
- Ensure that the data updates are reflected in the charts without needing a full reload.

#### Step 6: Build the Interactive Map
- Incorporate a mapping library to render mentor locations.
- Load marker data efficiently, ensuring a smooth user experience.

#### Step 7: Customization Options Implementation
- Develop toggle buttons for dashboard widgets.
- Implement logic to update the dashboard view based on user selections.

#### Step 8: Dynamic Content Integration
- Create a component for the announcement feed.
- Implement polling to update the feed dynamically.

#### Step 9: Notifications Functionality
- Develop a notification component.
- Set up event listeners to trigger notifications based on user actions.

#### Step 10: Testing and Validation
- Identify edge cases for each feature (e.g., no mentors available, feedback submission errors).
- Conduct thorough testing to ensure the reliability of navigation and data integrity.

---

### Technical Specifications
- **Frameworks**: React for UI components, ECharts for data visualization, and a mapping library like Leaflet.
- **State Management**: React Context API for global state management.
- **Routing**: React Router for URL routing.
- **Testing**: Use Jest and React Testing Library for unit and integration tests.

---

### Example Interactions and Edge Cases
- **Example**: User clicks on the 'Mentors' tab and successfully navigates to the Mentor Overview Page.
- **Edge Case**: If no mentors are available, display a friendly message instead of an empty dashboard.

### Enhancements
- Consider adding user-specific dashboards that remember user preferences.
- Explore using WebSockets for real-time updates on notifications and announcements.

This comprehensive plan outlines the core functionality of the Interconnections component, alongside innovative enhancements that prioritize user experience and engagement. The focus on seamless navigation, interactivity, and data visualization aligns with the goal of creating a professional ERP system.`

## **FileRequirements**
- Create **1 JS file** with **no styling**.
- Use only **dummy data**. **No backend** or API calls, only dummy data should be used.
- The entire file should be **self-contained**. **DO NOT** import any other JS files or components.

## **Rules**

### **General**
- **No errors or bugs** allowed. The code must work perfectly on the first try.
- Provide **complete, fully functional code** with no missing implementations or placeholder logic.
- **DO NOT** ask the user to implement anything. **DO NOT** leave out any code. Recreate everything within this file, and **DO NOT** import any external JS files or components.
- All necessary code must be included in this file, fully implemented, and functional with **no missing parts**.

### **ResponseFormat**
- Output **only** the requested code or response. **DO NOT** include explanations, comments, or additional information. Respond with the **complete code only**.

### **NoHeader**
- **DO NOT** include a header or any boilerplate explanations. Start **directly** with the code implementation.

## **ComponentRequirements**
- The component must be **fully implemented**, with **all functionality** integrated. **Nothing should be left out** or incomplete. Ensure all pieces work together seamlessly, and the code is ready to run without any issues.



# **Instructions**

## **ComponentRequirements**
- You will be given the requirements for a component. Create **complete React code** only for the component and nothing else.
- Ensure the React code works flawlessly using the **latest version of React**.
- **DO NOT** summarize or leave anything out. All functionality must be fully implemented and working together.
- `Component Name: HeatMap, Component requirements: ### Final Plan for Engagement HeatMap Component

#### Component Description
The HeatMap component displays engagement intensity across various time periods using a heat map visualization. This interactive tool is essential for users to quickly understand investor engagement patterns and trends over time.

#### Functionality
The HeatMap component visually represents the intensity of investor engagements over time, using color gradients to indicate higher or lower levels of activity. This feature helps users identify peak interaction periods and assess the consistency of communication with investors. Users can perform quick comparisons across different time frames and support interaction for deeper exploration of specific dates or events.

#### Key Features and Details
1. **Calendar View**: 
   - A grid-style layout representing days within a month, where each cell corresponds to a unique date.
   - Color-coded cells indicate engagement frequency, with a gradient scale from light (low engagement) to dark (high engagement).

2. **Hover Effects**: 
   - Implement hover functionality that displays a tooltip with detailed statistics for that day, such as:
     - Number of contacts
     - Number of meetings
     - Engagement breakdown by type (calls, meetings, emails).

3. **Detailed Engagement View**: 
   - On click of a date cell, transition to a detailed view displaying all engagements for that day, including:
     - Types of engagements (calls, meetings, emails)
     - Associated investors
     - Time stamps of engagements.

4. **Filters**:
   - **Engagement Type**: Dropdown menu to filter by types of engagement (calls, meetings, emails).
   - **Investors**: Multi-select dropdown to choose specific investors or investor groups.
   - **Time Ranges**: Options to view data on daily, weekly, or monthly bases.
   - Ensure filters are easily accessible and intuitive to use.

5. **Dynamic Updates**: 
   - The heat map should automatically refresh to reflect the engagement intensity based on selected filters.
   - Implement loading indicators during the recalibration to improve user experience.

#### User Interaction
- **Interactivity**: 
   - The heat map allows users to interact through filtering options, hover effects, and clicking on dates for detailed views.
   - Ensure smooth transitions and responsive feedback for user actions.

- **Result Functionality**: 
   - When filters are applied, the heat map updates in real-time, highlighting the most relevant interactions.
   - Maintain performance even with extensive data by implementing efficient rendering techniques (e.g., virtual scrolling).

#### Interconnectivity
- **Links**: 
   - The component should include links to an Engagement Comparison page for cross-investor analysis, enhancing the user's ability to draw insights from different datasets seamlessly.

### Ideas for Enhancement
1. **Enhanced Data Visualization**
   - **Main Functionality**: Introduce a trend line overlay on the heat map to show overall engagement trends.
   - **Key Components**: Trend line chart integrated with the heat map.
   - **User Interaction Flow**: Users can toggle the trend line on/off using a checkbox.
   - **Challenges**: Ensure clarity in visualization when both heat map and trend line are displayed. Use distinct colors and line styles.

2. **Gamification Elements**
   - **Main Functionality**: Introduce badges or rewards for users achieving certain engagement milestones.
   - **Key Components**: A badge display area next to the heat map.
   - **User Interaction Flow**: Users receive notifications upon achieving milestones.
   - **Challenges**: Balance gamification without detracting from professionalism. Keep badges subtle.

3. **Customizable Views**
   - **Main Functionality**: Allow users to save specific filter configurations as "views" for quick access later.
   - **Key Components**: A "Save View" button next to the filters.
   - **User Interaction Flow**: Users can create, name, and delete views, which can be accessed from a dropdown menu.
   - **Challenges**: Store user preferences using local storage.

4. **Notifications for Engagement Patterns**
   - **Main Functionality**: Implement notifications to alert users of significant changes in engagement patterns.
   - **Key Components**: A notification icon in the UI that displays alerts.
   - **User Interaction Flow**: Users receive notifications when engagement intensity surpasses a certain threshold.
   - **Challenges**: Ensure notifications are relevant; allow users to customize settings.

### Prioritization of Ideas
1. **Enhanced Data Visualization**: High impact; improves insights directly.
2. **Customizable Views**: High impact; enhances user experience and productivity.
3. **Notifications for Engagement Patterns**: Medium impact; promotes user engagement.
4. **Gamification Elements**: Low to medium impact; should be integrated carefully.

### Step-By-Step Implementation Plan

#### Clarification
Each feature is designed to enhance user interaction and data analysis. Ensure that all elements are responsive and maintain a professional aesthetic.

#### Implementation Guidance
1. **Calendar View**:
   - Use a grid layout component to structure the calendar.
   - Apply CSS for color coding based on engagement data.

2. **Hover Effects**:
   - Utilize JavaScript to capture mouse events for hover effects.
   - Implement tooltips using a library like Tippy.js for enhanced UI.

3. **Detailed Engagement View**:
   - Create a modal or new section that displays detailed engagement data.
   - Ensure data is fetched dynamically based on the clicked date.

4. **Filters**:
   - Implement filter components (dropdowns, checkboxes) with event listeners for user interactions.
   - Utilize state management to handle filter selections and data updates.

5. **Dynamic Updates**:
   - Use React’s state management or similar frameworks to trigger UI updates based on filter changes.
   - Add loading indicators during data fetching.

#### Efficiency
- Structure code into modular components: HeatMap, Tooltip, Filter, and DetailedView.
- Ensure code reusability and maintainability by using component libraries or frameworks that support these features.

#### Technical Specifications
- Framework: React.js or Vue.js for UI components.
- Libraries: D3.js for data visualization, Tippy.js for tooltips.
- Data Management: Use state management tools like Redux or Context API for handling user preferences and filter states.

#### Examples
- Example of a color-coded cell: 
   ```javascript
   const getCellColor = (engagementCount) => {
       return engagementCount > 20 ? 'darkgreen' : engagementCount > 10 ? 'yellow' : 'lightgray';
   };
   ```
- Example of a hover effect:
   ```javascript
   <div className="cell" onMouseEnter={showTooltip} onMouseLeave={hideTooltip}>
       {engagementCount}
   </div>
   ```

#### Edge Cases
- Handle cases where no engagement data exists for a selected date by displaying a message.
- Test filter combinations to ensure no conflicts arise that would cause incorrect data display.

#### Enhancements
- Include user preference settings to customize notification thresholds.
- Implement caching mechanisms for filter views to improve loading times.

### Conclusion
This plan outlines a robust and interactive HeatMap component that not only provides essential insights into investor engagement but also enhances the user experience through interactivity, customization, and visual clarity. The proposed enhancements align with existing functionality while introducing innovative features that can significantly improve user engagement and productivity.`

## **FileRequirements**
- Create **1 JS file** with **no styling**.
- Use only **dummy data**. **No backend** or API calls, only dummy data should be used.
- The entire file should be **self-contained**. **DO NOT** import any other JS files or components.

## **Rules**

### **General**
- **No errors or bugs** allowed. The code must work perfectly on the first try.
- Provide **complete, fully functional code** with no missing implementations or placeholder logic.
- **DO NOT** ask the user to implement anything. **DO NOT** leave out any code. Recreate everything within this file, and **DO NOT** import any external JS files or components.
- All necessary code must be included in this file, fully implemented, and functional with **no missing parts**.

### **ResponseFormat**
- Output **only** the requested code or response. **DO NOT** include explanations, comments, or additional information. Respond with the **complete code only**.

### **NoHeader**
- **DO NOT** include a header or any boilerplate explanations. Start **directly** with the code implementation.

## **ComponentRequirements**
- The component must be **fully implemented**, with **all functionality** integrated. **Nothing should be left out** or incomplete. Ensure all pieces work together seamlessly, and the code is ready to run without any issues.



# **Instructions**

## **ComponentRequirements**
- You will be given the requirements for a component. Create **complete React code** only for the component and nothing else.
- Ensure the React code works flawlessly using the **latest version of React**.
- **DO NOT** summarize or leave anything out. All functionality must be fully implemented and working together.
- `Component Name: EditButton, Component requirements: # Final Plan for Enhancing the Startup Profile Page

## Component Description
A button that allows users to enter edit mode for the startup's profile. This feature will significantly enhance user interaction with the profile, enabling real-time updates and modifications.

## Functionality
The EditButton component is a crucial interactive element that enables users to toggle the entire StartupProfileCard into an editable state. When clicked, it activates edit mode, allowing users to modify startup details, add new team members, or update funding information. This button ensures that users have the flexibility to make real-time changes to startup profiles, facilitating dynamic updates and ensuring data integrity.

## Details
- **Button Type**: Floating Action Button (FAB) with a pencil icon.
- **Color Change**: The button changes color to indicate active edit mode.
- **Visibility**: Always visible on the profile page.

## Interconnectivity
- **Link**: Directs to `/profile-settings` for more in-depth customization and data management.

## User Interaction
- **Interaction**: User clicks to toggle edit mode for the profile card.
- **Possible Interactions**: Editable fields appear along with a save icon when in edit mode.
- **Result**: Allows all editable fields on the profile card and displays a save button.
- **Save Button Functionality**: When clicked, it validates all changes and updates the displayed data on the profile card.

---

## New Features and Enhancements

### 1. Dynamic Data Visualization
- **Main Functionality**: Integrate ECharts for visualizing startup metrics such as funding history, team growth, and market trends.
- **Key Components**:
  - Line charts for funding over time.
  - Pie charts for team composition.
- **Data Requirements**: Dummy data arrays representing funding amounts and team members.
- **User Interaction Flow**:
  - Users can hover over data points for detailed information.
  - Click to expand charts for more insights.
- **Potential Challenges and Solutions**:
  - **Challenge**: Complex data may overwhelm users.  
    **Solution**: Implement tooltips and legends for clarity.

### 2. Team Member Management
- **Main Functionality**: Allow users to add, edit, or remove team members directly from the profile page.
- **Key Components**:
  - Modal popup for adding team members with fields for name, role, and profile picture upload.
- **Data Requirements**: Dummy data for existing team members.
- **User Interaction Flow**:
  - User clicks on "Add Team Member" button, fills in the details, and clicks "Save" to update the list.
- **Potential Challenges and Solutions**:
  - **Challenge**: Ensuring data consistency.  
    **Solution**: Implement frontend validation for required fields.

### 3. Notification System
- **Main Functionality**: Provide real-time notifications for profile updates or changes made by team members.
- **Key Components**: 
  - Notification banner at the top of the profile that updates when changes occur.
- **Data Requirements**: Dummy data representing different types of notifications (e.g., "Team member added", "Profile updated").
- **User Interaction Flow**:
  - Users can view notifications and dismiss them.
- **Potential Challenges and Solutions**:
  - **Challenge**: Users may miss notifications.  
    **Solution**: Implement a badge counter for unread notifications.

### 4. Customization Options
- **Main Functionality**: Allow users to customize the look and feel of their profile with themes and layouts.
- **Key Components**: 
  - "Customize" button that opens a settings panel for theme selection and layout options.
- **Data Requirements**: Dummy data representing various themes and layouts.
- **User Interaction Flow**:
  - Users select options and see a preview in real-time.
- **Potential Challenges and Solutions**:
  - **Challenge**: Users may find it overwhelming.  
    **Solution**: Provide default settings and suggestions.

### 5. Gamification Elements
- **Main Functionality**: Introduce a points system for completing profile updates and engaging with the platform.
- **Key Components**: 
  - Progress bar showing user achievements and points earned.
- **Data Requirements**: Dummy data tracking user points and achievements.
- **User Interaction Flow**:
  - Users can view their progress and unlock badges for completing actions.
- **Potential Challenges and Solutions**:
  - **Challenge**: Users may not find it motivating.  
    **Solution**: Offer tangible rewards for reaching milestones.

---

## Prioritization of Ideas
1. **Dynamic Data Visualization** - High impact, moderate feasibility.
2. **Team Member Management** - High impact, high feasibility.
3. **Notification System** - Medium impact, high feasibility.
4. **Customization Options** - Medium impact, moderate feasibility.
5. **Gamification Elements** - Low impact, moderate feasibility.

---

## Step-By-Step Plan

### 1. Edit Button Implementation
- Create a floating action button using a library like Material-UI or Bootstrap.
- Set up event handling for the button to toggle edit mode.
- Change button color on activation.

### 2. Dynamic Data Visualization
- Integrate ECharts library for charting functionality.
- Create dummy data arrays for funding and team metrics.
- Implement hover interactions for tooltips and click events for detailed views.

### 3. Team Member Management
- Create a modal component that includes forms for adding/editing team members.
- Implement validation logic to ensure all required fields are filled before submission.
- Use local state management (e.g., React useState) to manage the list of team members.

### 4. Notification System
- Implement a notification banner component that listens for profile changes.
- Create a local state to manage notifications and a counter for unread notifications.
- Allow users to dismiss notifications by updating the local state.

### 5. Customization Options
- Implement a settings panel that allows users to select themes and layouts.
- Use CSS variables or a theming library to manage different styles.
- Provide a real-time preview using a state management solution.

### 6. Gamification Elements
- Create a progress tracking component to display user points and achievements.
- Implement logic to award points based on user actions.
- Design badges and a rewards system to encourage user engagement.

---

## Conclusion
This comprehensive plan outlines enhancements for the Startup Profile Page, focusing on user engagement, interactivity, and customization. These features will create a dynamic and user-friendly experience, encouraging active participation and fostering a strong startup community. All interactions and visualizations will utilize dummy data to ensure a smooth frontend experience without dependencies on backend systems. 

By following this plan, we can ensure every function works together cohesively to provide a rich user experience on the desktop platform.`

## **FileRequirements**
- Create **1 JS file** with **no styling**.
- Use only **dummy data**. **No backend** or API calls, only dummy data should be used.
- The entire file should be **self-contained**. **DO NOT** import any other JS files or components.

## **Rules**

### **General**
- **No errors or bugs** allowed. The code must work perfectly on the first try.
- Provide **complete, fully functional code** with no missing implementations or placeholder logic.
- **DO NOT** ask the user to implement anything. **DO NOT** leave out any code. Recreate everything within this file, and **DO NOT** import any external JS files or components.
- All necessary code must be included in this file, fully implemented, and functional with **no missing parts**.

### **ResponseFormat**
- Output **only** the requested code or response. **DO NOT** include explanations, comments, or additional information. Respond with the **complete code only**.

### **NoHeader**
- **DO NOT** include a header or any boilerplate explanations. Start **directly** with the code implementation.

## **ComponentRequirements**
- The component must be **fully implemented**, with **all functionality** integrated. **Nothing should be left out** or incomplete. Ensure all pieces work together seamlessly, and the code is ready to run without any issues.



# **Instructions**

## **ComponentRequirements**
- You will be given the requirements for a component. Create **complete React code** only for the component and nothing else.
- Ensure the React code works flawlessly using the **latest version of React**.
- **DO NOT** summarize or leave anything out. All functionality must be fully implemented and working together.
- `Component Name: WebSocketManager, Component requirements: ### Final Plan

#### Description
This plan outlines the enhancements to the Startup Overview Page by incorporating new features and components that focus on user engagement, data visualization, interactivity, and overall user experience. The plan integrates seamlessly with the existing functionalities, particularly the WebSocketManager component that handles real-time data updates.

---

#### Existing Component Overview

- **WebSocketManager**
    - **Description**: Handles real-time data updates for the page using a WebSocket connection.
    - **Functionality**: Maintains an active WebSocket connection to ensure immediate reflection of changes made by users.
    - **Details**: 
        - Establishes a persistent connection for updates.
        - Includes error handling for connection drops.
    - **User Interaction**: Invisible to users, ensuring seamless data updates without manual refresh.

---

#### New Features and Components

1. **User Engagement Dashboard**
    - **Main Functionality**: Provides users with insights into their engagement level, such as messages sent and meetings scheduled.
    - **Key Components**: 
        - **Metrics Cards**: Display total messages, meetings, and engagement score.
        - **Graphs**: Use ECharts for visual representation of trends over time.
    - **Data Requirements**: 
        - Dummy data for engagement metrics: `{totalMessages: 120, meetings: 15, engagementTrends: [5, 10, 15, 20]}`.
    - **User Interaction Flow**: Users can hover over graphs to view detailed metrics.
        - **Implementation**: Utilize ECharts’ tooltip feature for detailed views on hover.
    - **Challenges and Solutions**: 
        - **Challenge**: Keeping data accurate and up-to-date.
        - **Solution**: Utilize WebSocketManager to push real-time updates on engagement data.

2. **Interactive Notifications Center**
    - **Main Functionality**: Displays real-time notifications for new messages, meeting invites, and important updates.
    - **Key Components**: 
        - **Notification Bell Icon**: Clickable icon that opens a dropdown list of notifications.
        - **Badge Indicator**: Displays the count of unread notifications.
    - **Data Requirements**: 
        - Dummy notifications data: `{notifications: [{id: 1, message: "New message from mentor", read: false}, ...]}`.
    - **User Interaction Flow**: 
        - Click the bell icon to view notifications; mark as read by clicking on them.
        - **Implementation**: Update notification state in local state management.
    - **Challenges and Solutions**: 
        - **Challenge**: Managing notification state (read/unread).
        - **Solution**: Use local state management to track notifications and refresh when new data arrives.

3. **Dynamic Content Customization**
    - **Main Functionality**: Allows users to customize the displayed content based on preferences (e.g., adding/removing metrics).
    - **Key Components**: 
        - **Customization Modal**: Interface for selecting which metrics to display.
        - **User Preferences Storage**: Use local storage to save user settings.
    - **Data Requirements**: 
        - Dummy data for available metrics: `{availableMetrics: ["Engagement", "Performance", "Investment"]}`.
    - **User Interaction Flow**: 
        - Users select metrics to display via a modal; changes reflect immediately after selection.
    - **Challenges and Solutions**: 
        - **Challenge**: Ensuring a user-friendly experience.
        - **Solution**: Provide a preview of changes before confirming, with clear instructions.

4. **Gamification Elements**
    - **Main Functionality**: Introduces gamification to encourage user engagement through badges and achievements.
    - **Key Components**: 
        - **Badge Display Section**: Shows earned badges.
        - **Progress Bars**: Visual representation of user progress towards goals (e.g., attending meetings, sending messages).
    - **Data Requirements**: 
        - Dummy data for achievements: `{badges: [{id: 1, name: "Top Communicator", earned: true}]}`.
    - **User Interaction Flow**: 
        - Users can click on badges to view progress and criteria for earning them.
    - **Challenges and Solutions**: 
        - **Challenge**: Balancing challenge and accessibility.
        - **Solution**: Set achievable yet challenging goals to maintain user interest.

5. **Collaborative Whiteboard Tool**
    - **Main Functionality**: Provides a virtual whiteboard for real-time collaboration during meetings.
    - **Key Components**: 
        - **Canvas Area**: For drawing and annotations.
        - **Drawing Tools**: Options for shapes, text, and colors.
    - **Data Requirements**: 
        - Dummy data for whiteboard state: `{shapes: [{type: "circle", x: 30, y: 30, color: "blue"}]}`.
    - **User Interaction Flow**: 
        - Users can draw on the canvas and see others' actions in real-time via WebSocketManager.
    - **Challenges and Solutions**: 
        - **Challenge**: Synchronizing drawing actions.
        - **Solution**: Use a centralized state management approach to handle whiteboard updates, ensuring consistency across users.

---

#### Prioritization of Ideas
1. **User Engagement Dashboard** - High Impact, Medium Feasibility
2. **Interactive Notifications Center** - High Impact, High Feasibility
3. **Dynamic Content Customization** - Medium Impact, Medium Feasibility
4. **Gamification Elements** - Medium Impact, Low Feasibility
5. **Collaborative Whiteboard Tool** - High Impact, Low Feasibility

---

### Implementation Guidance

1. **User Engagement Dashboard**
    - Create a component to handle the metrics display.
    - Implement ECharts for graphical representation.
    - Integrate with WebSocketManager for real-time updates.
  
2. **Interactive Notifications Center**
    - Develop a notification component with state management.
    - Use a dropdown component to list notifications.
    - Implement click handlers for marking notifications as read.

3. **Dynamic Content Customization**
    - Create a modal component for users to select metrics.
    - Store preferences in local storage and reflect changes in the dashboard accordingly.

4. **Gamification Elements**
    - Develop a section for displaying badges and progress.
    - Integrate with local storage for tracking user achievements.

5. **Collaborative Whiteboard Tool**
    - Implement a canvas component for collaborative drawing.
    - Use WebSocketManager to sync drawing actions among users.

---

### Edge Cases & Testing
- **User Engagement Dashboard**: Test for scenarios with no engagement data; ensure graceful handling.
- **Interactive Notifications Center**: Ensure notifications reflect accurately after marking as read and upon new arrivals.
- **Dynamic Content Customization**: Test for saving and retrieving user preferences accurately.
- **Gamification Elements**: Validate that progress bars update correctly based on user actions.
- **Collaborative Whiteboard Tool**: Ensure all users see real-time updates; test for connection drops and recovery.

---

### Enhancements
- **Performance Optimization**: Consider lazy loading components that are not immediately visible to improve initial load times.
- **User Experience**: Implement guided tours or tooltips for new users to familiarize them with features.
- **Accessibility**: Ensure that all interactive components are keyboard-navigable and use ARIA roles for screen readers.
- **Mobile Responsiveness**: While focused on desktop, ensure that layout can adapt for future mobile support.

---

This comprehensive plan details the functionality, user interaction flows, and considerations for the Startup Overview Page, ensuring a professional ERP experience that is engaging, interactive, and user-friendly. Each component is designed to work cohesively with existing functionalities, creating a seamless user experience.`

## **FileRequirements**
- Create **1 JS file** with **no styling**.
- Use only **dummy data**. **No backend** or API calls, only dummy data should be used.
- The entire file should be **self-contained**. **DO NOT** import any other JS files or components.

## **Rules**

### **General**
- **No errors or bugs** allowed. The code must work perfectly on the first try.
- Provide **complete, fully functional code** with no missing implementations or placeholder logic.
- **DO NOT** ask the user to implement anything. **DO NOT** leave out any code. Recreate everything within this file, and **DO NOT** import any external JS files or components.
- All necessary code must be included in this file, fully implemented, and functional with **no missing parts**.

### **ResponseFormat**
- Output **only** the requested code or response. **DO NOT** include explanations, comments, or additional information. Respond with the **complete code only**.

### **NoHeader**
- **DO NOT** include a header or any boilerplate explanations. Start **directly** with the code implementation.

## **ComponentRequirements**
- The component must be **fully implemented**, with **all functionality** integrated. **Nothing should be left out** or incomplete. Ensure all pieces work together seamlessly, and the code is ready to run without any issues.


