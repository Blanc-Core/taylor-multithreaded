
# **Instructions**

## **ComponentRequirements**
- You will be given the requirements for a component. Create **complete React code** only for the component and nothing else.
- Ensure the React code works flawlessly using the **latest version of React**.
- **DO NOT** summarize or leave anything out. All functionality must be fully implemented and working together.
- `Component Name: KpiCard, Component requirements: ## Final Plan for KpiCard Component Enhancement

### **Component Description**
The KpiCard component is designed to deliver key performance indicators (KPIs) in an engaging and interactive format, catering specifically to users managing startup metrics. Each card presents essential data like Monthly Recurring Revenue (MRR) or Monthly Active Users (MAUs), enabling immediate insights to drive business decisions.

### **Functionality**
The KpiCard is a reusable and versatile component that showcases specific metrics related to startup performance. Key features include:
- **KPI Title**: Clearly indicates the type of KPI being displayed.
- **KPI Value**: Prominently displayed to capture user attention.
- **Trend Indicator**: Visual representation (e.g., arrow up/down) to show performance changes.
- **Visual Indicators**: Color coding (green, red, yellow) and icons to denote the metric's status.
- **Loading Indicators**: Alerts users during data retrieval processes.
- **Interactive Elements**: Users can click or hover to gain deeper insights into the metrics.

### **Details**
- Each KpiCard displays the KPI title, value, trend indicator, and a brief description.
- Incorporates loading animations for data retrieval.
- Utilizes distinct color coding to signify performance status.
- Customizable card sizes to meet user requirements.

### **User Interaction**
- **Interaction Options**:
  - **Hover**: Displays tooltips for additional context or related KPIs.
  - **Click**: Opens a modal with detailed graphs and historical data.
- **Result of Interaction**:
  - **Hover**: Provides insights without leaving the main dashboard context.
  - **Click**: Allows for comprehensive analysis through engaging visual elements.

### **Interconnectivity**
- The KpiCard will utilize the AlertItem component with the Peer Review page, ensuring a consistent alert notification experience across the application.

### **New Features & Enhancements**
#### 1. **Dynamic Data Visualization**
   - **Functionality**: Integrate ECharts for dynamic graphs and visualizations within the KpiCard.
   - **Key Components**: 
     - Trend graphs illustrating KPI changes over time.
     - Comparison charts to visualize KPIs against historical data.
   - **User Interaction Flow**: Users can switch between various chart types (e.g., bar or line graphs) via tabs.
   - **Challenges and Solutions**: Use smooth animations for transitions to enhance user engagement.

#### 2. **Customization Options**
   - **Functionality**: Enable users to personalize the KpiCard layout and metrics.
   - **Key Components**: 
     - A settings modal for selecting KPIs to display.
     - Themes for color customization to improve readability.
   - **User Interaction Flow**: Access settings through a gear icon on the KpiCard.
   - **Challenges and Solutions**: Store user preferences in local storage for persistence.

#### 3. **Gamification Elements**
   - **Functionality**: Integrate achievement badges based on KPI performance.
   - **Key Components**: 
     - A badge display area on the KpiCard.
     - Notifications for badge achievements.
   - **User Interaction Flow**: Users can view achievements by clicking a badge icon.
   - **Challenges and Solutions**: Clearly define criteria for earning badges to maintain engagement.

#### 4. **Notifications for KPI Changes**
   - **Functionality**: Implement a notification system for significant KPI changes.
   - **Key Components**: 
     - A notification icon on the KpiCard.
     - Popup alerts when KPIs reach critical thresholds.
   - **User Interaction Flow**: Click the notification icon to view recent alerts.
   - **Challenges and Solutions**: Allow users to customize notification frequency to avoid overload.

### **Prioritization of Ideas**
1. **Dynamic Data Visualization** - High impact, feasible with ECharts.
2. **Customization Options** - Medium impact; enhances user experience significantly.
3. **Gamification Elements** - Medium impact; encourages user engagement.
4. **Notifications for KPI Changes** - Low to medium impact; beneficial but less critical.

### **Conclusion**
This comprehensive enhancement plan focuses on elevating the KpiCard component to improve user engagement, data visualization, and interactivity. The implementation of these features will transform the KpiCard from a simple informational tool to a highly interactive and customizable user experience, seamlessly integrating into a professional ERP system.

### **Step-by-Step Plan**
#### **Step 1: Clarification**
- Ensure clarity in the component's purpose and what specific KPIs will be included.

#### **Step 2: Implementation Guidance**
- Define the structure of the KpiCard, including props for title, value, trend indicator, and description.
- Use state management to handle loading indicators and data updates.

#### **Step 3: Efficiency**
- Modularize the KpiCard component to keep its logic isolated and reusable.
- Implement utility functions for color coding based on KPI performance.

#### **Step 4: Technical Specifications**
- Utilize React for component structure, ECharts for data visualization, and CSS for styling.
- Ensure responsiveness for various screen sizes, focusing on desktop optimality.

#### **Step 5: Examples**
- Example of a KpiCard for MRR:
  ```jsx
  <KpiCard 
      title="Monthly Recurring Revenue" 
      value="$10,000" 
      trend="up" 
      description="Increased by 5% from last month" 
  />
  ```

#### **Step 6: Edge Cases**
- Test for scenarios where data retrieval fails (e.g., API errors) and display appropriate error messages.
- Ensure that the component handles empty or null data gracefully.

#### **Step 7: Enhancements**
- Consider adding a feature that allows users to set custom thresholds for KPIs, triggering alerts or notifications when surpassed.
- Implement keyboard navigation for improved accessibility.

This final plan outlines all necessary functionalities and details for the KpiCard component, ensuring a professional and engaging user experience. By executing this plan, the KpiCard will effectively serve its purpose within the broader ERP system.`

## **FileRequirements**
- Create **1 JS file** with **no styling**.
- Use only **dummy data**. **No backend** or API calls, only dummy data should be used.
- The entire file should be **self-contained**. **DO NOT** import any other JS files or components.

## **Rules**

### **General**
- **No errors or bugs** allowed. The code must work perfectly on the first try.
- Provide **complete, fully functional code** with no missing implementations or placeholder logic.
- **DO NOT** ask the user to implement anything. **DO NOT** leave out any code. Recreate everything within this file, and **DO NOT** import any external JS files or components.
- All necessary code must be included in this file, fully implemented, and functional with **no missing parts**.

### **ResponseFormat**
- Output **only** the requested code or response. **DO NOT** include explanations, comments, or additional information. Respond with the **complete code only**.

### **NoHeader**
- **DO NOT** include a header or any boilerplate explanations. Start **directly** with the code implementation.

## **ComponentRequirements**
- The component must be **fully implemented**, with **all functionality** integrated. **Nothing should be left out** or incomplete. Ensure all pieces work together seamlessly, and the code is ready to run without any issues.



# **Instructions**

## **ComponentRequirements**
- You will be given the requirements for a component. Create **complete React code** only for the component and nothing else.
- Ensure the React code works flawlessly using the **latest version of React**.
- **DO NOT** summarize or leave anything out. All functionality must be fully implemented and working together.
- `Component Name: InvestorFilter, Component requirements: **Final Plan for Investor Filter Component Enhancement**

**Component Description**
The InvestorFilter component allows users to filter investor profiles based on their preferences and investment history, enhancing their experience by presenting only the most relevant profiles. 

**Functionality**
The InvestorFilter allows users to narrow down the list of investors by applying various filters such as industry preferences, geographical location, investment amount, and engagement activity. The component includes:
- A dynamic multi-select dropdown for industry preferences, fetching options from available investor data.
- Range sliders for investment amounts to specify min and max investment amounts.
- Checkboxes for engagement activities to filter based on levels of interaction.
- A reset button to clear all selections, returning to the default state of displaying all investors.
- A user-friendly interface that updates the InvestorProfilesContainer with filtered results in real-time.

**Details**
**Key Features**
- Multi-select dropdowns for industry preferences.
- Range sliders for investment amount.
- Checkboxes for engagement activity.
- Reset button to clear filters.
- Real-time filtering that updates displayed investor profiles.

**User Interaction**
Users can interact with filter options such as dropdowns, sliders, and checkboxes. They can select an industry, adjust the investment range, and check engagement activities. Upon selecting filter criteria, the component updates the state in the InvestorProfilesContainer, triggering a re-render of the InvestorProfileCard components to display only those profiles matching the selected criteria.

**Interconnectivity**
The filtering data may be sent to an analytics component to generate reports on investor engagement trends, providing insights on which investor profiles are most sought after based on user preferences.

---

### Step-by-Step Plan

**1. Clarification**
   - Ensure filter categories (industry, location, investment amount, engagement) are clearly defined and directly linked to investor profiles.
   - Confirm that the dropdown for industries pulls from a well-maintained data source to prevent stale data.

**2. Implementation Guidance**
   - **Multi-Select Dropdown for Industry Preferences**: 
     - Use a library like `react-select` to implement the dropdown.
     - Fetch industry options from the investor data and store them in component state.
     - On selection, update the filtering criteria state.

   - **Range Sliders for Investment Amount**:
     - Implement using a library such as `rc-slider`.
     - Initialize with min and max values based on the available investor data.
     - On value change, update the filtering criteria state.

   - **Checkboxes for Engagement Activity**:
     - Create checkboxes for different engagement levels.
     - On change, update the filtering criteria state accordingly.

   - **Reset Button**:
     - Implement a button that resets all filter states to default values.
     - Ensure it triggers an update to the InvestorProfilesContainer to show all profiles.

   - **Real-Time Filtering**:
     - Use `useEffect` to listen for changes in filter states and trigger updates to the InvestorProfilesContainer.

**3. Efficiency**
   - Structure the component to separate concerns: have individual components for the dropdown, sliders, checkboxes, and reset button.
   - Implement memoization techniques (e.g., `React.memo`) to prevent unnecessary re-renders.

**4. Technical Specifications**
   - Use React for component architecture.
   - Use state management via React hooks (e.g., `useState`, `useEffect`).
   - Libraries: `react-select` for dropdowns, `rc-slider` for sliders.
   - Ensure all components are responsive and compatible with desktop views.

**5. Examples**
   - **Scenario**: User selects "Technology" from the industry dropdown and sets the investment range to $10,000 - $50,000. Profiles displayed should only include those matching these criteria.
   - **Reset Action**: Clicking the reset button should restore the view to show all investor profiles, regardless of any previously applied filters.

**6. Edge Cases**
   - Ensure proper handling when no filters are applied: all profiles should be displayed.
   - Handle cases where no profiles match the selected criteria; display a user-friendly message indicating no matches found.
   - Test for responsiveness, ensuring dropdowns and sliders are usable at various screen resolutions.

**7. Enhancements**
   - **Data Visualization Panel**: 
     - Integrate ECharts to display insights about selected filters in real-time, such as investment frequency by industry.
     - Ensure charts reflect changes in filters immediately.

   - **Customizable Dashboard**:
     - Add functionality for users to save their filter settings, possibly using local storage to persist customizations.
     - Provide a UI for users to manage saved preferences.

   - **Gamification Elements**:
     - Implement a points system to reward users based on their engagement with the filters.
     - Create a leaderboard or achievement badges to encourage interaction.

   - **Notification System**:
     - Implement a notification panel to alert users of new investors matching their preferences.
     - Provide controls for users to manage notification frequency (e.g., daily, weekly).

**Prioritization**
- **High Priority**: Data Visualization Panel for user engagement and understanding.
- **Medium Priority**: Customizable Dashboard for user personalization.
- **Medium Priority**: Gamification Elements to encourage continued platform engagement.
- **Low Priority**: Notification System for enhancing user retention.

This comprehensive plan enhances the InvestorFilter component through interactivity, data visualization, customization, and gamification, ensuring practical implementation within a desktop application. Each component is designed with clarity and usability in mind, making the overall user experience seamless and engaging.`

## **FileRequirements**
- Create **1 JS file** with **no styling**.
- Use only **dummy data**. **No backend** or API calls, only dummy data should be used.
- The entire file should be **self-contained**. **DO NOT** import any other JS files or components.

## **Rules**

### **General**
- **No errors or bugs** allowed. The code must work perfectly on the first try.
- Provide **complete, fully functional code** with no missing implementations or placeholder logic.
- **DO NOT** ask the user to implement anything. **DO NOT** leave out any code. Recreate everything within this file, and **DO NOT** import any external JS files or components.
- All necessary code must be included in this file, fully implemented, and functional with **no missing parts**.

### **ResponseFormat**
- Output **only** the requested code or response. **DO NOT** include explanations, comments, or additional information. Respond with the **complete code only**.

### **NoHeader**
- **DO NOT** include a header or any boilerplate explanations. Start **directly** with the code implementation.

## **ComponentRequirements**
- The component must be **fully implemented**, with **all functionality** integrated. **Nothing should be left out** or incomplete. Ensure all pieces work together seamlessly, and the code is ready to run without any issues.



# **Instructions**

## **ComponentRequirements**
- You will be given the requirements for a component. Create **complete React code** only for the component and nothing else.
- Ensure the React code works flawlessly using the **latest version of React**.
- **DO NOT** summarize or leave anything out. All functionality must be fully implemented and working together.
- `Component Name: StartupCard, Component requirements: ### FinalPlan

#### Description
This plan provides a detailed framework for enhancing the StartupCard component in a professional ERP application. It emphasizes user engagement, interactivity, and data visualization while ensuring the implementation is feasible within a single-page React application.

#### Content
- **Component Description**: Represents individual startup summaries with key information and action buttons.
- **Functionality**: The StartupCard component encapsulates a brief overview of each startup, presenting key information such as the startup's name, industry, cohort, and action buttons for viewing more details or accessing additional features. This component is clickable and designed to facilitate quick navigation to the startup's detailed profile. It incorporates responsive design elements to ensure clarity and accessibility, providing visual feedback on hover or click. The StartupCard is reusable across different pages where startup information is required.
- **Details**:
  - Displays the startup's name, industry, cohort, and buttons for details and additional features.
  - Responsive design with hover effects for better user engagement.
  - Action buttons for quick navigation to detailed startup profiles.
  - Incorporates a rating system for user feedback on startups.
  - Includes a “Follow” button for users to track startups of interest.

- **Visibility**: True
- **Interconnectivity**:
  - Page URL: `/startups/profiles/details` - Navigates to the detailed profile of the startup when clicked.
  - Page URL: `/startups/profiles/followed` - Navigates to a user’s followed startups list.

- **User Interaction**:
  - **Interact**: Action buttons on StartupCard.
  - **Possible Interactions**: User clicks the 'View Details', 'Rate', or 'Follow' button on the StartupCard.
  - **Result**: Navigates to a detailed view of the startup profile or updates the user's followed startups list.
  - **Result Functionality**: The action buttons initiate navigation commands or update user preferences, such as rating a startup or following it for future updates.

#### Improvements
- **User Engagement Features**
  - **Rating System**: Add a 5-star rating system allowing users to rate startups directly from the StartupCard. This feature could use dummy data where ratings are pre-defined, showing average ratings dynamically.
  - **Follow Button**: Introduce a follow feature enabling users to track their favorite startups. A visual indication (like a heart icon) changes upon clicking to signify the startup is followed.

- **Data Visualization Elements**
  - **Mini Graphs**: Integrate small bar or line charts using ECharts to visually represent metrics such as funding rounds, user engagement, or growth in metrics over time.

- **Interactivity Enhancements**
  - **Hover Effects**: Enhance hover effects on the StartupCard to show a quick view of key metrics or a tooltip with additional information about the startup.
  - **Dynamic Content**: Use dynamic content loading for the StartupCard that updates based on user interactions, such as showing followed startups or recently viewed startups.

- **Productivity Tools**
  - **Bookmarking**: Allow users to bookmark or save their favorite startups for quick access later. This can be implemented as a simple star icon on the StartupCard.
  - **Search Functionality**: Implement a search bar that filters displayed StartupCards based on user input (e.g., startup name, industry).

- **Customization Options**
  - **Display Preferences**: Let users customize their view (e.g., grid vs. list) and the information displayed on the StartupCard. This could be handled through a simple settings panel where users can toggle options.

- **Gamification**
  - **Achievements**: Introduce a badge system where users can earn badges for certain actions (e.g., following a certain number of startups, rating startups). This could be displayed on the user profile.

- **Notifications**
  - **Update Alerts**: Implement a notification system that alerts users of updates or changes to startups they are following. These notifications could be represented as small badges or icons on the StartupCard itself.

#### PlanningOutline
- **Rating System**
  - **Main Functionality**: Users can rate startups and view average ratings.
  - **Key Components**: Rating stars component, integration with the StartupCard.
  - **Data Requirements**: Dummy data for average ratings and individual ratings.
  - **User Interaction Flow**: User clicks on a star to rate; the average updates dynamically.
  - **Challenges & Solutions**: Storing ratings locally or using a dummy state management solution.

- **Follow Button**
  - **Main Functionality**: Users can follow startups for updates.
  - **Key Components**: Follow button, followed startups list.
  - **Data Requirements**: Dummy data for the list of followed startups.
  - **User Interaction Flow**: User clicks 'Follow'; updates their followed startups list.
  - **Challenges & Solutions**: Keeping track of the followed startups using local state.

- **Mini Graphs**
  - **Main Functionality**: Visual representation of startup metrics.
  - **Key Components**: ECharts integration for mini charts.
  - **Data Requirements**: Dummy data for various metrics.
  - **User Interaction Flow**: All metrics are displayed dynamically as part of the StartupCard.
  - **Challenges & Solutions**: Ensuring charts are responsive and load efficiently.

- **Search Functionality**
  - **Main Functionality**: Filter displayed startups.
  - **Key Components**: Search input component, filtering logic in StartupCard.
  - **Data Requirements**: Dummy data for startup names and industries.
  - **User Interaction Flow**: User types in search; StartupCards filter in real-time.
  - **Challenges & Solutions**: Ensuring performance with large datasets.

#### Prioritization
- **High Impact & Feasibility**: Rating System, Follow Button, Search Functionality.
- **Moderate Impact & Feasibility**: Mini Graphs, Dynamic Content, Hover Effects.
- **Lower Impact & Feasibility**: Gamification, Customization Options, Notifications.

### StepByStepPlan
#### Description
This step-by-step plan outlines actionable tasks to implement the proposed features for the StartupCard component.

#### Steps
1. **Rating System Implementation**
   - Create a `RatingStars` component that accepts a rating prop and displays corresponding stars.
   - Add functionality to update ratings upon user click, modifying the local state to reflect the new rating.
   - Display average ratings using pre-defined dummy data.

2. **Follow Button Implementation**
   - Add a `FollowButton` component that toggles between "Follow" and "Following" states.
   - Integrate state management for followed startups, updating the list upon user clicks.
   - Ensure visual feedback (e.g., heart icon change) when a user follows or unfollows a startup.

3. **Mini Graphs Integration**
   - Use ECharts to create a `MiniChart` component, accepting data props for metrics.
   - Render the mini graphs within the StartupCard, dynamically displaying data based on dummy data sources.

4. **Hover Effects Enhancement**
   - Implement CSS hover effects that reveal quick views or tooltips with additional startup information.
   - Ensure that the hover effects are intuitive and improve user engagement.

5. **Dynamic Content Loading**
   - Utilize React hooks to manage state and effects for dynamic content updates.
   - Create a mechanism to fetch and display followed startups or recently viewed startups when the user interacts with the StartupCard.

6. **Search Functionality Development**
   - Create a search input component that captures user input for filtering.
   - Implement a filtering algorithm that updates displayed StartupCards based on the user’s search criteria (e.g., name, industry).

7. **Bookmarking Feature**
   - Add a bookmark icon to the StartupCard that allows users to save startups.
   - Create a `BookmarkList` component to display all bookmarked startups.

8. **Customization Options**
   - Develop a settings panel for users to customize their view preferences.
   - Implement state management to toggle between grid and list views.

9. **Gamification and Achievements**
   - Define a badge system and create a `Badges` component to display earned badges.
   - Integrate event listeners to track user actions and award badges accordingly.

10. **Notification System**
    - Create a notification component that listens for updates on followed startups.
    - Implement logic to display notifications when changes occur, represented visually on the StartupCard.

### Enhancements
- Optimize data fetching for mini graphs to ensure responsiveness.
- Implement lazy loading for StartupCards if there are many startups to enhance performance.
- Consider accessibility features for all components (e.g., ARIA roles).

### Edge Cases
- **Rating System**: Handle cases where users try to rate a startup multiple times quickly; debounce the rating update function.
- **Follow Button**: Ensure that clicking the Follow button multiple times doesn’t result in inconsistent states.
- **Search Functionality**: Prevent errors when the search input is empty or contains invalid characters.

This comprehensive plan outlines all necessary features, functionalities, and improvements for the StartupCard component in a professional ERP application, ensuring a robust and engaging user experience.`

## **FileRequirements**
- Create **1 JS file** with **no styling**.
- Use only **dummy data**. **No backend** or API calls, only dummy data should be used.
- The entire file should be **self-contained**. **DO NOT** import any other JS files or components.

## **Rules**

### **General**
- **No errors or bugs** allowed. The code must work perfectly on the first try.
- Provide **complete, fully functional code** with no missing implementations or placeholder logic.
- **DO NOT** ask the user to implement anything. **DO NOT** leave out any code. Recreate everything within this file, and **DO NOT** import any external JS files or components.
- All necessary code must be included in this file, fully implemented, and functional with **no missing parts**.

### **ResponseFormat**
- Output **only** the requested code or response. **DO NOT** include explanations, comments, or additional information. Respond with the **complete code only**.

### **NoHeader**
- **DO NOT** include a header or any boilerplate explanations. Start **directly** with the code implementation.

## **ComponentRequirements**
- The component must be **fully implemented**, with **all functionality** integrated. **Nothing should be left out** or incomplete. Ensure all pieces work together seamlessly, and the code is ready to run without any issues.



# **Instructions**

## **ComponentRequirements**
- You will be given the requirements for a component. Create **complete React code** only for the component and nothing else.
- Ensure the React code works flawlessly using the **latest version of React**.
- **DO NOT** summarize or leave anything out. All functionality must be fully implemented and working together.
- `Component Name: Tooltip, Component requirements: ### Comprehensive Plan for Enhancing the MentorCard Component

#### Component Description
The MentorCard component will be enhanced with interactive features that improve user engagement and provide richer information. A Tooltip component will display additional mentor details upon hovering, while new features will include data visualization, user customization, and interactive elements that promote productivity. 

### Functionality Enhancements

1. **Tooltip Component:**
   - **Description**: Provides quick access to supplementary information about mentors.
   - **Details**:
     - Activated on hover over a MentorCard.
     - Shows information such as the number of startups mentored, last feedback date, and a brief bio.
     - Smooth fade-in and fade-out animations for improved user experience.
   - **User Interaction**: The tooltip appears, aiding quick decision-making.

2. **Mentor Performance Dashboard:**
   - **Description**: Visual representation of mentor performance metrics.
   - **Key Features**:
     - Pie chart showing the distribution of startups mentored by category (e.g., tech, health).
     - Bar graph representing the number of feedback entries received over time.
   - **User Interaction**: Users can hover over charts to get specific data points.

3. **Customizable Mentor Filters:**
   - **Description**: Users can filter mentors based on various criteria.
   - **Key Features**:
     - Dropdown menus for filtering by expertise, number of startups mentored, or feedback rating.
     - Apply and reset buttons for user convenience.
   - **User Interaction**: Users select filters to dynamically update the displayed MentorCards.

4. **Gamification Elements:**
   - **Description**: Introduce a points/reward system for users engaging with mentors.
   - **Key Features**:
     - Points for actions taken (e.g., sending messages, booking sessions).
     - Leaderboard displaying top users based on points.
   - **User Interaction**: Users can view their points and compare them with others.

5. **Dynamic Notifications:**
   - **Description**: Real-time notifications for mentor-related activities.
   - **Key Features**:
     - Pop-up alerts for new feedback received or mentor availability.
     - Notification bell icon showing the number of unread notifications.
   - **User Interaction**: Users click the bell icon to view a drop-down list of notifications.

---

### Step-by-Step Implementation Plan

#### 1. Tooltip Component
- **Clarification**: The Tooltip component should provide essential mentor information without needing to navigate away from the MentorCard.
- **Implementation Guidance**:
  - Use a `div` element styled to appear as a tooltip that contains mentor details.
  - Trigger the tooltip display on hover using CSS and JavaScript event listeners.
- **Efficiency**: Ensure the tooltip is positioned correctly using CSS properties like `position`, `top`, and `left`.
- **Technical Specifications**: Use CSS transitions for smooth animations and z-index for proper layering.
- **Examples**: On hovering over a MentorCard, a tooltip appears showing “Mentored 10 Startups, Last Feedback: 01/12/2023”.
- **Edge Cases**: Test for hover events on rapidly moving the cursor in and out to ensure the tooltip behaves as expected.
- **Enhancements**: Consider adding a delay to the tooltip appearance to avoid flickering.

#### 2. Mentor Performance Dashboard
- **Clarification**: This dashboard should visualize mentor performance metrics through interactive charts.
- **Implementation Guidance**:
  - Use a charting library like Chart.js or ECharts to create dynamic visualizations.
  - Fetch and process data needed for the charts on component mount.
- **Efficiency**: Optimize data fetching to limit the load on the component.
- **Technical Specifications**: Utilize hooks for managing chart state and lifecycle.
- **Examples**: Display a pie chart with sections for “Tech”, “Health”, and “Finance” startups mentored.
- **Edge Cases**: Verify chart rendering with no data or incomplete data sets.
- **Enhancements**: Allow users to export the chart data as CSV for external analysis.

#### 3. Customizable Mentor Filters
- **Clarification**: Users should have the ability to filter mentors based on specific criteria.
- **Implementation Guidance**:
  - Create dropdown components for each filter category (expertise, startups mentored, feedback rating).
  - Implement a state management solution to handle filter selections and apply them to the displayed MentorCards.
- **Efficiency**: Ensure filtering is efficient and does not reload the entire component.
- **Technical Specifications**: Use controlled components for dropdowns to keep track of user selections.
- **Examples**: Users can select “Tech” from the expertise dropdown to filter MentorCards.
- **Edge Cases**: Handle cases where no mentors match the selected filters gracefully.
- **Enhancements**: Add a “clear all filters” option for user convenience.

#### 4. Gamification Elements
- **Clarification**: Introduce a points/reward system to encourage user interaction with mentors.
- **Implementation Guidance**:
  - Create a points system that tracks user actions and updates points accordingly.
  - Build a leaderboard component that displays user rankings based on points.
- **Efficiency**: Keep the points calculation lightweight to prevent performance lag.
- **Technical Specifications**: Use a state management library to maintain user points and leaderboard data.
- **Examples**: User receives 10 points for booking a mentor session, and their rank updates on the leaderboard.
- **Edge Cases**: Ensure points are not duplicated for the same action.
- **Enhancements**: Implement notifications for users when they earn points or achieve new ranks.

#### 5. Dynamic Notifications
- **Clarification**: Real-time notifications should inform users of mentor-related updates.
- **Implementation Guidance**:
  - Implement a notification system that listens for events (e.g., new feedback).
  - Utilize a bell icon to display the count of unread notifications.
- **Efficiency**: Optimize for quick updates without overwhelming the user with pop-ups.
- **Technical Specifications**: Use WebSocket or polling to fetch notifications in real-time.
- **Examples**: A notification appears stating, “You have new feedback from Mentor XYZ”.
- **Edge Cases**: Test scenarios where notifications arrive while the user is interacting with the dashboard.
- **Enhancements**: Allow users to customize notification preferences (e.g., types of alerts).

---

### Prioritization of Ideas
1. **Tooltip Component** - High impact, easy to implement.
2. **Customizable Mentor Filters** - High impact, moderate complexity.
3. **Mentor Performance Dashboard** - Moderate impact, moderate complexity.
4. **Dynamic Notifications** - Moderate impact, moderate complexity.
5. **Gamification Elements** - Low to moderate impact, higher complexity.

### Conclusion
This comprehensive plan outlines enhancements to the MentorCard component, focusing on enriching user interaction, providing valuable information, and improving the overall user experience. By implementing these ideas, the application will be more engaging, informative, and user-friendly, aligning with the goals of an effective ERP system. Each component is designed to work together seamlessly, providing a cohesive experience for users on desktop platforms.`

## **FileRequirements**
- Create **1 JS file** with **no styling**.
- Use only **dummy data**. **No backend** or API calls, only dummy data should be used.
- The entire file should be **self-contained**. **DO NOT** import any other JS files or components.

## **Rules**

### **General**
- **No errors or bugs** allowed. The code must work perfectly on the first try.
- Provide **complete, fully functional code** with no missing implementations or placeholder logic.
- **DO NOT** ask the user to implement anything. **DO NOT** leave out any code. Recreate everything within this file, and **DO NOT** import any external JS files or components.
- All necessary code must be included in this file, fully implemented, and functional with **no missing parts**.

### **ResponseFormat**
- Output **only** the requested code or response. **DO NOT** include explanations, comments, or additional information. Respond with the **complete code only**.

### **NoHeader**
- **DO NOT** include a header or any boilerplate explanations. Start **directly** with the code implementation.

## **ComponentRequirements**
- The component must be **fully implemented**, with **all functionality** integrated. **Nothing should be left out** or incomplete. Ensure all pieces work together seamlessly, and the code is ready to run without any issues.



# **Instructions**

## **ComponentRequirements**
- You will be given the requirements for a component. Create **complete React code** only for the component and nothing else.
- Ensure the React code works flawlessly using the **latest version of React**.
- **DO NOT** summarize or leave anything out. All functionality must be fully implemented and working together.
- `Component Name: InvestorProfileCard, Component requirements: ### Final Plan

---

**Component Overview**
- **Description**
    - The `InvestorProfileCard` component is designed to display individual investor information, including name, preferences, and engagement summary. It serves as a core element in a professional ERP application, facilitating user engagement and data interaction.

---

**Content**

- **Functionality**
    - The `InvestorProfileCard` will dynamically render information for each investor based on data received from the `InvestorProfilesContainer`. The key information displayed includes:
        - **Investor Name and Photo**: A visual representation of the investor.
        - **Top 3 Investment Preferences**: Highlighting key areas of interest to the investor.
        - **Summary of Recent Engagements**: A brief overview of the investor’s past interactions or activities.
        - **Button to View Detailed Profile**: A call-to-action that opens the `InvestorDetailModal`.

- **Visibility**
    - `isVisible`: True (The component is visible by default as part of the main investor overview page).

- **Interconnectivity**
    - **Page URL**: `/investor-details`
        - **Description**: Clicking on an `InvestorProfileCard` opens the `InvestorDetailModal`, presenting comprehensive details about the chosen investor.

- **User Interaction**
    - **Interaction**: Users can click on an `InvestorProfileCard`.
    - **Possible Interactions**:
        - Click to view detailed profile.
        - Click to bookmark the investor as a favorite.
        - Hover to see performance metrics on a chart.
    - **Result**: 
        - Opens the `InvestorDetailModal` component.
        - Updates favorites list if the user interacts with the favorites feature.
        - Displays performance data chart on hover.

---

### Enhanced Features and Ideas

1. **User Engagement Tools**
    - **Favorites Feature**:
        - **Functionality**: Users can add/remove investors from a favorites list by clicking a heart icon.
        - **Components**: `FavoriteButton`, `FavoritesList`.
        - **Data Requirements**: Track favorites with a structure like `favoriteInvestors: []`.
        - **Interaction Flow**: Clicking the heart updates the state and reflects changes immediately.
        - **Challenges**: Ensure smooth UI updates; use local state management for real-time feedback.

2. **Data Visualization**
    - **Performance Chart**:
        - **Functionality**: Display a line chart showing investment performance over time.
        - **Components**: `PerformanceChart`.
        - **Data Requirements**: Structure data as `performanceData: [{date: '2023-01-01', value: 100}, ...]`.
        - **Interaction Flow**: Hovering over the chart reveals data points.
        - **Challenges**: Use responsive design principles for charts; integrate ECharts with responsive settings.

3. **Interactive Analytics Dashboard**
    - **Overview Dashboard**:
        - **Functionality**: Show a summary card with average performance metrics of favorite investors.
        - **Components**: `Dashboard`, `SummaryCard`.
        - **Data Requirements**: Aggregate data from the favorites list.
        - **Interaction Flow**: Clicking on the dashboard leads to detailed analytics.
        - **Challenges**: Optimize performance for larger datasets; initially limit data shown.

4. **Customization Options**
    - **Card Layout Customization**:
        - **Functionality**: Users can select which details to show/hide on their cards.
        - **Components**: `CustomizationModal`.
        - **Data Requirements**: Store user preferences in a structure like `cardSettings: {showPreferences: true, showEngagements: false}`.
        - **Interaction Flow**: A settings icon opens a modal for user preferences.
        - **Challenges**: Ensure settings persist across sessions; use local storage for saving preferences.

5. **Notifications System**
    - **Notifications Panel**:
        - **Functionality**: Notify users of important updates or new investor interests.
        - **Components**: `NotificationPanel`.
        - **Data Requirements**: Structure notifications as `notifications: [{message: 'Investor X has shown interest in Y.', timestamp: '2023-10-01'}, ...]`.
        - **Interaction Flow**: Click on notifications for more details.
        - **Challenges**: Maintain relevance of notifications; filter based on user interests.

---

### Prioritization of Ideas

1. **Favorites Feature** - High Impact, High Feasibility
2. **Data Visualization (Performance Chart)** - High Impact, Medium Feasibility
3. **Interactive Analytics Dashboard** - Medium Impact, Medium Feasibility
4. **Customization Options** - Medium Impact, High Feasibility
5. **Notifications System** - Low Impact, Medium Feasibility

---

### Step-by-Step Plan

1. **Clarification**
    - Ensure all component details are well-defined, including required props and state structures.

2. **Implementation Guidance**
    - Set up the `InvestorProfileCard` component using functional components and hooks (e.g., `useState` for managing favorites).
    - Create sub-components for favorites, performance charts, and notifications.

3. **Efficiency**
    - Use `React.memo` to optimize rendering of cards that do not change when the state updates.
    - Implement lazy loading for performance charts to improve initial load times.

4. **Technical Specifications**
    - Utilize React for component structure.
    - Integrate ECharts for data visualization.
    - Use local storage for persisting user preferences.

5. **Examples**
    - Provide sample data structures for investors, preferences, and notifications for testing.

6. **Edge Cases**
    - Handle scenarios where no investors are available or when all investors are favorited.
    - Ensure proper error handling in the notification system (e.g., no new notifications).

7. **Enhancements**
    - Consider adding animations for card interactions to enhance user experience.
    - Implement a search/filter functionality for investors to quickly locate specific profiles.

---

### Conclusion
This comprehensive plan outlines the development of the `InvestorProfileCard` component within a professional ERP application. By focusing on user engagement, data visualization, and customization options, the component will enhance user interaction and provide valuable insights, fostering a productive and informative environment for users.`

## **FileRequirements**
- Create **1 JS file** with **no styling**.
- Use only **dummy data**. **No backend** or API calls, only dummy data should be used.
- The entire file should be **self-contained**. **DO NOT** import any other JS files or components.

## **Rules**

### **General**
- **No errors or bugs** allowed. The code must work perfectly on the first try.
- Provide **complete, fully functional code** with no missing implementations or placeholder logic.
- **DO NOT** ask the user to implement anything. **DO NOT** leave out any code. Recreate everything within this file, and **DO NOT** import any external JS files or components.
- All necessary code must be included in this file, fully implemented, and functional with **no missing parts**.

### **ResponseFormat**
- Output **only** the requested code or response. **DO NOT** include explanations, comments, or additional information. Respond with the **complete code only**.

### **NoHeader**
- **DO NOT** include a header or any boilerplate explanations. Start **directly** with the code implementation.

## **ComponentRequirements**
- The component must be **fully implemented**, with **all functionality** integrated. **Nothing should be left out** or incomplete. Ensure all pieces work together seamlessly, and the code is ready to run without any issues.


