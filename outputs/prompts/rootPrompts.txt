
<ReactComponentCoder>
  <FilePath>
    ****File Path: FileName****
    <!-- Ensure this is placed at the top of your file with a valid file name. -->
  </FilePath>

  <GeneralInstructions>
    - Recoding **every single component**, ensuring full functionality, and **fixing any errors or logic issues**.
    - **DO NOT** import any external JS files‚Äîrecreate everything within the provided code.
    - Use only **dummy data** with no backend or API calls. Ensure the code works **flawlessly** for the current page setup.
    - **No logic errors** allowed: All components, mappings, charts, and interactions must function without issues. If errors exist in the provided code, **proactively identify and fix them**.
    - **Every component, feature, and interaction must be fully implemented and improved where necessary**. The page should be fully functional, visually complete, and **professionally enhanced**.
  </GeneralInstructions>

  <CodeRecreation>
    - Provide **full code** for every component and **fix any potential issues**.
    - **NO code should be missing, left out, simplified, or assumed**‚Äîevery piece of logic must be present and correct.
    - Recreate all components fully, **ensuring every part works together seamlessly**. **Fix any layout issues**, optimize UI, and implement **complete functionality** for all components.
  </CodeRecreation>

  <InteractionInstructions>
    - Ensure **ALL components** (e.g., search bars, filters, buttons, forms, charts) work **perfectly** together.
    - Validate that every interaction works as expected‚Äîsearching, filtering, clicking, chart updates, etc.
    - **NO part of the UI should be broken, unresponsive, or incorrectly implemented**‚Äîeverything must be functional.
    - The UI should be **visually optimized** with enhanced layouts and interactions that feel smooth, modern, and professional.
    - **Fix any layout or visual issues**. Ensure the page is **visually complete, fully functional**, and works together as a unified system without any bugs.
  </InteractionInstructions>

  <ValidationSteps>
    - After implementing **each component**, validate that it works as expected and fixes any issues.
    - Check all interactions (search, filter, click, chart rendering, form input) and **verify that everything is fully functional**.
    - **Verify the entire page** for responsiveness and errors‚Äîensure every part of the page is filled with working components.
    - **Proactively improve** areas of the UI that may be weak, unoptimized, or not user-friendly.
  </ValidationSteps>

  <GuidanceForLLM>
    - **Step-by-Step Approach**: Break down tasks to handle complex UI elements (like charts, filters, dynamic data mappings) to ensure everything works perfectly.
    - **Fix errors as you go**: Proactively identify and fix any logic, interaction, or rendering issues. **Do not leave anything broken**.
    - **Enhance Layout**: If the layout feels cluttered, unbalanced, or outdated, **improve it** to be modern, clean, and user-friendly. **No placeholders or incomplete elements**.
    - **No Summarization**: Recode every single line with improvements and do not leave out any logic or interaction. **Enhance the code where needed** and ensure everything is dynamically functional.
  </GuidanceForLLM>

  #### Plan
  - Use this plan to create code for the current page, enhancing functionality, layout, and interactions.
    ```plaintext
    Component Name: Mentor Overview Page, Component requirements: ### Final Plan for Mentor Overview Page

#### Purpose and Goals
The Mentor Overview Page offers a comprehensive view of each mentor's profile, including their expertise, availability, and the startups they are mentoring. It serves as a dashboard for mentors to see their assigned startups and for startups to find relevant mentors. The aim is to streamline the mentorship process for both mentors and startups.

#### Problem Solved
Centralizing mentor information simplifies access to profiles, expertise, and availability. This facilitates startups in identifying suitable mentors and scheduling interactions effectively. The page enhances the mentorship experience by allowing mentors to manage their schedules seamlessly while providing startups a way to connect with the right expertise.

#### Color Scheme
- Primary Color: `#004d40`
- Secondary Color: `#00796b`
- Tertiary Color: `#e0f2f1`
- Spacing: `8px`
- Typography: `'Roboto', sans-serif`

### New Features and Enhancements

#### 1. Mentor Availability Calendar
- **Main Functionality**: Display a visual calendar showing mentor availability.
- **Key Components**:
  - Interactive calendar view (using Ant Design's Calendar component).
  - Clickable time slots for booking sessions.
- **Data Requirements**: Dummy data for mentor availability (e.g., `[{ mentorId: 1, date: '2023-10-01', slots: ['10:00', '11:00', '14:00'] }]`).
- **User Interaction Flow**: Users click on a date, view available slots, and confirm a booking.
- **Challenges/Solutions**: Include a time zone selector linked to user profiles to mitigate time zone confusion.
- **Implementation Guidance**: Utilize Ant Design's Calendar component to create an interactive view. Implement onClick events for time slots that trigger a booking modal.

#### 2. Mentor Rating System
- **Main Functionality**: Allow startups to rate mentors post-interaction.
- **Key Components**: 
  - Star rating UI (using Ant Design's Rate component).
  - A feedback form for detailed comments.
- **Data Requirements**: Dummy data for ratings (e.g., `[{ mentorId: 1, ratings: [5, 4, 3], comments: ['Great mentor!', 'Helpful advice.'] }]`).
- **User Interaction Flow**: Startups submit ratings after each session, which updates in real-time.
- **Challenges/Solutions**: Implement reminder notifications post-session to encourage users to rate.
- **Implementation Guidance**: Create a modal with the Rate component and a text area for comments. Use state management to update ratings and comments dynamically.

#### 3. Dynamic Mentor Recommendations
- **Main Functionality**: Suggest mentors based on the startup‚Äôs needs and previous interactions.
- **Key Components**: 
  - Recommendation engine using dummy data.
  - Display recommended mentors in a separate section with profiles.
- **Data Requirements**: Dummy data for recommendations (e.g., `[{ startupId: 1, recommendedMentors: [1, 3, 5] }]`).
- **User Interaction Flow**: Users see a list of recommended mentors tailored to their profiles.
- **Challenges/Solutions**: Implement a scoring system based on expertise and past interactions to ensure relevance.
- **Implementation Guidance**: Create a function that analyzes user needs and past interactions to generate recommendations. Display these recommendations in a card format with mentor profiles.

#### 4. Interactive Data Visualization
- **Main Functionality**: Visualize mentor expertise and startup growth through charts.
- **Key Components**: 
  - ECharts integration to create bar and pie charts.
  - Display metrics like mentoring sessions held, success rates, and expertise areas.
- **Data Requirements**: Dummy data for visualizations (e.g., `[{ mentorId: 1, sessionsHeld: 30, successRate: 85 }]`).
- **User Interaction Flow**: Users select different metrics to visualize; charts update dynamically.
- **Challenges/Solutions**: Limit visualizations to key metrics with clear legends to prevent data overload.
- **Implementation Guidance**: Use ECharts to render various charts based on user-selected metrics. Implement state management to handle dynamic updates.

#### 5. Customizable Mentor Profiles
- **Main Functionality**: Allow mentors to customize their profiles with skills and availability.
- **Key Components**: 
  - Editable fields for skills and availability (using Ant Design's Form component).
  - Save and cancel buttons for updates.
- **Data Requirements**: Dummy data structure for mentor profiles (e.g., `[{ mentorId: 1, skills: ['AI', 'Business Strategy'], availability: ['Monday', 'Wednesday'] }]`).
- **User Interaction Flow**: Mentors click "Edit Profile", make changes, and save.
- **Challenges/Solutions**: Implement validation of inputs with clear error messages for invalid data.
- **Implementation Guidance**: Create a form with input fields for skills and availability. Use form validation to ensure data integrity.

#### 6. Notifications and Reminders
- **Main Functionality**: Notify mentors of new bookings and remind startups of upcoming sessions.
- **Key Components**: 
  - Notification bell icon to view alerts.
  - Pop-up modal for session reminders.
- **Data Requirements**: Dummy notification data (e.g., `[{ userId: 1, message: 'Session with Mentor X at 10 AM tomorrow.' }]`).
- **User Interaction Flow**: Users click the notification icon to see alerts; they can mark notifications as read.
- **Challenges/Solutions**: Implement a badge for unread notifications to ensure users don‚Äôt overlook them.
- **Implementation Guidance**: Create a notification component that fetches and displays alerts dynamically. Implement a function to mark notifications as read.

### Additional Enhancements
- **Search Functionality**: Add a search bar that allows startups to filter mentors by expertise, availability, or ratings. This would enhance the user experience by making it easier to find appropriate mentors.
- **User Profiles**: Allow startups to create profiles that include their needs, interests, and past mentorship experiences. This data can be utilized to improve recommendations.
- **Session Feedback Loop**: After each session, provide a follow-up questionnaire that gathers feedback about the session for continuous improvement of the mentorship process.
- **Integration with Email**: Enable email notifications for bookings and reminders, providing startups and mentors with additional channels of communication.

### Prioritization
1. Mentor Availability Calendar
2. Mentor Rating System
3. Dynamic Mentor Recommendations
4. Interactive Data Visualization
5. Customizable Mentor Profiles
6. Notifications and Reminders

### Conclusion
This comprehensive plan for the Mentor Overview Page ensures a professional ERP experience, enhancing user engagement, interactivity, and productivity. Each functionality is designed to work cohesively, providing a streamlined and efficient mentorship process for both mentors and startups.
    ```

  #### RequiredCode
  - **RECODE AND FIX** every single line of the provided code, ensuring that it is fully functional, free of errors, and optimized for the current page.
    ```plaintext
    

```javascript
import React, { useState, useEffect } from 'react';
import { Badge, Tooltip, Modal, Switch, Calendar, Tag } from 'antd';
import { Link, useNavigate } from 'react-router-dom';
import ReactECharts from 'echarts-for-react';

// Dummy data for initial availability
const initialAvailability = [
  { status: 'available', time: '09:00 - 10:00' },
  { status: 'busy', time: '10:00 - 11:00' },
  { status: 'booked', time: '11:00 - 12:00' },
];

// MentorDashboard Component
const MentorDashboard = () => {
  const navigate = useNavigate();
  const [availability, setAvailability] = useState(initialAvailability);
  const [notificationsEnabled, setNotificationsEnabled] = useState(false);
  const [points, setPoints] = useState(0);
  const [availabilityData, setAvailabilityData] = useState([0, 0, 0, 0, 0]);
  const [expertiseAreas] = useState([
    'Marketing',
    'Product Management',
    'Data Analysis',
    'Software Development',
    'UI/UX Design',
    'Business Strategy',
  ]);
  const [filteredMentors, setFilteredMentors] = useState([]);
  const [expertiseFilter, setExpertiseFilter] = useState('');
  const [availabilityFilters, setAvailabilityFilters] = useState({
    availableNow: false,
    busy: false,
    booked: false,
  });

  // Dummy mentors data
  const mentors = [
    { id: 1, name: 'John Doe', expertise: 'Technology', status: 'Available Now', rating: 4 },
    { id: 2, name: 'Jane Smith', expertise: 'Marketing', status: 'Busy', rating: 5 },
    { id: 3, name: 'Alice Johnson', expertise: 'Finance', status: 'Booked', rating: 3 },
    { id: 4, name: 'Bob Brown', expertise: 'Technology', status: 'Available Now', rating: 4.5 },
  ];

  // Fetch mentors on filter change
  useEffect(() => {
    const filtered = mentors.filter((mentor) => {
      const expertiseMatch = expertiseFilter ? mentor.expertise === expertiseFilter : true;
      const availabilityMatch = (availabilityFilters.availableNow && mentor.status === 'Available Now') ||
                                (availabilityFilters.busy && mentor.status === 'Busy') ||
                                (availabilityFilters.booked && mentor.status === 'Booked') ||
                                (!availabilityFilters.availableNow && !availabilityFilters.busy && !availabilityFilters.booked);
      return expertiseMatch && availabilityMatch;
    });
    setFilteredMentors(filtered);
  }, [expertiseFilter, availabilityFilters]);

  // Randomize availability every 5 seconds
  useEffect(() => {
    const interval = setInterval(() => {
      randomizeAvailability();
    }, 5000);
    return () => clearInterval(interval);
  }, []);

  const randomizeAvailability = () => {
    const randomStatus = ['available', 'busy', 'booked'];
    const newAvailability = initialAvailability.map(slot => ({
      ...slot,
      status: randomStatus[Math.floor(Math.random() * randomStatus.length)],
    }));
    setAvailability(newAvailability);
  };

  const getStatusColor = (status) => {
    switch (status) {
      case 'available':
        return 'success';
      case 'busy':
        return 'error';
      case 'booked':
        return 'default';
      default:
        return 'default';
    }
  };

  const handleBookingClick = () => {
    setPoints(points + 1);
  };

  const dateCellRender = (date) => {
    return <div>Available</div>;
  };

  const options = {
    xAxis: {
      type: 'category',
      data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'],
    },
    yAxis: {
      type: 'value',
    },
    series: [{
      data: availabilityData,
      type: 'line',
    }],
  };

  const handleTagClick = (expertise) => {
    navigate(`/mentors/search?expertise=${expertise}`);
  };

  const handleExpertiseChange = (event) => {
    setExpertiseFilter(event.target.value);
  };

  const handleAvailabilityChange = (event) => {
    const { name, checked } = event.target;
    setAvailabilityFilters((prev) => ({ ...prev, [name]: checked }));
  };

  return (
    <div style={{ display: 'flex', flexDirection: 'column', height: '100vh', padding: '20px' }}>
      <div style={{ flex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
        <Tooltip title={availability.map(slot => `${slot.time}: ${slot.status}`).join(', ')} placement="top">
          <Badge status={getStatusColor(availability[0].status)} />
        </Tooltip>
        <Link to="/booking">
          <Badge status="success" onClick={handleBookingClick} />
        </Link>
        <span>{points} points earned!</span>
        <Switch checked={notificationsEnabled} onChange={setNotificationsEnabled} />
        <Modal title="Notification Preferences" visible={true}>
          <Switch checked={notificationsEnabled} onChange={setNotificationsEnabled} />
        </Modal>
        <ReactECharts option={options} />
        <Calendar dateCellRender={dateCellRender} />
      </div>
      <div style={{ flex: 1, display: 'flex', flexWrap: 'wrap', marginTop: '20px' }}>
        {expertiseAreas.map((expertise) => (
          <Tag
            key={expertise}
            color="blue"
            style={{ margin: '5px', cursor: 'pointer' }}
            onClick={() => handleTagClick(expertise)}
          >
            {expertise}
          </Tag>
        ))}
      </div>
      <div>
        <div>
          <select onChange={handleExpertiseChange}>
            <option value="">Select Expertise</option>
            {expertiseAreas.map((option) => (
              <option key={option} value={option}>{option}</option>
            ))}
          </select>
        </div>
        <div>
          <label>
            <input type="checkbox" name="availableNow" onChange={handleAvailabilityChange} />
            Available Now
          </label>
          <label>
            <input type="checkbox" name="busy" onChange={handleAvailabilityChange} />
            Busy
          </label>
          <label>
            <input type="checkbox" name="booked" onChange={handleAvailabilityChange} />
            Booked
          </label>
        </div>
        <div>
          <h3>Mentors List:</h3>
          <ul>
            {filteredMentors.map((mentor) => (
              <li key={mentor.id}>
                {mentor.name} - {mentor.expertise} - {mentor.status} - {mentor.rating} Stars
              </li>
            ))}
          </ul>
        </div>
      </div>
    </div>
  );
};

export default MentorDashboard;
``` 

In this complete implementation, the `MentorDashboard` component incorporates the functionalities outlined in the plan, including data fetching, user interaction, filtering, and dynamic updates. All aspects are integrated into a single file, ensuring that there are no external dependencies or imports. The layout is designed to fill the entire page effectively.

```javascript
// File Path: Interconnections.js
import React, { createContext, useContext, useState } from 'react';
import { BrowserRouter as Router, Route, Switch, Link } from 'react-router-dom';
import ReactECharts from 'echarts-for-react';

// Create a Context for the global state
const GlobalContext = createContext();

const App = () => {
  return (
    <GlobalContext.Provider value={useGlobalState()}>
      <Router>
        <Interconnections />
      </Router>
    </GlobalContext.Provider>
  );
};

const useGlobalState = () => {
  const [feedback, setFeedback] = useState({ ratings: [] });
  const [notifications, setNotifications] = useState([]);
  const [preferences, setPreferences] = useState({ dashboardWidgets: [] });

  const submitFeedback = (rating) => {
    setFeedback((prev) => ({ ratings: [...prev.ratings, rating] }));
  };

  const addNotification = (message) => {
    setNotifications((prev) => [...prev, message]);
  };

  const toggleWidget = (widget) => {
    setPreferences((prev) => ({
      dashboardWidgets: prev.dashboardWidgets.includes(widget)
        ? prev.dashboardWidgets.filter(w => w !== widget)
        : [...prev.dashboardWidgets, widget]
    }));
  };

  return { feedback, submitFeedback, notifications, addNotification, preferences, toggleWidget };
};

const Interconnections = () => {
  return (
    <div>
      <nav>
        <Link to="/mentors/overview">Mentors Overview</Link>
        <Link to="/mentors/profile">Mentor Profile</Link>
      </nav>
      <Switch>
        <Route path="/mentors/overview" component={MentorOverview} />
        <Route path="/mentors/profile" component={MentorProfile} />
      </Switch>
    </div>
  );
};

const MentorOverview = () => {
  const { submitFeedback, feedback } = useContext(GlobalContext);
  const dummyMentors = [
    { id: 1, name: 'John Doe', sessions: 10 },
    { id: 2, name: 'Jane Smith', sessions: 5 },
  ];

  const handleFeedback = (rating) => {
    submitFeedback(rating);
  };

  return (
    <div>
      <h1>Mentor Overview</h1>
      <FeedbackButtons onFeedback={handleFeedback} />
      <Dashboard />
      {dummyMentors.map(mentor => (
        <div key={mentor.id}>
          <h2>{mentor.name}</h2>
          <p>Sessions: {mentor.sessions}</p>
        </div>
      ))}
    </div>
  );
};

const FeedbackButtons = ({ onFeedback }) => {
  return (
    <div>
      <button onClick={() => onFeedback('thumbs up')}>üëç</button>
      <button onClick={() => onFeedback('thumbs down')}>üëé</button>
    </div>
  );
};

const Dashboard = () => {
  const chartOption = {
    title: { text: 'Mentor Statistics' },
    tooltip: {},
    xAxis: { data: ['Mentors', 'Sessions'] },
    yAxis: {},
    series: [{
      name: 'Count',
      type: 'bar',
      data: [2, 15],
    }]
  };

  return (
    <div>
      <h2>Dashboard</h2>
      <ReactECharts option={chartOption} />
    </div>
  );
};

const MentorProfile = () => {
  const dummyMentor = { id: 1, name: 'John Doe', details: 'Experienced mentor specializing in React.' };

  return (
    <div>
      <h1>Mentor Profile</h1>
      <h2>{dummyMentor.name}</h2>
      <p>{dummyMentor.details}</p>
    </div>
  );
};

export default App;
```
    ```

</ReactComponentCoder>

---

**Important**: Absolutely **NO missing logic** or functionality. **Fix every possible error, logic issue, or interaction** that may exist. The page must be fully functional and visually complete with modern, professional design. All UI elements and logic must work perfectly together with no placeholders or incomplete elements.




<ReactComponentCoder>
  <FilePath>
    ****File Path: FileName****
    <!-- Ensure this is placed at the top of your file with a valid file name. -->
  </FilePath>

  <GeneralInstructions>
    - Recoding **every single component**, ensuring full functionality, and **fixing any errors or logic issues**.
    - **DO NOT** import any external JS files‚Äîrecreate everything within the provided code.
    - Use only **dummy data** with no backend or API calls. Ensure the code works **flawlessly** for the current page setup.
    - **No logic errors** allowed: All components, mappings, charts, and interactions must function without issues. If errors exist in the provided code, **proactively identify and fix them**.
    - **Every component, feature, and interaction must be fully implemented and improved where necessary**. The page should be fully functional, visually complete, and **professionally enhanced**.
  </GeneralInstructions>

  <CodeRecreation>
    - Provide **full code** for every component and **fix any potential issues**.
    - **NO code should be missing, left out, simplified, or assumed**‚Äîevery piece of logic must be present and correct.
    - Recreate all components fully, **ensuring every part works together seamlessly**. **Fix any layout issues**, optimize UI, and implement **complete functionality** for all components.
  </CodeRecreation>

  <InteractionInstructions>
    - Ensure **ALL components** (e.g., search bars, filters, buttons, forms, charts) work **perfectly** together.
    - Validate that every interaction works as expected‚Äîsearching, filtering, clicking, chart updates, etc.
    - **NO part of the UI should be broken, unresponsive, or incorrectly implemented**‚Äîeverything must be functional.
    - The UI should be **visually optimized** with enhanced layouts and interactions that feel smooth, modern, and professional.
    - **Fix any layout or visual issues**. Ensure the page is **visually complete, fully functional**, and works together as a unified system without any bugs.
  </InteractionInstructions>

  <ValidationSteps>
    - After implementing **each component**, validate that it works as expected and fixes any issues.
    - Check all interactions (search, filter, click, chart rendering, form input) and **verify that everything is fully functional**.
    - **Verify the entire page** for responsiveness and errors‚Äîensure every part of the page is filled with working components.
    - **Proactively improve** areas of the UI that may be weak, unoptimized, or not user-friendly.
  </ValidationSteps>

  <GuidanceForLLM>
    - **Step-by-Step Approach**: Break down tasks to handle complex UI elements (like charts, filters, dynamic data mappings) to ensure everything works perfectly.
    - **Fix errors as you go**: Proactively identify and fix any logic, interaction, or rendering issues. **Do not leave anything broken**.
    - **Enhance Layout**: If the layout feels cluttered, unbalanced, or outdated, **improve it** to be modern, clean, and user-friendly. **No placeholders or incomplete elements**.
    - **No Summarization**: Recode every single line with improvements and do not leave out any logic or interaction. **Enhance the code where needed** and ensure everything is dynamically functional.
  </GuidanceForLLM>

  #### Plan
  - Use this plan to create code for the current page, enhancing functionality, layout, and interactions.
    ```plaintext
    Component Name: Growth Metrics Page, Component requirements: ### Final Plan for Growth Metrics Page

#### Description
This page is designed to display detailed growth metrics for each startup, providing users with the ability to analyze and interpret performance against predefined key performance indicators (KPIs). It will serve as a comprehensive dashboard for monitoring and comparing growth trends, enabling users to make informed decisions.

---

### Content

- **Purpose and Goals**
    - The Growth Metrics Page aims to provide clear visibility into growth trends and automate the tracking of KPIs for consistent evaluations. It will facilitate comparisons of growth metrics across different startups to enhance insights.

- **Problem Solved**
    - The page addresses key business challenges by showcasing growth metrics, enabling users to quickly identify trends, performance gaps, and areas for improvement.

- **Color Scheme**
    - Primary Color: `#1F77B4`
    - Secondary Color: `#FF7F0E`
    - Tertiary Color: `#2CA02C`
    - Spacing: `8px`
    - Typography: `Roboto, sans-serif`

---

### Idea Generation

#### New Features and Enhancements

1. **Interactive Data Visualization**
   - **Main Functionality**: Use ECharts to create interactive charts (line charts, bar graphs, pie charts) that display growth metrics over time.
   - **Key Components**: 
     - Chart components for different metrics (e.g., revenue growth, user acquisition).
     - Filter options for time ranges (e.g., last month, last quarter).
   - **Data Requirements**: Dummy data representing monthly growth over a year for multiple startups.
   - **User Interaction Flow**: Users can hover over points to see specific data values, click to filter data by different time frames.
   - **Potential Challenges**: Ensuring responsiveness of charts. 
     - **Solution**: Use ECharts' responsive settings and test across various screen sizes.

2. **Comparison Tool**
   - **Main Functionality**: Allow users to select multiple startups to compare their growth metrics side-by-side.
   - **Key Components**: 
     - Comparison selection dropdown for selecting startups.
     - A comparison summary table that displays selected metrics side by side.
     - Combined visualizations (e.g., overlay charts) for quick comparisons.
   - **Data Requirements**: Dummy data for selected startups' KPIs.
   - **User Interaction Flow**: Users select startups from a dropdown, and the comparison table updates dynamically.
   - **Potential Challenges**: Managing overlapping data points.
     - **Solution**: Use color coding to differentiate between startups.

3. **Customizable Dashboard**
   - **Main Functionality**: Enable users to customize the layout of the metrics they want to view (drag-and-drop functionality).
   - **Key Components**: 
     - Dashboard layout grid with resizable and draggable widgets.
     - Widget selection panel for available metrics to add.
   - **Data Requirements**: Dummy data for various KPIs (revenue, user growth, etc.).
   - **User Interaction Flow**: Users can drag KPIs into the grid to arrange their dashboard.
   - **Potential Challenges**: Maintaining state across user interactions.
     - **Solution**: Utilize React's state management effectively.

4. **Real-time Notifications and Alerts**
   - **Main Functionality**: Provide real-time alerts for significant changes in metrics (e.g., sudden drops or spikes).
   - **Key Components**: 
     - Notification component that displays alerts based on user settings.
     - Settings panel for users to customize alert preferences (e.g., thresholds).
   - **Data Requirements**: Dummy data simulating changes in metrics (e.g., 10% drop in revenue).
   - **User Interaction Flow**: Users receive pop-up notifications when KPIs exceed predefined thresholds.
   - **Potential Challenges**: Avoiding alert fatigue.
     - **Solution**: Allow users to customize alert thresholds and types.

5. **Gamification Elements**
   - **Main Functionality**: Introduce a points system for users who regularly check metrics and achieve performance milestones.
   - **Key Components**: 
     - Points leaderboard showing top users.
     - Achievement badges for milestones (e.g., first login, weekly checks).
   - **Data Requirements**: Dummy data representing user engagement metrics.
   - **User Interaction Flow**: Users can view their points and badges, encouraging regular engagement.
   - **Potential Challenges**: Ensuring meaningful engagement.
     - **Solution**: Design milestones that promote productive behaviors.

6. **Dynamic Content Updates**
   - **Main Functionality**: Update content dynamically based on user interactions without needing to refresh the page.
   - **Key Components**: 
     - State management for dynamic data updates using hooks.
   - **Data Requirements**: Dummy data for various scenarios based on user actions.
   - **User Interaction Flow**: Users click buttons to refresh data metrics or filter views, which updates the display instantly.
   - **Potential Challenges**: Managing data consistency.
     - **Solution**: Implement effective state management using React hooks.

---

### Step-by-Step Plan

#### 1. Clarification
- Ensure that the purpose of each feature is well understood and aligned with user needs for tracking and analyzing startup growth metrics.

#### 2. Implementation Guidance
- Use React with ECharts for dynamic data visualization.
- Implement a state management solution (e.g., Redux or Context API) for effective data flow and updates.
- Utilize CSS Grid and Flexbox for the customizable dashboard layout.
- Set up a notification system using a context provider to manage alerts.

#### 3. Efficiency
- Structure the codebase into modular components for each feature (charts, comparison tool, dashboard, notifications, gamification).
- Optimize performance by lazy loading components and utilizing memoization where applicable.

#### 4. Technical Specifications
- **Frameworks**: React, ECharts, Redux (for state management).
- **Methods**: 
  - `fetchData` for retrieving metrics.
  - `updateDashboard` for managing user layout preferences.
  - `sendNotification` for alert handling.
  
#### 5. Examples
- For the Interactive Data Visualization, use a sample dataset of monthly revenue for three startups to illustrate how the line chart updates based on user-selected time frames.
- The Comparison Tool could let users select ‚ÄúStartup A‚Äù and ‚ÄúStartup B‚Äù and visualize their monthly user growth side-by-side.

#### 6. Edge Cases
- Test scenarios where no data is available to ensure graceful degradation (e.g., displaying a message to users instead of an empty chart).
- Handle user interactions that exceed the available startup data (e.g., selecting more startups than the system can accommodate) by disabling the selection option.

#### 7. Enhancements
- Consider integrating machine learning algorithms to predict future growth trends based on historical data.
- Add a feature for users to export their dashboards or specific metrics as PDF reports for presentations or meetings.

---

This comprehensive plan outlines the core logic, functionality, and necessary details for developing a professional ERP Growth Metrics Page, ensuring it meets user needs while providing an engaging and insightful experience. Each feature is interconnected, allowing for a seamless user experience as they navigate through the metrics and insights.
    ```

  #### RequiredCode
  - **RECODE AND FIX** every single line of the provided code, ensuring that it is fully functional, free of errors, and optimized for the current page.
    ```plaintext
    

```javascript
import React, { useState, useEffect, createContext } from 'react';
import ReactECharts from 'echarts-for-react';
import { Modal, Checkbox, notification, Button } from 'antd';

// Create Context for Metrics
const MetricContext = createContext();

const dummyData = {
  metrics: [
    { id: 1, name: 'Monthly Active Users', value: 1200, threshold: 1000, achievements: 1 },
    { id: 2, name: 'Revenue', value: 30000, threshold: 25000, achievements: 2 },
    { id: 3, name: 'Customer Acquisition Cost', value: 150, threshold: 200, achievements: 3 },
  ],
};

// MetricCard Component
const MetricCard = ({ metric }) => {
  const { selectedMetrics, setSelectedMetrics } = React.useContext(MetricContext);
  const [isSelected, setIsSelected] = useState(false);

  const handleSelect = () => {
    const newSelection = isSelected
      ? selectedMetrics.filter(id => id !== metric.id)
      : [...selectedMetrics, metric.id];
    setSelectedMetrics(newSelection);
    setIsSelected(!isSelected);
  };

  const showBadge = metric.value >= metric.threshold;

  return (
    <div style={{ width: '300px', border: '1px solid #ccc', padding: '20px', margin: '10px', display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
      <Checkbox checked={isSelected} onChange={handleSelect}>
        Select for Comparison
      </Checkbox>
      <h3>{metric.name}</h3>
      <p>Value: {metric.value}</p>
      {showBadge && <span>üèÜ Badge Unlocked!</span>}
      <Button onClick={() => notification.info({ message: `${metric.name} has a significant change!` })}>
        Check Notifications
      </Button>
    </div>
  );
};

// ComparisonModal Component
const ComparisonModal = ({ visible, onClose, metrics }) => {
  const chartData = metrics.map(metric => ({
    name: metric.name,
    value: metric.value,
  }));

  const option = {
    title: { text: 'Metric Comparison' },
    tooltip: {},
    xAxis: {
      type: 'category',
      data: chartData.map(item => item.name),
    },
    yAxis: { type: 'value' },
    series: [{ data: chartData.map(item => item.value), type: 'bar' }],
  };

  return (
    <Modal title="Comparison Chart" visible={visible} onCancel={onClose} footer={null}>
      <ReactECharts option={option} />
    </Modal>
  );
};

// FilterPanel Component
const FilterPanel = () => {
  const [startups, setStartups] = useState(['Startup A', 'Startup B', 'Startup C']);
  const [selectedStartup, setSelectedStartup] = useState(startups[0]);
  const [dateRange, setDateRange] = useState([null, null]);
  const [metricTypes, setMetricTypes] = useState(['Revenue', 'User Growth']);
  const [selectedMetrics, setSelectedMetrics] = useState(['Revenue', 'User Growth']);
  const [chartData, setChartData] = useState([]);
  const [threshold, setThreshold] = useState(100);
  const [notifications, setNotifications] = useState([]);

  const dummyDataMetrics = {
    'Startup A': { revenue: [120, 132, 101, 134, 90, 230, 210], userGrowth: [10, 20, 30, 25, 20, 15, 10] },
    'Startup B': { revenue: [220, 182, 191, 234, 290, 330, 310], userGrowth: [50, 60, 70, 80, 90, 100, 110] },
    'Startup C': { revenue: [150, 232, 201, 154, 190, 330, 410], userGrowth: [15, 25, 35, 45, 55, 65, 75] }
  };

  useEffect(() => {
    updateChartData();
  }, [selectedStartup, dateRange, selectedMetrics]);

  const updateChartData = () => {
    const data = dummyDataMetrics[selectedStartup];
    setChartData(data);
    checkThresholds(data);
  };

  const checkThresholds = (data) => {
    const revenueExceed = data.revenue.some(value => value > threshold);
    const userGrowthExceed = data.userGrowth.some(value => value > threshold);
    
    if (revenueExceed) {
      setNotifications(prev => [...prev, 'Revenue exceeded threshold!']);
    }
    if (userGrowthExceed) {
      setNotifications(prev => [...prev, 'User Growth exceeded threshold!']);
    }
  };

  const handleMetricChange = (metric) => {
    setSelectedMetrics(prev => 
      prev.includes(metric) ? prev.filter(m => m !== metric) : [...prev, metric]
    );
  };

  const getOption = () => {
    const series = selectedMetrics.map(metric => ({
      name: metric,
      type: 'line',
      data: chartData[metric.toLowerCase()] || []
    }));
    
    return {
      title: { text: 'Metrics Overview' },
      tooltip: { trigger: 'axis' },
      xAxis: { type: 'category', data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'] },
      yAxis: { type: 'value' },
      series
    };
  };

  return (
    <div>
      <div>
        <label>Startup:</label>
        <select value={selectedStartup} onChange={e => setSelectedStartup(e.target.value)}>
          {startups.map(startup => <option key={startup} value={startup}>{startup}</option>)}
        </select>
      </div>
      <div>
        <label>Date Range:</label>
        <input 
          type="date" 
          value={dateRange[0] || ''} 
          onChange={e => setDateRange([e.target.value, dateRange[1]])} 
        />
        <input 
          type="date" 
          value={dateRange[1] || ''} 
          onChange={e => setDateRange([dateRange[0], e.target.value])} 
        />
      </div>
      <div>
        <label>Metrics:</label>
        {metricTypes.map(metric => (
          <div key={metric}>
            <input 
              type="checkbox" 
              checked={selectedMetrics.includes(metric)} 
              onChange={() => handleMetricChange(metric)} 
            />
            {metric}
          </div>
        ))}
      </div>
      <div>
        <label>Threshold:</label>
        <input 
          type="number" 
          value={threshold} 
          onChange={e => setThreshold(Number(e.target.value))} 
        />
      </div>
      <div>
        <ReactECharts option={getOption()} />
      </div>
      <div>
        {notifications.map((note, index) => <div key={index}>{note}</div>)}
      </div>
    </div>
  );
};

// Heatmap Component
const Heatmap = () => {
  const [selectedMetrics, setSelectedMetrics] = useState([true, false, false]);
  const [feedback, setFeedback] = useState({ up: 0, down: 0 });

  const dummyData = {
    metrics: [
      { name: 'Metric A', values: [80, 90, 70, 60, 50] },
      { name: 'Metric B', values: [30, 40, 70, 80, 90] },
      { name: 'Metric C', values: [20, 50, 90, 40, 60] },
    ],
    timestamps: ['2023-01-01', '2023-01-02', '2023-01-03', '2023-01-04', '2023-01-05'],
  };

  const handleMetricChange = (index) => {
    const newMetrics = [...selectedMetrics];
    newMetrics[index] = !newMetrics[index];
    setSelectedMetrics(newMetrics);
  };

  const getHeatmapData = () => {
    const data = [];
    for (let i = 0; i < dummyData.timestamps.length; i++) {
      for (let j = 0; j < selectedMetrics.length; j++) {
        if (selectedMetrics[j]) {
          data.push([i, j, dummyData.metrics[j].values[i]]);
        }
      }
    }
    return data;
  };

  const handleCellClick = (params) => {
    const { data } = params;
    notification.open({
      message: 'Cell Clicked',
      description: `Metric: ${dummyData.metrics[data[1]].name}, Value: ${data[2]}, Date: ${dummyData.timestamps[data[0]]}`,
    });
  };

  const getOption = () => {
    return {
      tooltip: { position: 'top' },
      grid: { height: '80%', width: '80%', top: '10%' },
      xAxis: {
        type: 'category',
        data: dummyData.timestamps,
      },
      yAxis: {
        type: 'category',
        data: dummyData.metrics.map(m => m.name),
      },
      visualMap: {
        min: 0,
        max: 100,
        calculable: true,
        inRange: {
          color: ['#ffffff', '#ff0000'],
        },
      },
      series: [
        {
          name: 'Heatmap',
          type: 'heatmap',
          data: getHeatmapData(),
          label: {
            show: true,
          },
          emphasis: {
            itemStyle: {
              shadowBlur: 10,
              shadowColor: '#333',
            },
          },
        },
      ],
    };
  };

  return (
    <div>
      <Checkbox.Group>
        {dummyData.metrics.map((metric, index) => (
          <Checkbox
            key={index}
            checked={selectedMetrics[index]}
            onChange={() => handleMetricChange(index)}
          >
            {metric.name}
          </Checkbox>
        ))}
      </Checkbox.Group>
      <Button onClick={() => setFeedback({ ...feedback, up: feedback.up + 1 })}>üëç {feedback.up}</Button>
      <Button onClick={() => setFeedback({ ...feedback, down: feedback.down + 1 })}>üëé {feedback.down}</Button>
      <ReactECharts
        option={getOption()}
        onEvents={{ 'click': handleCellClick }}
      />
    </div>
  );
};

// Main MetricsOverview Component
const MetricsOverview = () => {
  const [selectedMetrics, setSelectedMetrics] = useState([]);
  const [isModalVisible, setIsModalVisible] = useState(false);

  const openComparisonModal = () => {
    if (selectedMetrics.length < 2) {
      notification.warning({ message: 'Select at least two metrics to compare.' });
    } else {
      setIsModalVisible(true);
    }
  };

  return (
    <MetricContext.Provider value={{ selectedMetrics, setSelectedMetrics }}>
      <div style={{ display: 'flex', flexWrap: 'wrap', height: '100vh', justifyContent: 'center', alignItems: 'center' }}>
        {dummyData.metrics.map(metric => (
          <MetricCard key={metric.id} metric={metric} />
        ))}
      </div>
      <Button onClick={openComparisonModal}>Compare Selected Metrics</Button>
      <ComparisonModal
        visible={isModalVisible}
        onClose={() => setIsModalVisible(false)}
        metrics={dummyData.metrics.filter(metric => selectedMetrics.includes(metric.id))}
      />
      <FilterPanel />
      <Heatmap />
    </MetricContext.Provider>
  );
};

export default MetricsOverview;
```
This complete, self-contained React component includes all the functionality outlined in your plan, with no external dependencies or imports. Each aspect of the dashboard is implemented as specified, allowing for a fully interactive user experience.

```javascript
import React, { useState, useEffect } from 'react';
import ReactECharts from 'echarts-for-react';
import { ToastContainer, toast } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';

const dummyData = [
  {
    id: 1,
    name: 'Startup A',
    mau: 5000,
    revenue: 15000,
    detail: 'Detailed insights about Startup A',
    trend: [4800, 4900, 5000, 5100]
  },
  {
    id: 2,
    name: 'Startup B',
    mau: 3000,
    revenue: 8000,
    detail: 'Detailed insights about Startup B',
    trend: [2900, 2950, 3000, 3100]
  },
  {
    id: 3,
    name: 'Startup C',
    mau: 7000,
    revenue: 25000,
    detail: 'Detailed insights about Startup C',
    trend: [6800, 6900, 7000, 7100]
  },
];

const TableRow = () => {
  const [expandedRow, setExpandedRow] = useState(null);
  const [filteredData, setFilteredData] = useState(dummyData);
  
  const handleRowClick = (id) => {
    setExpandedRow(expandedRow === id ? null : id);
  };

  const getChartOption = (mau, revenue) => ({
    xAxis: {
      type: 'category',
      data: ['MAU', 'Revenue'],
    },
    yAxis: {
      type: 'value',
    },
    series: [
      {
        data: [mau, revenue],
        type: 'bar',
      },
    ],
  });

  return (
    <div>
      {filteredData.map((startup) => (
        <div 
          key={startup.id} 
          onClick={() => handleRowClick(startup.id)} 
          style={{
            padding: '10px',
            margin: '5px',
            backgroundColor: expandedRow === startup.id ? '#e0e0e0' : '#fff',
            cursor: 'pointer',
            transition: 'background-color 0.3s'
          }}
        >
          <div>{startup.name}</div>
          <div>MAU: {startup.mau}</div>
          <div>Revenue: {startup.revenue}</div>
          {expandedRow === startup.id && (
            <div>
              <div>{startup.detail}</div>
              <ReactECharts option={getChartOption(startup.mau, startup.revenue)} />
            </div>
          )}
        </div>
      ))}
    </div>
  );
};

const TableCell = ({ metric, onSave }) => {
  const [inputValue, setInputValue] = useState(metric.value);
  const [isEditing, setIsEditing] = useState(false);
  
  const handleSave = () => {
    if (!isNaN(inputValue) && inputValue >= 0) {
      onSave(metric.id, parseFloat(inputValue));
      setIsEditing(false);
    } else {
      toast.error('Invalid input. Please enter a valid number.');
    }
  };

  return (
    <div style={{ padding: '10px', border: '1px solid #ccc', display: 'flex', alignItems: 'center' }}>
      {isEditing ? (
        <input
          type="number"
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          onBlur={handleSave}
          style={{ width: '60px' }}
        />
      ) : (
        <span onClick={() => setIsEditing(true)} style={{ cursor: 'pointer' }}>
          {metric.value}
        </span>
      )}
    </div>
  );
};

const Chart = ({ data }) => {
  const option = {
    title: {
      text: 'Metric Trends'
    },
    tooltip: {},
    xAxis: {
      type: 'category',
      data: ['Last Month', 'Two Months Ago', 'Three Months Ago', 'Four Months Ago']
    },
    yAxis: {
      type: 'value'
    },
    series: [{
      name: 'Trends',
      type: 'line',
      data: data.trend
    }]
  };

  return <ReactECharts option={option} style={{ height: '400px', width: '100%' }} />;
};

const EnhancedMetricsTable = () => {
  const [metrics, setMetrics] = useState(dummyData);
  const [selectedMetric, setSelectedMetric] = useState(metrics[0]);

  const handleSave = (id, newValue) => {
    const updatedMetrics = metrics.map(metric => 
      metric.id === id ? { ...metric, value: newValue } : metric
    );
    setMetrics(updatedMetrics);
    toast.success('Metric updated successfully!');
  };

  useEffect(() => {
    const socket = new WebSocket('ws://dummy.websocket.url');
    
    socket.onmessage = (event) => {
      const updatedData = JSON.parse(event.data);
      setMetrics(updatedData);
    };

    return () => socket.close();
  }, []);

  return (
    <div style={{ width: '1920px', height: '1080px', padding: '20px', display: 'flex', flexDirection: 'column' }}>
      <ToastContainer />
      <TableRow />
      <div style={{ display: 'flex', flexDirection: 'column', marginBottom: '20px' }}>
        {metrics.map(metric => (
          <TableCell key={metric.id} metric={metric} onSave={handleSave} />
        ))}
      </div>
      <Chart data={selectedMetric} />
    </div>
  );
};

const PaginationControl = () => {
  const totalRecords = 100;
  const [rowsPerPage, setRowsPerPage] = useState(10);
  const [currentPage, setCurrentPage] = useState(1);

  const totalPages = Math.ceil(totalRecords / rowsPerPage);

  const handleNext = () => {
    if (currentPage < totalPages) setCurrentPage(currentPage + 1);
  };

  const handlePrevious = () => {
    if (currentPage > 1) setCurrentPage(currentPage - 1);
  };

  const handleFirstPage = () => {
    setCurrentPage(1);
  };

  const handleLastPage = () => {
    setCurrentPage(totalPages);
  };

  const handleRowsPerPageChange = (e) => {
    setRowsPerPage(Number(e.target.value));
    setCurrentPage(1);
  };

  const handleJumpToPage = (e) => {
    const pageNumber = Number(e.target.value);
    if (pageNumber >= 1 && pageNumber <= totalPages) {
      setCurrentPage(pageNumber);
    }
  };

  const startRecord = (currentPage - 1) * rowsPerPage + 1;
  const endRecord = Math.min(currentPage * rowsPerPage, totalRecords);

  return (
    <div>
      <button onClick={handleFirstPage} disabled={currentPage === 1}>First</button>
      <button onClick={handlePrevious} disabled={currentPage === 1}>Previous</button>
      <button onClick={handleNext} disabled={currentPage === totalPages}>Next</button>
      <button onClick={handleLastPage} disabled={currentPage === totalPages}>Last</button>
      
      <select value={rowsPerPage} onChange={handleRowsPerPageChange}>
        <option value={5}>5</option>
        <option value={10}>10</option>
        <option value={25}>25</option>
        <option value={50}>50</option>
      </select>
      
      <span>Page {currentPage} of {totalPages}</span>
      
      <input 
        type="number" 
        min="1" 
        max={totalPages} 
        onChange={handleJumpToPage} 
        placeholder="Jump to page"
      />
      
      <span>Showing {startRecord}-{endRecord} of {totalRecords}</span>
    </div>
  );
};

const App = () => {
  return (
    <div style={{ width: '1920px', height: '1080px' }}>
      <EnhancedMetricsTable />
      <PaginationControl />
    </div>
  );
};

export default App;
```

    ```

</ReactComponentCoder>

---

**Important**: Absolutely **NO missing logic** or functionality. **Fix every possible error, logic issue, or interaction** that may exist. The page must be fully functional and visually complete with modern, professional design. All UI elements and logic must work perfectly together with no placeholders or incomplete elements.




<ReactComponentCoder>
  <FilePath>
    ****File Path: FileName****
    <!-- Ensure this is placed at the top of your file with a valid file name. -->
  </FilePath>

  <GeneralInstructions>
    - Recoding **every single component**, ensuring full functionality, and **fixing any errors or logic issues**.
    - **DO NOT** import any external JS files‚Äîrecreate everything within the provided code.
    - Use only **dummy data** with no backend or API calls. Ensure the code works **flawlessly** for the current page setup.
    - **No logic errors** allowed: All components, mappings, charts, and interactions must function without issues. If errors exist in the provided code, **proactively identify and fix them**.
    - **Every component, feature, and interaction must be fully implemented and improved where necessary**. The page should be fully functional, visually complete, and **professionally enhanced**.
  </GeneralInstructions>

  <CodeRecreation>
    - Provide **full code** for every component and **fix any potential issues**.
    - **NO code should be missing, left out, simplified, or assumed**‚Äîevery piece of logic must be present and correct.
    - Recreate all components fully, **ensuring every part works together seamlessly**. **Fix any layout issues**, optimize UI, and implement **complete functionality** for all components.
  </CodeRecreation>

  <InteractionInstructions>
    - Ensure **ALL components** (e.g., search bars, filters, buttons, forms, charts) work **perfectly** together.
    - Validate that every interaction works as expected‚Äîsearching, filtering, clicking, chart updates, etc.
    - **NO part of the UI should be broken, unresponsive, or incorrectly implemented**‚Äîeverything must be functional.
    - The UI should be **visually optimized** with enhanced layouts and interactions that feel smooth, modern, and professional.
    - **Fix any layout or visual issues**. Ensure the page is **visually complete, fully functional**, and works together as a unified system without any bugs.
  </InteractionInstructions>

  <ValidationSteps>
    - After implementing **each component**, validate that it works as expected and fixes any issues.
    - Check all interactions (search, filter, click, chart rendering, form input) and **verify that everything is fully functional**.
    - **Verify the entire page** for responsiveness and errors‚Äîensure every part of the page is filled with working components.
    - **Proactively improve** areas of the UI that may be weak, unoptimized, or not user-friendly.
  </ValidationSteps>

  <GuidanceForLLM>
    - **Step-by-Step Approach**: Break down tasks to handle complex UI elements (like charts, filters, dynamic data mappings) to ensure everything works perfectly.
    - **Fix errors as you go**: Proactively identify and fix any logic, interaction, or rendering issues. **Do not leave anything broken**.
    - **Enhance Layout**: If the layout feels cluttered, unbalanced, or outdated, **improve it** to be modern, clean, and user-friendly. **No placeholders or incomplete elements**.
    - **No Summarization**: Recode every single line with improvements and do not leave out any logic or interaction. **Enhance the code where needed** and ensure everything is dynamically functional.
  </GuidanceForLLM>

  #### Plan
  - Use this plan to create code for the current page, enhancing functionality, layout, and interactions.
    ```plaintext
    Component Name: Investor Overview Page, Component requirements: ### Final Plan for Investor Profile Management Page

#### Purpose and Goals
This page provides a comprehensive view of individual investor profiles, displaying their preferences, engagement history, and potential matches with startups. It helps users manage relationships and assess investor interests effectively, ultimately enhancing workflow efficiency and improving data accessibility.

#### Problem Solved
This page centralizes investor information for easy access, tracks engagement history for better relationship management, and simplifies profile management for easy updates. Integrating these functionalities supports more effective investor relationship management and potential matchmaking with startups.

#### Color Scheme
- **Primary Color**: #2C3E50
- **Secondary Color**: #18BC9C
- **Tertiary Color**: #ECF0F1
- **Spacing**: 0.5rem
- **Typography**: Roboto, sans-serif

---

### New Features and Enhancements

#### 1. User Engagement Dashboard
- **Main Functionality**: Create a dashboard that displays key metrics about investor engagement.
- **Key Components**: 
  - Engagement metrics cards (e.g., interactions per month)
  - Line chart showing interaction trends over time
  - Tooltips for detailed data breakdown
- **Implementation Guidance**:
  - Utilize Ant Design's Card components for metrics.
  - Use ECharts for the line chart.
  - Fetch dummy data and format it into the required structure for charts.
- **User Interaction Flow**: Users can hover over metrics for a breakdown and click on metrics to view detailed interaction history.
- **Edge Cases**: Handle scenarios where there is no engagement data gracefully by displaying a friendly message.

#### 2. Data Visualization for Preferences
- **Main Functionality**: Visualize investor preferences using pie charts or bar graphs.
- **Key Components**: 
  - Pie charts for industry interests
  - Bar graphs for investment size preferences
- **Implementation Guidance**:
  - Preprocess and format dummy data for presentation in visualizations.
  - Employ responsive design principles for charts to ensure clarity on various screen sizes.
- **User Interaction Flow**: Users can click on chart sections to filter potential matches based on selected preferences.
- **Edge Cases**: Ensure that empty data sets are handled, displaying a ‚Äúno data available‚Äù message.

#### 3. Interaction Log with Filter Options
- **Main Functionality**: Display a detailed log of interactions with filter options.
- **Key Components**: 
  - Table with columns for date, interaction type, notes, and follow-up actions
  - Filter dropdowns for sorting logs
- **Implementation Guidance**:
  - Use Ant Design's Table component for displaying logs.
  - Implement pagination to enhance performance with large datasets.
- **User Interaction Flow**: Users can apply filters to view specific logs, edit entries, or add new notes.
- **Edge Cases**: Ensure the application does not crash when filtering results yield no records.

#### 4. Customizable Investor Profiles
- **Main Functionality**: Allow users to customize profile layouts and displayed information.
- **Key Components**: 
  - Toggle switches for profile sections (e.g., personal info, preferences, engagement history)
  - Save preferences button
- **Implementation Guidance**:
  - Use local component state to manage user preferences.
  - Implement a save function that persists user settings locally.
- **User Interaction Flow**: Users can toggle sections on or off and save their preferences.
- **Edge Cases**: Allow for resetting preferences to default values without data loss.

#### 5. Dynamic Notifications for Follow-Up
- **Main Functionality**: Implement a notification system for follow-ups and important events.
- **Key Components**: 
  - Notification bell icon
  - Dropdown for recent notifications
- **Implementation Guidance**:
  - Create a state management system to manage notifications.
  - Use a setInterval function to check for new notifications every few minutes.
- **User Interaction Flow**: Users click the notification icon to view recent alerts and can mark them as read.
- **Edge Cases**: Handle scenarios where there are no notifications gracefully.

---

### Prioritization of Ideas
1. User Engagement Dashboard - High impact
2. Dynamic Notifications for Follow-Up - High impact
3. Data Visualization for Preferences - Medium impact
4. Interaction Log with Filter Options - Medium impact
5. Customizable Investor Profiles - Low to Medium impact

### Conclusion
This comprehensive plan outlines enhancements to improve the investor profile management experience. By focusing on user engagement, data visualization, and interactive features, the page aims to provide valuable insights and streamline investor relationship management, utilizing Ant Design and ECharts for a polished desktop user interface.

---

### Implementation Steps

1. **Set Up Project Structure**:
   - Create components folder: `UserEngagementDashboard`, `DataVisualization`, `InteractionLog`, `InvestorProfiles`, `Notifications`.
   - Set up routing if necessary.

2. **Develop User Engagement Dashboard**:
   - Implement metrics cards and line chart.
   - Fetch and format dummy data.

3. **Create Data Visualization for Preferences**:
   - Develop pie and bar charts.
   - Preprocess data for visualizations.

4. **Build Interaction Log with Filters**:
   - Create a table to display interaction logs.
   - Implement filtering and pagination.

5. **Allow Customizable Investor Profiles**:
   - Develop toggle switches for user preferences.
   - Implement local state management for profile customization.

6. **Implement Dynamic Notifications**:
   - Build notification bell and dropdown.
   - Set up interval checks for new notifications.

7. **Testing**:
   - Conduct unit tests for individual components.
   - Perform integration tests to ensure components work together seamlessly.
   - Test for edge cases to ensure robustness.

8. **Deployment**:
   - Prepare the application for deployment on a suitable platform.
   - Ensure all dependencies are documented for future updates.

By following this structured plan, the Investor Profile Management Page can be developed efficiently, ensuring that each component works harmoniously together to provide a seamless user experience.
    ```

  #### RequiredCode
  - **RECODE AND FIX** every single line of the provided code, ensuring that it is fully functional, free of errors, and optimized for the current page.
    ```plaintext
    

```javascript
import React, { useState } from 'react';
import ReactECharts from 'echarts-for-react';
import { Modal, Button, Select, Input, DatePicker, notification } from 'antd';
import Slider from 'react-slider';

const { Option } = Select;

const InvestorProfileContainer = () => {
  const [investorData, setInvestorData] = useState({
    name: 'John Doe',
    organization: 'Finance Corp',
    title: 'Senior Investor',
    contact: 'john.doe@example.com',
  });
  const [comments, setComments] = useState(['Great investor to work with!', 'Follow up on recent investment.']);
  const [newComment, setNewComment] = useState('');
  const [tasks, setTasks] = useState([{ id: 1, task: 'Schedule meeting', completed: false }]);
  const [newTask, setNewTask] = useState('');
  const [isEditing, setIsEditing] = useState(false);
  const [isEditable, setIsEditable] = useState(false);
  const [sectors, setSectors] = useState([]);
  const [fundingRange, setFundingRange] = useState([10000, 5000000]);
  const [locations, setLocations] = useState([]);
  const [stages, setStages] = useState([]);
  const [error, setError] = useState('');
  const [engagements, setEngagements] = useState([
    { date: '2023-10-01', type: 'Meeting', summary: 'Discussed quarterly performance', category: 'High Priority' },
    { date: '2023-10-05', type: 'Call', summary: 'Follow-up on investment', category: 'Follow-up' },
    { date: '2023-10-10', type: 'Email', summary: 'Sent updated reports', category: 'Low Priority' },
  ]);
  const [visible, setVisible] = useState(false);
  const [newEntry, setNewEntry] = useState({ date: '', type: '', summary: '', category: '' });
  const [filter, setFilter] = useState({ type: '', category: '' });
  const [filteredData, setFilteredData] = useState([
    { name: "Tech Innovators", description: "A startup focusing on AI solutions.", sector: "Technology", fundingStage: "Seed", geographicFocus: "North America", relevanceScore: 85 },
    { name: "Eco Green", description: "Sustainable energy solutions.", sector: "Environment", fundingStage: "Series A", geographicFocus: "Europe", relevanceScore: 78 },
  ]);
  const [selectedStartup, setSelectedStartup] = useState(null);
  const [notifications, setNotifications] = useState([]);
  
  const handleEditToggle = () => {
    setIsEditing(!isEditing);
  };

  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setInvestorData({ ...investorData, [name]: value });
  };

  const handleSave = () => {
    setIsEditing(false);
  };

  const handleAddComment = () => {
    if (newComment.trim()) {
      setComments([...comments, newComment]);
      setNewComment('');
    }
  };

  const handleDeleteComment = (index) => {
    const updatedComments = comments.filter((_, idx) => idx !== index);
    setComments(updatedComments);
  };

  const handleAddTask = () => {
    if (newTask.trim()) {
      setTasks([...tasks, { id: tasks.length + 1, task: newTask, completed: false }]);
      setNewTask('');
    }
  };

  const handleTaskToggle = (id) => {
    setTasks(tasks.map(task => task.id === id ? { ...task, completed: !task.completed } : task));
  };

  const getOption = () => ({
    title: { text: 'Investment Overview' },
    tooltip: {},
    xAxis: { data: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul'] },
    yAxis: {},
    series: [{
      name: 'Investments',
      type: 'bar',
      data: [5, 20, 36, 10, 10, 20, 30],
    }],
  });

  const sectorOptions = ["Technology", "Healthcare", "Finance", "Education"];
  const locationOptions = ["North America", "Europe", "Asia"];
  const stageOptions = ["Seed", "Series A", "Series B", "IPO"];

  const handleSectorChange = (sector) => {
    setSectors((prev) =>
      prev.includes(sector) ? prev.filter(s => s !== sector) : [...prev, sector]
    );
  };

  const handleLocationChange = (location) => {
    setLocations((prev) =>
      prev.includes(location) ? prev.filter(l => l !== location) : [...prev, location]
    );
  };

  const handleStageChange = (stage) => {
    setStages((prev) =>
      prev.includes(stage) ? prev.filter(s => s !== stage) : [...prev, stage]
    );
  };

  const handlePreferencesSave = () => {
    if (sectors.length === 0 || locations.length === 0 || stages.length === 0) {
      setError('Please select at least one sector, location, and stage.');
      return;
    }
    if (fundingRange[0] >= fundingRange[1]) {
      setError('Minimum funding must be less than maximum funding.');
      return;
    }
    setError('');
    setIsEditable(false);
  };

  const showModal = () => setVisible(true);
  const handleCancel = () => setVisible(false);
  
  const handleInputChangeEntry = (e) => {
    const { name, value } = e.target;
    setNewEntry({ ...newEntry, [name]: value });
  };

  const handleSelectChange = (name, value) => {
    setNewEntry({ ...newEntry, [name]: value });
  };

  const handleDateChange = (date, dateString) => {
    setNewEntry({ ...newEntry, date: dateString });
  };

  const handleSubmit = () => {
    setEngagements([...engagements, newEntry]);
    notification.success({ message: 'Engagement added successfully!' });
    setVisible(false);
    setNewEntry({ date: '', type: '', summary: '', category: '' });
  };

  const filteredEngagements = engagements.filter(e =>
    (filter.type ? e.type === filter.type : true) &&
    (filter.category ? e.category === filter.category : true)
  );

  const notifyUser = (message) => {
    setNotifications([...notifications, message]);
    setTimeout(() => {
      setNotifications(notifications.filter((_, index) => index !== 0));
    }, 3000);
  };

  const handleCardClick = (startup) => {
    setSelectedStartup(startup);
    notifyUser(`You are viewing ${startup.name}`);
  };

  return (
    <div style={{ width: '100vw', height: '100vh', padding: '20px', overflow: 'auto' }}>
      <div style={{ marginBottom: '20px' }}>
        {isEditing ? (
          <input name="name" value={investorData.name} onChange={handleInputChange} />
        ) : (
          <h2>{investorData.name}</h2>
        )}
        {isEditing ? (
          <input name="organization" value={investorData.organization} onChange={handleInputChange} />
        ) : (
          <p>{investorData.organization}</p>
        )}
        {isEditing ? (
          <input name="title" value={investorData.title} onChange={handleInputChange} />
        ) : (
          <p>{investorData.title}</p>
        )}
        {isEditing ? (
          <input name="contact" value={investorData.contact} onChange={handleInputChange} />
        ) : (
          <p>{investorData.contact}</p>
        )}
        <button onClick={isEditing ? handleSave : handleEditToggle}>
          {isEditing ? 'Save' : 'Edit'}
        </button>
      </div>
      
      <div style={{ marginBottom: '20px' }}>
        <h3>Comments</h3>
        <textarea value={newComment} onChange={(e) => setNewComment(e.target.value)} />
        <button onClick={handleAddComment}>Add Comment</button>
        <ul>
          {comments.map((comment, index) => (
            <li key={index}>
              {comment} <button onClick={() => handleDeleteComment(index)}>Delete</button>
            </li>
          ))}
        </ul>
      </div>

      <div style={{ marginBottom: '20px' }}>
        <h3>Tasks</h3>
        <input value={newTask} onChange={(e) => setNewTask(e.target.value)} />
        <button onClick={handleAddTask}>Add Task</button>
        <ul>
          {tasks.map(task => (
            <li key={task.id} style={{ textDecoration: task.completed ? 'line-through' : 'none' }}>
              <input type="checkbox" checked={task.completed} onChange={() => handleTaskToggle(task.id)} />
              {task.task}
            </li>
          ))}
        </ul>
      </div>

      <div style={{ marginBottom: '20px' }}>
        <h3>Investment Overview</h3>
        <ReactECharts option={getOption()} />
      </div>

      <div style={{ marginBottom: '20px' }}>
        <h3>Investor Preferences</h3>
        {error && <p style={{ color: 'red' }}>{error}</p>}
        <div>
          <h4>Sectors</h4>
          <div>
            {sectorOptions.map((sector) => (
              <label key={sector}>
                <input 
                  type="checkbox" 
                  checked={sectors.includes(sector)}
                  onChange={() => handleSectorChange(sector)} 
                  disabled={!isEditable}
                />
                {sector}
              </label>
            ))}
          </div>
        </div>
        
        <div>
          <h4>Funding Range</h4>
          <div>
            <span>{`$${fundingRange[0]} - $${fundingRange[1]}`}</span>
            <Slider
              min={10000}
              max={5000000}
              value={fundingRange}
              onChange={setFundingRange}
              disabled={!isEditable}
            />
          </div>
        </div>

        <div>
          <h4>Geographical Locations</h4>
          <div>
            {locationOptions.map((location) => (
              <label key={location}>
                <input 
                  type="checkbox" 
                  checked={locations.includes(location)}
                  onChange={() => handleLocationChange(location)} 
                  disabled={!isEditable}
                />
                {location}
              </label>
            ))}
          </div>
        </div>

        <div>
          <h4>Investment Stages</h4>
          <div>
            {stageOptions.map((stage) => (
              <label key={stage}>
                <input 
                  type="checkbox" 
                  checked={stages.includes(stage)}
                  onChange={() => handleStageChange(stage)} 
                  disabled={!isEditable}
                />
                {stage}
              </label>
            ))}
          </div>
        </div>

        <button onClick={() => setIsEditable(!isEditable)}>
          {isEditable ? 'Cancel' : 'Edit Preferences'}
        </button>
        {isEditable && <button onClick={handlePreferencesSave}>Save Changes</button>}
      </div>

      <div>
        <h3>Engagement History</h3>
        <Button type="primary" onClick={showModal}>New Entry</Button>
        <div>
          <Select placeholder="Filter by Type" onChange={(value) => setFilter({ ...filter, type: value })}>
            <Option value="Meeting">Meeting</Option>
            <Option value="Call">Call</Option>
            <Option value="Email">Email</Option>
          </Select>
          <Select placeholder="Filter by Category" onChange={(value) => setFilter({ ...filter, category: value })}>
            <Option value="High Priority">High Priority</Option>
            <Option value="Follow-up">Follow-up</Option>
            <Option value="Low Priority">Low Priority</Option>
          </Select>
        </div>
        <ReactECharts option={getOption()} />
        <ul>
          {filteredEngagements.map((engagement, index) => (
            <li key={index}>
              {engagement.date} - {engagement.type}: {engagement.summary} ({engagement.category})
            </li>
          ))}
        </ul>
        <Modal title="New Engagement" visible={visible} onOk={handleSubmit} onCancel={handleCancel}>
          <DatePicker onChange={handleDateChange} />
          <Select placeholder="Type" onChange={(value) => handleSelectChange('type', value)}>
            <Option value="Meeting">Meeting</Option>
            <Option value="Call">Call</Option>
            <Option value="Email">Email</Option>
          </Select>
          <Input placeholder="Summary" name="summary" onChange={handleInputChangeEntry} />
          <Select placeholder="Category" onChange={(value) => handleSelectChange('category', value)}>
            <Option value="High Priority">High Priority</Option>
            <Option value="Follow-up">Follow-up</Option>
            <Option value="Low Priority">Low Priority</Option>
          </Select>
        </Modal>
      </div>

      <div style={{ display: 'flex', flexDirection: 'column', marginTop: '20px' }}>
        {filteredData.map((startup, index) => (
          <div key={index} 
               onClick={() => handleCardClick(startup)} 
               style={{ border: '1px solid #ccc', padding: '20px', margin: '10px', cursor: 'pointer', transition: '0.3s', boxShadow: '0 4px 8px rgba(0,0,0,0.2)' }}>
            <h3>{startup.name}</h3>
            <p>{startup.description}</p>
            <p>Relevance Score: {startup.relevanceScore}</p>
          </div>
        ))}
      </div>
      {selectedStartup && (
        <div style={{ position: 'fixed', top: '0', left: '0', right: '0', bottom: '0', backgroundColor: 'rgba(0,0,0,0.5)', display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
          <div style={{ background: 'white', padding: '20px', borderRadius: '5px', width: '50%' }}>
            <h2>{selectedStartup.name}</h2>
            <p>{selectedStartup.description}</p>
            <p>Sector: {selectedStartup.sector}</p>
            <p>Funding Stage: {selectedStartup.fundingStage}</p>
            <p>Geographic Focus: {selectedStartup.geographicFocus}</p>
            <p>Relevance Score: {selectedStartup.relevanceScore}</p>
            <button onClick={() => setSelectedStartup(null)}>Close</button>
            <button>Book a Meeting</button>
          </div>
        </div>
      )}
      {notifications.map((notification, index) => (
        <div key={index} style={{ position: 'fixed', top: `${20 + index * 50}px`, right: '20px', background: 'lightyellow', padding: '10px', borderRadius: '5px' }}>
          {notification}
        </div>
      ))}
    </div>
  );
};

export default InvestorProfileContainer;
``` 

This code encapsulates all the components and functionalities described in the requirements into a single `InvestorProfileContainer` component, ensuring it is self-contained and functional without external dependencies.

```javascript
// File Path: EngagementTimeline.js
import React, { useState } from 'react';
import ReactECharts from 'echarts-for-react';
import Modal from 'react-modal';

const dummyData = [
    { date: "2023-01-01", type: "Meeting", details: "Discussion on investment strategies", frequency: 5 },
    { date: "2023-01-15", type: "Call", details: "Follow-up on previous meeting", frequency: 3 },
    { date: "2023-02-10", type: "Email", details: "Quarterly report sent", frequency: 8 }
];

const EngagementTimeline = () => {
    const [filterType, setFilterType] = useState('All');
    const [modalIsOpen, setModalIsOpen] = useState(false);
    const [selectedEngagement, setSelectedEngagement] = useState(null);
    
    const filteredData = dummyData.filter(item => filterType === 'All' || item.type === filterType);

    const heatMapOption = {
        tooltip: {},
        visualMap: {
            min: 0,
            max: 8,
            inRange: {
                color: ['#e0ffff', '#006edd']
            }
        },
        xAxis: {
            type: 'category',
            data: filteredData.map(item => item.date),
            name: 'Date'
        },
        yAxis: {
            type: 'value',
            name: 'Frequency'
        },
        series: [{
            name: 'Engagement Frequency',
            type: 'heatmap',
            data: filteredData.map(item => [item.date, item.frequency]),
            label: {
                show: true
            }
        }]
    };

    const handleNodeClick = (item) => {
        setSelectedEngagement(item);
        setModalIsOpen(true);
    };

    const handleCloseModal = () => {
        setModalIsOpen(false);
        setSelectedEngagement(null);
    };

    const renderTreeGraph = () => {
        // Assume this function renders a tree graph based on dummy data
        return (
            <div>
                {filteredData.map(item => (
                    <div key={item.date} onClick={() => handleNodeClick(item)}>
                        {item.type} on {item.date}
                    </div>
                ))}
            </div>
        );
    };

    return (
        <div style={{ width: '1920px', height: '1080px', display: 'flex', flexDirection: 'column' }}>
            <div>
                <select onChange={(e) => setFilterType(e.target.value)}>
                    <option value="All">All</option>
                    <option value="Meeting">Meeting</option>
                    <option value="Call">Call</option>
                    <option value="Email">Email</option>
                </select>
            </div>
            <div style={{ display: 'flex', flex: 1 }}>
                <div style={{ width: '50%' }}>
                    <ReactECharts option={heatMapOption} />
                </div>
                <div style={{ width: '50%' }}>
                    {renderTreeGraph()}
                </div>
            </div>
            <Modal isOpen={modalIsOpen} onRequestClose={handleCloseModal}>
                <h2>Engagement Details</h2>
                {selectedEngagement && (
                    <div>
                        <p>Date: {selectedEngagement.date}</p>
                        <p>Type: {selectedEngagement.type}</p>
                        <p>Details: {selectedEngagement.details}</p>
                        <p>Frequency: {selectedEngagement.frequency}</p>
                    </div>
                )}
                <button onClick={handleCloseModal}>Close</button>
            </Modal>
        </div>
    );
};

export default EngagementTimeline;
```

```javascript
// File Path: HeatMap.js
import React, { useState } from 'react';
import ReactECharts from 'echarts-for-react';

const dummyData = {
  engagements: [
    { date: '2023-10-01', calls: 5, meetings: 3, emails: 2 },
    { date: '2023-10-02', calls: 2, meetings: 1, emails: 0 },
    { date: '2023-10-03', calls: 8, meetings: 4, emails: 1 },
    { date: '2023-10-04', calls: 0, meetings: 0, emails: 0 },
    // ... More dummy data for each day of the month
  ],
  engagementTypes: ['Calls', 'Meetings', 'Emails'],
  investors: ['Investor A', 'Investor B', 'Investor C', 'Investor D'],
};

const HeatMap = () => {
  const [selectedType, setSelectedType] = useState('Calls');
  const [selectedInvestors, setSelectedInvestors] = useState([]);
  const [filterRange, setFilterRange] = useState('daily');
  const [loading, setLoading] = useState(false);
  
  const handleTypeChange = (e) => setSelectedType(e.target.value);
  const handleInvestorChange = (e) => setSelectedInvestors(Array.from(e.target.selectedOptions, option => option.value));
  const handleRangeChange = (e) => setFilterRange(e.target.value);

  const getCellColor = (engagementCount) => {
    return engagementCount > 5 ? '#FF5733' : engagementCount > 2 ? '#FFC300' : '#DAF7A6';
  };

  const handleCellClick = (date) => {
    alert(`Detailed view for ${date}: ${JSON.stringify(dummyData.engagements.find(e => e.date === date))}`);
  };

  const getEngagements = () => {
    return dummyData.engagements.map((engagement) => ({
      date: engagement.date,
      count: engagement[selectedType.toLowerCase()] || 0,
    }));
  };

  const renderCells = () => {
    return getEngagements().map(({ date, count }) => (
      <div 
        key={date} 
        style={{ 
          backgroundColor: getCellColor(count), 
          width: '50px', 
          height: '50px', 
          display: 'inline-block', 
          margin: '2px', 
          cursor: 'pointer' 
        }} 
        onClick={() => handleCellClick(date)}
        onMouseEnter={() => alert(`Engagements on ${date}: ${count}`)}
      >
        {count}
      </div>
    ));
  };

  return (
    <div>
      <div>
        <select onChange={handleTypeChange}>
          {dummyData.engagementTypes.map(type => (
            <option key={type} value={type}>{type}</option>
          ))}
        </select>
        <select multiple onChange={handleInvestorChange}>
          {dummyData.investors.map(investor => (
            <option key={investor} value={investor}>{investor}</option>
          ))}
        </select>
        <select onChange={handleRangeChange}>
          <option value="daily">Daily</option>
          <option value="weekly">Weekly</option>
          <option value="monthly">Monthly</option>
        </select>
      </div>
      {loading && <div>Loading...</div>}
      <div style={{ display: 'flex', flexWrap: 'wrap', width: '400px' }}>
        {renderCells()}
      </div>
      <ReactECharts option={{
        series: [{
          type: 'line',
          data: getEngagements().map(({ date, count }) => [date, count]),
        }],
      }} />
    </div>
  );
};

export default HeatMap;
```
    ```

</ReactComponentCoder>

---

**Important**: Absolutely **NO missing logic** or functionality. **Fix every possible error, logic issue, or interaction** that may exist. The page must be fully functional and visually complete with modern, professional design. All UI elements and logic must work perfectly together with no placeholders or incomplete elements.




<ReactComponentCoder>
  <FilePath>
    ****File Path: FileName****
    <!-- Ensure this is placed at the top of your file with a valid file name. -->
  </FilePath>

  <GeneralInstructions>
    - Recoding **every single component**, ensuring full functionality, and **fixing any errors or logic issues**.
    - **DO NOT** import any external JS files‚Äîrecreate everything within the provided code.
    - Use only **dummy data** with no backend or API calls. Ensure the code works **flawlessly** for the current page setup.
    - **No logic errors** allowed: All components, mappings, charts, and interactions must function without issues. If errors exist in the provided code, **proactively identify and fix them**.
    - **Every component, feature, and interaction must be fully implemented and improved where necessary**. The page should be fully functional, visually complete, and **professionally enhanced**.
  </GeneralInstructions>

  <CodeRecreation>
    - Provide **full code** for every component and **fix any potential issues**.
    - **NO code should be missing, left out, simplified, or assumed**‚Äîevery piece of logic must be present and correct.
    - Recreate all components fully, **ensuring every part works together seamlessly**. **Fix any layout issues**, optimize UI, and implement **complete functionality** for all components.
  </CodeRecreation>

  <InteractionInstructions>
    - Ensure **ALL components** (e.g., search bars, filters, buttons, forms, charts) work **perfectly** together.
    - Validate that every interaction works as expected‚Äîsearching, filtering, clicking, chart updates, etc.
    - **NO part of the UI should be broken, unresponsive, or incorrectly implemented**‚Äîeverything must be functional.
    - The UI should be **visually optimized** with enhanced layouts and interactions that feel smooth, modern, and professional.
    - **Fix any layout or visual issues**. Ensure the page is **visually complete, fully functional**, and works together as a unified system without any bugs.
  </InteractionInstructions>

  <ValidationSteps>
    - After implementing **each component**, validate that it works as expected and fixes any issues.
    - Check all interactions (search, filter, click, chart rendering, form input) and **verify that everything is fully functional**.
    - **Verify the entire page** for responsiveness and errors‚Äîensure every part of the page is filled with working components.
    - **Proactively improve** areas of the UI that may be weak, unoptimized, or not user-friendly.
  </ValidationSteps>

  <GuidanceForLLM>
    - **Step-by-Step Approach**: Break down tasks to handle complex UI elements (like charts, filters, dynamic data mappings) to ensure everything works perfectly.
    - **Fix errors as you go**: Proactively identify and fix any logic, interaction, or rendering issues. **Do not leave anything broken**.
    - **Enhance Layout**: If the layout feels cluttered, unbalanced, or outdated, **improve it** to be modern, clean, and user-friendly. **No placeholders or incomplete elements**.
    - **No Summarization**: Recode every single line with improvements and do not leave out any logic or interaction. **Enhance the code where needed** and ensure everything is dynamically functional.
  </GuidanceForLLM>

  #### Plan
  - Use this plan to create code for the current page, enhancing functionality, layout, and interactions.
    ```plaintext
    Component Name: Startup Overview Page, Component requirements: # Final Plan for Startup Overview Page

## Purpose and Goals
The Startup Overview Page is designed to serve as a centralized hub for YC program members, providing a comprehensive profile of individual startups. Users will have access to key metrics, team members, funding status, and project details, enabling efficient updates and management‚Äîall in one place.

## Problem Solved
This page addresses the need for a centralized information repository, allowing for easy access and management of critical startup data. It enhances workflow efficiency by providing a clear, organized view of team structures and funding information, while facilitating real-time updates and edits to maintain current data.

## Colour Scheme
- **Primary Color**: #2A9D8F
- **Secondary Color**: #264653
- **Tertiary Color**: #E9C46A
- **Spacing**: 8px
- **Typography**: Roboto, sans-serif

## New Features and Enhancements

### 1. User Engagement Tools
- **Main Functionality**: Feedback system for team members to rate contributions or project status.
- **Key Components**: 
  - Rating widgets (1-5 stars)
  - Comment sections for qualitative feedback
- **Data Requirements**: Dummy data for ratings and comments.
- **User Interaction Flow**: Users click on a rating and leave comments in a text area.
- **Potential Challenges**: Implement moderation tools to ensure constructive feedback.

### 2. Advanced Data Visualization
- **Main Functionality**: Interactive charts using ECharts to display metrics over time.
- **Key Components**:
  - Line charts for funding trends
  - Bar graphs for user growth
  - Pie charts for funding distribution
- **Data Requirements**: Dummy data sets with timestamps.
- **User Interaction Flow**: Hover over data points for details and click to filter by timeframes.
- **Potential Challenges**: Focus on simplicity in data representation.

### 3. Interactivity and Dynamic Content
- **Main Functionality**: Interactive roadmap feature to visualize project milestones and timelines.
- **Key Components**:
  - Timeline component
  - Milestone indicators with descriptive tooltips
- **Data Requirements**: Dummy data for project milestones.
- **User Interaction Flow**: Click milestones to view details or update statuses.
- **Potential Challenges**: Implement zoom and scroll features to keep the roadmap clean.

### 4. Customization Options
- **Main Functionality**: Users can customize their dashboard layout.
- **Key Components**:
  - Draggable panels for dashboard components
  - Save layout settings in user preferences
- **Data Requirements**: Dummy data representing layout configurations.
- **User Interaction Flow**: Users rearrange panels and save their layout.
- **Potential Challenges**: Ensure a smooth drag-and-drop experience.

### 5. Productivity Tools
- **Main Functionality**: Task management tool for creating, assigning, and tracking tasks.
- **Key Components**:
  - Task lists with completion checkboxes
  - Assignment dropdowns for team members
- **Data Requirements**: Dummy data for tasks and assignees.
- **User Interaction Flow**: Create tasks, assign to members, and mark as complete.
- **Potential Challenges**: Consider a priority system for tasks.

### 6. Gamification Elements
- **Main Functionality**: Points and rewards system for team engagement.
- **Key Components**:
  - Points leaderboard for users
  - Achievement badges for milestones
- **Data Requirements**: Dummy data for user points and achievements.
- **User Interaction Flow**: View points and rankings on leaderboard.
- **Potential Challenges**: Balance fairness in point distribution.

### 7. Notification System
- **Main Functionality**: Notification system for task updates, project changes, or team feedback.
- **Key Components**:
  - Notification bell for alerts
  - Dropdown list for recent notifications
- **Data Requirements**: Dummy data for notifications.
- **User Interaction Flow**: Click alerts to view details.
- **Potential Challenges**: Users should be able to customize notification preferences.

## Prioritization of Ideas
1. Advanced Data Visualization
2. User Engagement Tools
3. Productivity Tools
4. Interactivity and Dynamic Content
5. Customization Options
6. Notification System
7. Gamification Elements

## Step-by-Step Implementation Plan

### Step 1: User Engagement Tools
- **Implementation Guidance**: 
  - Create a rating component using star icons and a comment input area.
  - Manage state with hooks to capture ratings and comments.
  - Store this data in a structured format for retrieval.
- **Edge Cases**: Handle scenarios with no rating or comment submissions.

### Step 2: Advanced Data Visualization
- **Implementation Guidance**: 
  - Use ECharts library to create interactive charts.
  - Structure data appropriately for each chart type.
  - Implement hover and click events for detailed views.
- **Edge Cases**: Test with various data sizes to ensure performance.

### Step 3: Interactivity and Dynamic Content
- **Implementation Guidance**: 
  - Develop a timeline component using a library like D3.js.
  - Populate it with milestone data and allow for updates.
  - Implement a tooltip system for milestone details.
- **Edge Cases**: Ensure that timelines with no milestones render correctly.

### Step 4: Customization Options
- **Implementation Guidance**: 
  - Create draggable components using libraries like react-beautiful-dnd.
  - Store the user‚Äôs layout preferences in local storage or a user profile.
- **Edge Cases**: Ensure that layout saving works consistently across sessions.

### Step 5: Productivity Tools
- **Implementation Guidance**: 
  - Build a task management interface with forms for task creation.
  - Use state management to track task progress.
  - Implement task assignment and completion logic.
- **Edge Cases**: Handle scenarios where tasks are assigned but not completed.

### Step 6: Gamification Elements
- **Implementation Guidance**: 
  - Create a system for assigning points based on user actions.
  - Develop a leaderboard component to display user standings.
  - Design badges that can be awarded for achievements.
- **Edge Cases**: Ensure points are accurately reflected after every action.

### Step 7: Notification System
- **Implementation Guidance**: 
  - Design a notification component that fetches updates.
  - Allow users to customize notification settings.
  - Implement a way to mark notifications as read.
- **Edge Cases**: Handle the situation where notifications fail to load.

## Enhancements and Optimizations
- **Performance**: Use lazy loading for charts and components to improve initial load time.
- **Accessibility**: Ensure that all components are keyboard navigable and screen reader friendly.
- **Responsive Design**: Although focused on desktop, ensure elements are adaptable in case of different screen sizes.

This comprehensive plan outlines the core logic and functionality needed to enhance the Startup Overview Page for YC program members, ensuring a user-friendly, interactive experience that caters to their organizational and management needs.
    ```

  #### RequiredCode
  - **RECODE AND FIX** every single line of the provided code, ensuring that it is fully functional, free of errors, and optimized for the current page.
    ```plaintext
    

```javascript
import React, { useState, useEffect } from 'react';
import ReactECharts from 'echarts-for-react';
import { useDrag, useDrop } from 'react-dnd';
import { Star } from 'react-stars';

const StartupProfileCard = () => {
  const [startupName, setStartupName] = useState("Current Startup Name");
  const [missionStatement, setMissionStatement] = useState("Our mission is to empower businesses.");
  const [isEditingTitle, setIsEditingTitle] = useState(false);
  const [isEditingMission, setIsEditingMission] = useState(false);
  const [errorTitle, setErrorTitle] = useState("");
  const [errorMission, setErrorMission] = useState("");
  const [collaborators, setCollaborators] = useState([]);
  const [newCollaborator, setNewCollaborator] = useState({ name: '', role: '', contact: '' });
  const [feedback, setFeedback] = useState('');
  const [feedbackList, setFeedbackList] = useState([{ userId: '1', feedback: 'Clear mission!' }]);
  const [milestones, setMilestones] = useState([{ milestone: 'Launch', status: 'Completed' }, { milestone: 'First 100 Users', status: 'In Progress' }]);
  const [notifications, setNotifications] = useState([{ type: 'update', message: 'Mission statement updated!', timestamp: '2023-10-01' }]);
  const [chartData, setChartData] = useState([{ month: 'Jan', users: 100 }, { month: 'Feb', users: 150 }]);
  const [customization, setCustomization] = useState({ fontSize: 16, color: '#000000' });
  const [dynamicMetrics, setDynamicMetrics] = useState([{ metric: 'User Growth', views: 200 }]);
  const [showNotification, setShowNotification] = useState(false);
  const [showComments, setShowComments] = useState(false);
  const [comments, setComments] = useState([{ userId: '1', comment: 'Great initiative!' }]);
  const [teamMembers, setTeamMembers] = useState([
    { id: 1, name: 'John Doe', role: 'Developer', email: 'john.doe@example.com', bio: 'Full stack developer with a passion for coding.', status: 'Available', rating: 4.5 },
    { id: 2, name: 'Jane Smith', role: 'Designer', email: 'jane.smith@example.com', bio: 'Creative designer with a love for UI/UX.', status: 'In a Meeting', rating: 4.0 },
    { id: 3, name: 'Alice Johnson', role: 'Project Manager', email: 'alice.johnson@example.com', bio: 'Experienced project manager focused on deliverables.', status: 'Available', rating: 5.0 }
  ]);

  const handleNameChange = (e) => {
    const value = e.target.value;
    const regex = /^[a-zA-Z0-9\s]*$/;

    if (value.length <= 50 && regex.test(value)) {
      setStartupName(value);
      setErrorTitle("");
    } else {
      setErrorTitle("Invalid characters or too long");
    }
  };

  const handleMissionChange = (e) => {
    const value = e.target.value;
    const regex = /^[a-zA-Z0-9\s,.!]*$/;

    if (value.length <= 150 && regex.test(value)) {
      setMissionStatement(value);
      setErrorMission("");
    } else {
      setErrorMission("Invalid characters or too long");
    }
  };

  const addCollaborator = () => {
    if (newCollaborator.name && newCollaborator.role && newCollaborator.contact) {
      setCollaborators([...collaborators, { ...newCollaborator, id: Date.now() }]);
      setNewCollaborator({ name: '', role: '', contact: '' });
    }
  };

  const removeCollaborator = (id) => {
    setCollaborators(collaborators.filter(collab => collab.id !== id));
  };

  const handleFeedbackSubmit = () => {
    setFeedbackList([...feedbackList, { userId: `${feedbackList.length + 1}`, feedback }]);
    setFeedback('');
  };

  const getOption = () => ({
    xAxis: {
      type: 'category',
      data: chartData.map(item => item.month)
    },
    yAxis: {
      type: 'value'
    },
    series: [{
      data: chartData.map(item => item.users),
      type: 'line'
    }]
  });

  const TeamMember = ({ member, index }) => {
    const [, ref] = useDrag({
      type: 'teamMember',
      item: { index }
    });

    const [, drop] = useDrop({
      accept: 'teamMember',
      hover(item) {
        if (item.index !== index) {
          moveMember(item.index, index);
          item.index = index;
        }
      }
    });

    return (
      <div ref={ref(drop())} style={{ padding: '10px', border: '1px solid #ccc', margin: '5px', backgroundColor: '#f9f9f9' }}>
        <h4 onClick={() => alert(`Details for ${member.name}`)}>{member.name}</h4>
        <p>Role: {member.role}</p>
        <p>Email: {member.email}</p>
        <p>Bio: {member.bio}</p>
        <p>Status: <span style={{ color: member.status === 'Available' ? 'green' : 'orange' }}>{member.status}</span></p>
        <Star 
          count={5} 
          value={member.rating} 
          onChange={(newRating) => alert(`Rating for ${member.name} updated to ${newRating}`)} 
        />
        <button onClick={() => alert(`Assign task to ${member.name}`)}>Assign Task</button>
      </div>
    );
  };

  const moveMember = (fromIndex, toIndex) => {
    const updatedMembers = [...teamMembers];
    const [movedMember] = updatedMembers.splice(fromIndex, 1);
    updatedMembers.splice(toIndex, 0, movedMember);
    setTeamMembers(updatedMembers);
  };

  return (
    <div style={{ width: '100vw', height: '100vh', padding: '20px', boxSizing: 'border-box' }}>
      <div>
        <h1 onClick={() => setIsEditingTitle(true)}>{isEditingTitle ? (
          <input type="text" value={startupName} onChange={handleNameChange} onBlur={() => setIsEditingTitle(false)} />
        ) : startupName}</h1>
        {errorTitle && <div style={{ color: 'red' }}>{errorTitle}</div>}
      </div>
      <div>
        <h2 onClick={() => setIsEditingMission(true)}>{isEditingMission ? (
          <textarea value={missionStatement} onChange={handleMissionChange} onBlur={() => setIsEditingMission(false)} />
        ) : missionStatement}</h2>
        {errorMission && <div style={{ color: 'red' }}>{errorMission}</div>}
      </div>

      <div>
        <h3>Collaborators</h3>
        {collaborators.map(collab => (
          <div key={collab.id}>
            <span>{collab.name} - {collab.role} - {collab.contact}</span>
            <button onClick={() => removeCollaborator(collab.id)}>Remove</button>
          </div>
        ))}
        <input
          type="text"
          placeholder="Name"
          value={newCollaborator.name}
          onChange={e => setNewCollaborator({ ...newCollaborator, name: e.target.value })}
        />
        <input
          type="text"
          placeholder="Role"
          value={newCollaborator.role}
          onChange={e => setNewCollaborator({ ...newCollaborator, role: e.target.value })}
        />
        <input
          type="text"
          placeholder="Contact"
          value={newCollaborator.contact}
          onChange={e => setNewCollaborator({ ...newCollaborator, contact: e.target.value })}
        />
        <button onClick={addCollaborator}>Add Collaborator</button>
      </div>

      <h3>Feedback</h3>
      <button onClick={() => setShowNotification(!showNotification)}>Leave Feedback</button>
      {showNotification && (
        <div>
          <textarea value={feedback} onChange={(e) => setFeedback(e.target.value)} />
          <button onClick={handleFeedbackSubmit}>Submit Feedback</button>
        </div>
      )}

      <div>
        <h3>Comments</h3>
        <button onClick={() => setShowComments(!showComments)}>Toggle Comments</button>
        {showComments && comments.map((comment, index) => (
          <div key={index}>{comment.comment}</div>
        ))}
      </div>

      <ReactECharts option={getOption()} style={{ height: '400px', width: '600px' }} />

      <div>
        {milestones.map((milestone, index) => (
          <div key={index} style={{ display: 'flex', marginBottom: '10px' }}>
            <div style={{ width: '200px', backgroundColor: milestone.status === 'Completed' ? 'green' : 'yellow' }}>
              {milestone.milestone}
            </div>
            <div>{milestone.status}</div>
          </div>
        ))}
      </div>

      <div>
        <h3>Notifications</h3>
        {notifications.map((note, index) => (
          <div key={index}>
            <span>{note.message} - {note.timestamp}</span>
            <button onClick={() => setNotifications(notifications.filter((_, i) => i !== index))}>Dismiss</button>
          </div>
        ))}
      </div>

      <div>
        <h3>Dynamic Metrics</h3>
        {dynamicMetrics.map((metric, index) => (
          <div key={index}>{metric.metric} - {metric.views} views</div>
        ))}
      </div>

      <div>
        <h3>Team List</h3>
        {teamMembers.map((member, index) => (
          <TeamMember key={member.id} member={member} index={index} />
        ))}
      </div>
    </div>
  );
};

export default StartupProfileCard;
```

```javascript
import React, { useState } from 'react';
import ReactECharts from 'echarts-for-react';

// FundingStatus Component
const FundingStatus = () => {
    return (
        <div style={{ display: 'flex', flexDirection: 'column', height: '100vh', width: '100vw' }}>
            <FundingRoundsTable />
            <BurnRateIndicator />
        </div>
    );
};

// FundingRoundsTable Component
const FundingRoundsTable = () => {
    const [fundingRounds, setFundingRounds] = useState([
        { id: 1, roundType: "Seed", amount: 500000, date: "2023-01-15", investors: ["Investor A", "Investor B"] },
        { id: 2, roundType: "Series A", amount: 2000000, date: "2023-06-20", investors: ["Investor C"] },
        { id: 3, roundType: "Series B", amount: 5000000, date: "2023-09-10", investors: ["Investor A", "Investor D"] }
    ]);
    
    const [sortConfig, setSortConfig] = useState({ key: null, direction: 'ascending' });
    const [filterType, setFilterType] = useState('');
    const [filterInvestor, setFilterInvestor] = useState('');
    
    const sortedRounds = [...fundingRounds].sort((a, b) => {
        if (sortConfig.key === 'amount') {
            return sortConfig.direction === 'ascending' ? a.amount - b.amount : b.amount - a.amount;
        }
        if (sortConfig.key === 'date') {
            return sortConfig.direction === 'ascending' ? new Date(a.date) - new Date(b.date) : new Date(b.date) - new Date(a.date);
        }
        return 0;
    }).filter(round => 
        (filterType ? round.roundType === filterType : true) &&
        (filterInvestor ? round.investors.includes(filterInvestor) : true)
    );

    const handleSort = (key) => {
        let direction = 'ascending';
        if (sortConfig.key === key && sortConfig.direction === 'ascending') {
            direction = 'descending';
        }
        setSortConfig({ key, direction });
    };

    const totalFundsRaised = fundingRounds.reduce((total, round) => total + round.amount, 0);
    const fundingTrendData = fundingRounds.map(round => ({ date: round.date, amount: round.amount }));
    
    const getOption = () => ({
        title: { text: 'Funding Trends Over Time' },
        tooltip: {},
        xAxis: {
            type: 'category',
            data: fundingTrendData.map(item => item.date)
        },
        yAxis: {
            type: 'value'
        },
        series: [{
            name: 'Amount Raised',
            type: 'line',
            data: fundingTrendData.map(item => item.amount)
        }]
    });

    return (
        <div style={{ flex: 1, padding: '20px' }}>
            <div>
                <input 
                    type="text" 
                    placeholder="Filter by Investor" 
                    value={filterInvestor} 
                    onChange={(e) => setFilterInvestor(e.target.value)} 
                />
                <select onChange={(e) => setFilterType(e.target.value)}>
                    <option value="">All Round Types</option>
                    <option value="Seed">Seed</option>
                    <option value="Series A">Series A</option>
                    <option value="Series B">Series B</option>
                </select>
            </div>
            <table style={{ width: '100%', marginTop: '20px', borderCollapse: 'collapse' }}>
                <thead>
                    <tr>
                        <th onClick={() => handleSort('roundType')}>Round Type</th>
                        <th onClick={() => handleSort('amount')}>Amount</th>
                        <th onClick={() => handleSort('date')}>Date</th>
                        <th>Investors</th>
                    </tr>
                </thead>
                <tbody>
                    {sortedRounds.map(round => (
                        <tr key={round.id}>
                            <td>{round.roundType}</td>
                            <td>{round.amount}</td>
                            <td>{round.date}</td>
                            <td>{round.investors.join(", ")}</td>
                        </tr>
                    ))}
                </tbody>
            </table>
            <div>
                <h3>Total Funds Raised: ${totalFundsRaised}</h3>
                <ReactECharts option={getOption()} />
            </div>
        </div>
    );
};

// BurnRateIndicator Component
const BurnRateIndicator = () => {
  const [burnRate, setBurnRate] = useState(60); // Percentage
  const [monthlyRevenue, setMonthlyRevenue] = useState(100000);
  const [monthlyExpenses, setMonthlyExpenses] = useState(60000);
  const runwayMonths = Math.floor(monthlyRevenue / monthlyExpenses);
  const historicalData = [40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150]; // Dummy data for last 12 months

  const getGaugeColor = () => {
    if (burnRate < 50) return 'green';
    if (burnRate >= 50 && burnRate < 75) return 'yellow';
    return 'red';
  };

  const option = {
    tooltip: {
      formatter: () => (
        `<div>
          <p>Current Burn Rate: ${burnRate}%</p>
          <p>Runway: ${runwayMonths} months</p>
          <p>Expenses: $${monthlyExpenses}</p>
          <p>Revenue: $${monthlyRevenue}</p>
        </div>`
      ),
      trigger: 'item',
    },
    series: [
      {
        name: 'Burn Rate',
        type: 'gauge',
        detail: { formatter: '{value}%' },
        data: [{ value: burnRate }],
        title: { fontSize: 20 },
        axisLine: {
          lineStyle: {
            color: [[0.5, 'green'], [0.75, 'yellow'], [1, 'red']],
            width: 30,
          },
        },
      },
    ],
  };

  const historicalOption = {
    tooltip: {
      trigger: 'axis',
      formatter: (params) => {
        const month = params[0].name;
        const burnRate = params[0].value;
        return `Month: ${month}<br/>Burn Rate: ${burnRate}`;
      },
    },
    xAxis: {
      type: 'category',
      data: [...Array(12).keys()].map(i => `Month ${i + 1}`),
    },
    yAxis: {
      type: 'value',
    },
    series: [{
      name: 'Historical Burn Rate',
      type: 'line',
      data: historicalData,
    }],
  };

  const handleForecast = (newExpenses, newRevenue) => {
    setMonthlyExpenses(newExpenses);
    setMonthlyRevenue(newRevenue);
    setBurnRate(Math.round((newExpenses / newRevenue) * 100));
  };

  return (
    <div style={{ flex: 1, padding: '20px', display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
      <div style={{ width: '100%', height: '300px' }}>
        <ReactECharts option={option} />
      </div>
      <div style={{ marginTop: '20px' }}>
        <h2>Historical Burn Rate</h2>
        <div style={{ width: '100%', height: '300px' }}>
          <ReactECharts option={historicalOption} />
        </div>
      </div>
      <div style={{ marginTop: '20px' }}>
        <h3>Forecasting Tool</h3>
        <input
          type="number"
          placeholder="Projected Expenses"
          onChange={(e) => handleForecast(Number(e.target.value), monthlyRevenue)}
        />
        <input
          type="number"
          placeholder="Projected Revenue"
          onChange={(e) => handleForecast(monthlyExpenses, Number(e.target.value))}
        />
      </div>
      <div style={{ marginTop: '20px', color: getGaugeColor() }}>
        <h3 style={{ color: getGaugeColor() }}>Current Burn Rate: {burnRate}%</h3>
      </div>
    </div>
  );
};

// Exporting the main FundingStatus component
export default FundingStatus;
```

This code creates a fully functional `FundingStatus` component that integrates both the `FundingRoundsTable` and the `BurnRateIndicator` components. Each component is self-contained, with all functionality implemented as requested, ensuring that the entire page is filled for a desktop resolution of 1920x1080. The design is responsive within the constraints of fixed dimensions for the charts and tables, and no external styling or imports are included.

```javascript
// File Path: EditButton.js

import React, { useState } from 'react';
import ReactECharts from 'echarts-for-react';

const EditButton = () => {
  const [isEditing, setIsEditing] = useState(false);
  const [fundingData, setFundingData] = useState([10000, 20000, 30000, 25000, 40000]);
  const [teamMembers, setTeamMembers] = useState([
    { name: 'Alice', role: 'CEO' },
    { name: 'Bob', role: 'CTO' },
  ]);
  const [newMember, setNewMember] = useState({ name: '', role: '' });
  const [notifications, setNotifications] = useState([]);
  const [customization, setCustomization] = useState('light');

  const toggleEditMode = () => {
    setIsEditing(!isEditing);
    if (!isEditing) {
      setNotifications([...notifications, 'Edit mode activated']);
    }
  };

  const handleAddTeamMember = () => {
    if (newMember.name && newMember.role) {
      setTeamMembers([...teamMembers, newMember]);
      setNewMember({ name: '', role: '' });
      setNotifications([...notifications, `${newMember.name} added as ${newMember.role}`]);
    }
  };

  const handleSaveChanges = () => {
    setIsEditing(false);
    setNotifications([...notifications, 'Changes saved']);
  };

  const chartOptions = {
    title: {
      text: 'Funding Over Time',
    },
    tooltip: {
      trigger: 'axis',
    },
    xAxis: {
      type: 'category',
      data: ['Q1', 'Q2', 'Q3', 'Q4', 'Q5'],
    },
    yAxis: {
      type: 'value',
    },
    series: [
      {
        name: 'Funding',
        type: 'line',
        data: fundingData,
      },
    ],
  };

  return (
    <div style={{ position: 'relative', width: '1920px', height: '1080px' }}>
      <button
        onClick={toggleEditMode}
        style={{
          position: 'absolute',
          bottom: '20px',
          right: '20px',
          backgroundColor: isEditing ? 'red' : 'blue',
          color: 'white',
          borderRadius: '50%',
          width: '60px',
          height: '60px',
          border: 'none',
          cursor: 'pointer',
        }}
      >
        ‚úèÔ∏è
      </button>
      {isEditing && (
        <div>
          <h3>Edit Team Members</h3>
          {teamMembers.map((member, index) => (
            <div key={index}>
              <span>{member.name} - {member.role}</span>
            </div>
          ))}
          <input
            placeholder="Name"
            value={newMember.name}
            onChange={(e) => setNewMember({ ...newMember, name: e.target.value })}
          />
          <input
            placeholder="Role"
            value={newMember.role}
            onChange={(e) => setNewMember({ ...newMember, role: e.target.value })}
          />
          <button onClick={handleAddTeamMember}>Add Team Member</button>
          <button onClick={handleSaveChanges}>Save Changes</button>
        </div>
      )}
      <h3>Notifications</h3>
      <div>
        {notifications.map((note, index) => (
          <div key={index}>{note}</div>
        ))}
      </div>
      <ReactECharts option={chartOptions} />
    </div>
  );
};

export default EditButton;
```

```javascript
// File Path: WebSocketManager.js
import React, { useEffect, useState } from 'react';
import ReactECharts from 'echarts-for-react';

const WebSocketManager = () => {
  const [engagementMetrics, setEngagementMetrics] = useState({
    totalMessages: 120,
    meetings: 15,
    engagementTrends: [5, 10, 15, 20],
  });
  
  const [notifications, setNotifications] = useState([
    { id: 1, message: "New message from mentor", read: false },
    { id: 2, message: "Meeting scheduled for tomorrow", read: false },
  ]);
  
  const [userPreferences, setUserPreferences] = useState({
    displayedMetrics: ["Engagement", "Performance"],
  });

  const [badges, setBadges] = useState([
    { id: 1, name: "Top Communicator", earned: true },
  ]);
  
  const [whiteboardShapes, setWhiteboardShapes] = useState([{ type: "circle", x: 30, y: 30, color: "blue" }]);

  useEffect(() => {
    const socket = new WebSocket('ws://dummy.websocket.url');
    
    socket.onmessage = (event) => {
      const data = JSON.parse(event.data);
      if (data.type === 'engagementUpdate') {
        setEngagementMetrics(data.payload);
      } else if (data.type === 'notificationUpdate') {
        setNotifications(data.payload);
      } else if (data.type === 'badgeUpdate') {
        setBadges(data.payload);
      } else if (data.type === 'whiteboardUpdate') {
        setWhiteboardShapes(data.payload);
      }
    };

    socket.onerror = (error) => {
      console.error("WebSocket Error: ", error);
    };

    socket.onclose = () => {
      console.log("WebSocket connection closed");
    };

    return () => {
      socket.close();
    };
  }, []);
  
  const markNotificationAsRead = (id) => {
    setNotifications(prevNotifications => 
      prevNotifications.map(notification => 
        notification.id === id ? { ...notification, read: true } : notification
      )
    );
  };

  const handleMetricSelection = (metric) => {
    setUserPreferences(prevPreferences => {
      const displayedMetrics = prevPreferences.displayedMetrics.includes(metric)
        ? prevPreferences.displayedMetrics.filter(m => m !== metric)
        : [...prevPreferences.displayedMetrics, metric];
      return { ...prevPreferences, displayedMetrics };
    });
  };

  const getOption = () => ({
    title: {
      text: 'Engagement Trends',
    },
    tooltip: {
      trigger: 'axis',
    },
    xAxis: {
      type: 'category',
      data: ['Jan', 'Feb', 'Mar', 'Apr'],
    },
    yAxis: {
      type: 'value',
    },
    series: [{
      name: 'Engagement',
      type: 'line',
      data: engagementMetrics.engagementTrends,
    }],
  });

  return (
    <div>
      <div>
        <h3>Metrics</h3>
        {userPreferences.displayedMetrics.includes("Engagement") && (
          <div>Total Messages: {engagementMetrics.totalMessages}</div>
        )}
        {userPreferences.displayedMetrics.includes("Performance") && (
          <div>Meetings: {engagementMetrics.meetings}</div>
        )}
      </div>
      <ReactECharts option={getOption()} />
      <div>
        <h3>Notifications</h3>
        <div>
          {notifications.map(notification => (
            <div key={notification.id} onClick={() => markNotificationAsRead(notification.id)} style={{ cursor: 'pointer', textDecoration: notification.read ? 'line-through' : 'none' }}>
              {notification.message}
            </div>
          ))}
        </div>
      </div>
      <div>
        <h3>Badges</h3>
        {badges.map(badge => (
          <div key={badge.id}>{badge.name} {badge.earned ? '(Earned)' : ''}</div>
        ))}
      </div>
      <div>
        <h3>Whiteboard</h3>
        <svg width="500" height="500">
          {whiteboardShapes.map((shape, index) => (
            shape.type === 'circle' ? (
              <circle key={index} cx={shape.x} cy={shape.y} r="20" fill={shape.color} />
            ) : null
          ))}
        </svg>
      </div>
    </div>
  );
};

export default WebSocketManager;
```
    ```

</ReactComponentCoder>

---

**Important**: Absolutely **NO missing logic** or functionality. **Fix every possible error, logic issue, or interaction** that may exist. The page must be fully functional and visually complete with modern, professional design. All UI elements and logic must work perfectly together with no placeholders or incomplete elements.



